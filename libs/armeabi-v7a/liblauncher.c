/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// int __fastcall Plat_VerifyHardwareKeyPrompt(_DWORD); weak
int j_memcmp(const void *s1, const void *s2, size_t n);
// int memcmp(const void *s1, const void *s2, size_t n);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int _errno(void); weak
// int __fastcall Unwind_GetDataRelBase(_DWORD); weak
// void abort(void);
// void *realloc(void *ptr, size_t size);
// int sscanf(const char *s, const char *format, ...);
// int __fastcall SDL_SetWindowPosition(_DWORD, _DWORD); weak
int __fastcall j_SDL_GL_CreateContext(int a1);
// int __fastcall SDL_GL_CreateContext(_DWORD); weak
// int access(const char *name, int type);
// int __cdecl SDL_GetError(_DWORD, _DWORD); weak
// int DevMsg(_DWORD, const char *, ...); weak
int j_strcmp(const char *s1, const char *s2);
// int strcmp(const char *s1, const char *s2);
// int __fastcall Plat_DebugString(_DWORD); weak
// time_t time(time_t *timer);
// int __fastcall Plat_SetCommandLine(_DWORD); weak
void *j_memset(void *s, int c, size_t n);
// void *memset(void *s, int c, size_t n);
int j_unlink(const char *name);
// int unlink(const char *name);
// int __fastcall SDL_QuitSubSystem(_DWORD); weak
// void *malloc(size_t size);
// char *getcwd(char *buf, size_t size);
// _DWORD DevMsg(const char *, ...); idb
// int __fastcall SDL_HideWindow(_DWORD); weak
// int __fastcall SDL_GL_SetAttribute(_DWORD, _DWORD); weak
void *j_memmove(void *dest, const void *src, size_t n);
// void *memmove(void *dest, const void *src, size_t n);
// _DWORD __cdecl operator new(unsigned int); idb
int __fastcall sub_35CC(_DWORD); // weak
// int system(const char *command);
// char *strcpy(char *dest, const char *src);
// int __fastcall SDL_ShowSimpleMessageBox(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl androidwrapper_dlopen(_DWORD); weak
// int fclose(FILE *stream);
// int setenv(const char *name, const char *value, int replace);
// char *strdup(const char *s);
// unsigned int sleep(unsigned int seconds);
// int Warning(const char *, ...); weak
// int __fastcall SDL_GetNumVideoDisplays(_DWORD); weak
// int __fastcall SDL_GetCurrentVideoDriver(_DWORD); weak
// char *strstr(const char *haystack, const char *needle);
// int __fastcall SpewOutputFunc(_DWORD); weak
// int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD); weak
// _DWORD __cdecl __cxxabiv1::__unexpected(void (*)(void)); idb
// int VStdLib_GetICVarFactory(void); weak
// int __fastcall SDL_GL_UnloadLibrary(_DWORD); weak
// int __fastcall SDL_SetWindowDisplayMode(_DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// int androidwrapper_vswprintf(void); weak
// int __fastcall SetUseRegal(_DWORD); weak
// _DWORD __cdecl __cxxabiv1::__terminate(void (*)(void)); idb
// double scalbn(double x, int n);
// int __fastcall SDL_CreateWindow(_DWORD); weak
// __int32 ftell(FILE *stream);
// int __cdecl CommandLine_Tier0(_DWORD, _DWORD); weak
// int __fastcall COM_TimestampedLog(_DWORD); weak
// int printf(const char *format, ...);
// int pthread_mutexattr_init(pthread_mutexattr_t *attr);
// int __cdecl SetAssertDialogParent(_DWORD, _DWORD); weak
// char *strncpy(char *dest, const char *src, size_t n);
// _DWORD ConMsg(const char *, ...); idb
// int __fastcall SDL_GetDesktopDisplayMode(_DWORD, _DWORD); weak
// int __fastcall SDL_GetDisplayBounds(_DWORD, _DWORD); weak
// int __fastcall SDL_WasInit(_DWORD); weak
// int __fastcall _cxa_finalize(_DWORD); weak
// int __fastcall SDL_GL_MakeCurrent(_DWORD); weak
// void exit(int status);
int j_dlclose(void *handle);
// int dlclose(void *handle);
// int fprintf(FILE *stream, const char *format, ...);
// int __fastcall ThreadSleep(_DWORD); weak
// int __cdecl SDL_SetWindowTitle(_DWORD); weak
// double floor(double x);
// int __cdecl SDL_GL_GetProcAddress(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall SDL_GL_LoadLibrary(_DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
char *j_strncat(char *dest, const char *src, size_t n);
// char *strncat(char *dest, const char *src, size_t n);
// unsigned __int32 strtoul(const char *nptr, char **endptr, int base);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int close(int fd);
// int __fastcall SDL_Init(_DWORD); weak
// int __fastcall BuildCmdLine(_DWORD, _DWORD, _DWORD); weak
// int __fastcall Plat_FloatTime(_DWORD); weak
// char *setlocale(int category, const char *locale);
// char *dlerror(void);
// int __fastcall _cxa_guard_release(_DWORD); weak
// int __fastcall SDL_ShowWindow(_DWORD); weak
// int __fastcall Unwind_GetRegionStart(_DWORD); weak
// void __cdecl operator delete(void *); idb
// int __fastcall Unwind_GetTextRelBase(_DWORD); weak
// _DWORD std::terminate(void); idb
// int __fastcall _cxa_begin_catch(_DWORD); weak
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int chdir(const char *path);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
int j_SDL_GL_DeleteContext();
// int SDL_GL_DeleteContext(void); weak
// _DWORD std::unexpected(void); idb
// int __fastcall SDL_RaiseWindow(_DWORD); weak
// int __fastcall Msg(_DWORD); weak
// int __fastcall SDL_SetWindowFullscreen(_DWORD, _DWORD); weak
// int __cdecl KeyValuesSystem(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void free(void *ptr);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
void *j_dlsym(void *handle, const char *name);
// void *dlsym(void *handle, const char *name);
// int atoi(const char *nptr);
// int stat(const char *file, struct stat *buf);
// int __fastcall GetAssertDialogParent(_DWORD); weak
// int __fastcall Plat_localtime(_DWORD, _DWORD); weak
// int __fastcall SDL_SetRegalMode(_DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// int __fastcall SDL_GL_SwapWindow(_DWORD); weak
// char *getenv(const char *name);
void *j_memcpy(void *dest, const void *src, size_t n);
// void *memcpy(void *dest, const void *src, size_t n);
// double strtod(const char *nptr, char **endptr);
// size_t strlen(const char *s);
// __int32 strtol(const char *nptr, char **endptr, int base);
// int fseek(FILE *stream, __int32 off, int whence);
int j_Error();
int j_strcasecmp(const char *s1, const char *s2);
// int strcasecmp(const char *s1, const char *s2);
// int __fastcall GetOpenGLEntryPoints(_DWORD); weak
// int __fastcall _cxa_guard_acquire(_DWORD); weak
// int __fastcall _aeabi_ul2f(_DWORD, _DWORD); weak
int start();
int __fastcall sub_443C(const char **a1, const char **a2);
int __fastcall sub_4450(int a1, const char *a2, char *a3);
signed int __fastcall sub_45A0(const char *a1, int a2, int a3, int a4);
_BYTE *__fastcall sub_464C(char *a1, size_t a2);
int __fastcall sub_4684(int result);
int __fastcall sub_46A4(int result);
_BYTE *__fastcall sub_46E8(_BYTE *result);
int __fastcall sub_4730(int a1, int a2);
signed int __fastcall sub_476C(char *a1, int a2);
int __fastcall sub_4818(int a1, int a2, const char *a3, int a4);
_BOOL4 __fastcall sub_48D0(const char *a1, const char *a2);
signed int __fastcall sub_4930(const char *a1, unsigned int a2, int a3);
int __fastcall sub_4A74(int a1, int a2, size_t a3, int a4);
const char *__fastcall sub_4D4C(int a1, int a2);
int __fastcall sub_4DC0(int a1);
int __fastcall sub_4E60(char *a1, size_t a2, _BYTE *a3);
int __fastcall sub_4EC8(int a1, int a2, int a3, int a4);
int __fastcall sub_4F0C(int result);
FILE *__fastcall sub_4F84(const char *a1);
int __fastcall sub_5078(const char *a1, int *a2, int *a3, int *a4);
int __fastcall sub_515C(int a1);
int __fastcall sub_599C(int a1, const char *a2, int a3);
int __fastcall sub_5A90(int a1, const char *a2, int a3);
int __fastcall sub_60FC(int a1, int a2, int a3, int a4);
int __fastcall sub_6580(int a1, const char *a2, int a3, int a4);
void __fastcall sub_65D8(int a1, int a2, int a3, int a4);
int __fastcall sub_6600(int a1, int a2, int a3, void *a4);
void __fastcall sub_667C(int a1, int a2, int a3, int a4);
int __fastcall sub_66A4(int a1, int a2, int a3, int a4);
int __fastcall sub_66C8(int a1, int a2, int a3);
int __fastcall sub_6728(int a1, int a2, int a3);
void *__fastcall sub_689C(void *result, int a2, int a3, int a4);
_DWORD *__fastcall sub_6920(_DWORD *result, int a2, int a3);
void sub_6958();
int __fastcall sub_6968(int a1, int a2);
void sub_6984();
signed int __fastcall sub_69AC(int a1);
int sub_6C04(); // weak
_BYTE *__fastcall sub_6D14(int a1, int a2);
int __fastcall sub_6D8C(int a1, int a2);
int __fastcall sub_6DC8(int a1, int a2);
int sub_6E38();
int __fastcall sub_6E7C(int a1, int a2);
int __fastcall sub_6F34(int a1, const char *a2);
char *__fastcall sub_7018(int a1, int a2);
signed int __fastcall sub_7220(int a1);
void __fastcall sub_7464(_BYTE *a1, int a2);
int __fastcall sub_7584(int a1, int a2);
void __fastcall sub_75C8(_BYTE *a1, _BYTE *a2, int a3);
signed int __fastcall LauncherMainAndroid(int a1, int a2, int a3);
int sub_7F58();
int __fastcall sub_7F68(int result);
int __fastcall sub_7F7C(int a1, int a2);
void __fastcall sub_7FBC(int a1, int a2, int a3, int a4);
void __fastcall sub_7FE4(int a1, int a2);
int __fastcall sub_80A0(int a1, int a2, int a3, int a4);
void __fastcall sub_811C(int a1, int a2, int a3, int a4);
int __fastcall sub_8144(int a1, int a2, int a3, int a4);
void __fastcall sub_81CC(int a1, int a2, int a3, int a4);
void __fastcall sub_81F4(int a1, int a2, int a3, int a4);
void __fastcall sub_821C(int a1, int a2, int a3, int a4);
int __fastcall sub_8244(int result);
int __fastcall sub_82F0(int a1, int a2);
int __fastcall sub_867C(int a1, int a2);
void __fastcall sub_8A00(int a1, int a2);
int __fastcall sub_9188(int a1, int a2);
signed int __fastcall sub_93F0(int a1, unsigned int a2);
int __fastcall sub_974C(int a1);
void sub_98E4();
int __fastcall sub_98F4(int a1);
int sub_9914(); // weak
int __fastcall sub_9948(int a1, int a2, int a3, int a4);
int __fastcall sub_99AC(int result);
int __fastcall sub_9BA0(int result);
int __fastcall sub_9BBC(int a1);
void __fastcall sub_9D54(int a1, int a2, int a3, int a4);
int __fastcall sub_9E74(int a1, int a2, _BYTE *a3);
int __fastcall sub_A2FC(int a1, const char *a2, int a3);
int __fastcall sub_A3A4(int result, const char *a2, int a3);
void __fastcall sub_A500(int a1, int a2, int a3);
void __fastcall sub_A6D8(int a1, int a2);
void __fastcall sub_A764(int a1, int a2, int a3);
signed int __fastcall sub_AA28(int a1, int a2);
int __fastcall sub_AD74(int a1, int a2, int a3);
void __fastcall sub_AE24(int a1, int a2, int a3, int a4);
void __fastcall sub_AE58(int a1, int a2, int a3, int a4);
int __fastcall sub_AE80(int a1, int a2, int a3, int a4);
int __fastcall sub_AEA8(int a1, int a2, int a3);
void __fastcall sub_AF70(int a1, int a2, int a3, int a4);
void __fastcall sub_AF98(int a1, int a2, int a3, int a4);
int __fastcall sub_AFDC(int a1, int a2, int a3, int a4);
_BYTE *__fastcall sub_B0A4(_BYTE *result, _BYTE *a2);
_DWORD *__fastcall sub_B0E8(_DWORD *result);
signed int sub_B104();
int sub_B114();
int __fastcall sub_B12C(int result, int a2, char *a3, int a4);
int __fastcall sub_B178(int result);
int __fastcall sub_B198(int a1);
_BOOL4 __fastcall sub_B1A8(int a1, int a2);
int __fastcall sub_B1C0(int result, int a2);
int __fastcall sub_B1D4(int a1);
int __fastcall sub_B1E4(int a1);
_DWORD *__fastcall sub_B204(_DWORD *result);
signed int sub_B220();
int __fastcall sub_B230(int a1);
_BOOL4 __fastcall sub_B248(int a1, int a2);
_BOOL4 __fastcall sub_B264(int a1, int a2);
int __fastcall sub_B26C(int a1);
int __fastcall sub_B280(int result, int a2);
int __fastcall sub_B298(int a1);
int __fastcall sub_B2AC(int a1);
int __fastcall sub_B2C0(int a1);
int sub_B2C8();
int __fastcall sub_B2D8(int result);
int __fastcall sub_B2F8(int a1, int a2);
int __fastcall sub_B30C(int a1, int a2);
int __fastcall sub_B314(int a1, int a2);
int __fastcall sub_B328(int a1, int a2);
int __fastcall sub_B330(int a1, int a2);
int __fastcall sub_B344(int a1, int a2);
void *__fastcall sub_B34C(void *a1, int a2, int a3, int a4);
void *__fastcall sub_B370(void *a1, int a2, int a3, int a4);
int __fastcall sub_B394(int a1, int a2, int a3, int a4);
void *__fastcall sub_B3D0(int a1, int a2, int a3, int a4);
int __fastcall sub_B3EC(int result);
int __fastcall sub_B4A4(int result, int a2);
int __fastcall sub_B574(int a1, const char *a2);
int __fastcall sub_B648(int, int, char *s, int, int, char, char, int); // idb
int __fastcall sub_B708(int a1, const char *a2);
int __fastcall sub_B7B8(int result, int a2);
int __fastcall sub_B7F0(int _R0, int _R1);
int __fastcall sub_B838(int result, char *a2);
int sub_B8D4();
char *__fastcall sub_BB6C(_DWORD *a1, const char *a2);
char *__fastcall sub_C09C(int a1, int a2, int a3);
int __fastcall sub_C148(int a1, int a2, int a3, int a4);
_BOOL4 __fastcall sub_C1A4(_DWORD *a1);
int __fastcall sub_C1C8(int a1, int a2, int a3);
int (***__fastcall sub_C6D8(int a1, int a2, int a3))(void);
signed int __fastcall sub_C770(int a1, int a2);
void sub_C790();
void sub_C7A0();
void sub_C7A8();
void sub_C7B8();
void sub_C7C0();
void sub_C7D0();
char *sub_C7D8();
char *sub_C7F0();
int sub_C7F8();
int sub_C808();
int __fastcall sub_C810(int a1, int a2, int a3, int a4);
void *__fastcall sub_C838(int a1, int a2, int a3, int a4);
int __fastcall sub_C868(char *s2, _DWORD *a2, int a3, int a4);
int __fastcall sub_C8B4(int a1, int a2, int a3, int a4);
void *__fastcall sub_C8E0(int a1, int a2, int a3, int a4);
int __fastcall CreateInterface(char *s2, _DWORD *a2, int a3, int a4);
void *__fastcall sub_C934(void *a1, int a2, int a3, int a4);
int __fastcall sub_C980(const char *a1, int a2, int a3, int a4);
int __fastcall sub_CA38(int a1, int a2);
void *__fastcall sub_CB24(void *result);
void *__fastcall sub_CB40(void *result);
void *__fastcall sub_CB9C(int a1, int a2, _DWORD *a3, int *a4);
int __fastcall sub_CCB4(int a1, int *a2, int a3);
int __fastcall sub_CD1C(int a1, int a2, int a3, int a4);
int __fastcall sub_CD50(int a1, int a2, int a3, int a4);
int __fastcall sub_CD70(int a1, int a2, int a3, int a4);
int __fastcall sub_CD8C(int *a1, int a2, int a3, int a4);
int __fastcall sub_CDD8(int a1, int *a2, int a3);
signed int __fastcall sub_CE70(int a1, int a2, int a3, int a4);
int __fastcall sub_CEA0(int result);
_DWORD *__fastcall sub_CECC(int a1, int a2);
int __fastcall sub_CF08(_DWORD *a1);
char *__fastcall sub_CF20(int a1, int a2, _BYTE *a3, _BYTE *a4);
char *__fastcall sub_D19C(int a1, int a2, int a3, int a4, const void *a5, int a6);
char *__fastcall sub_D254(char *s, int a2, int a3, int a4, char *sa);
int __fastcall sub_D420(int a1);
int __fastcall sub_D440(int result);
int __fastcall sub_D514(int a1);
int __fastcall sub_D5C4(int a1, int a2);
int __fastcall sub_DB08(int a1, int a2, int a3, int a4);
int __fastcall sub_DB40(int a1, int a2, int a3, int a4);
void __fastcall sub_DB5C(int a1);
int __fastcall sub_DBF0(int result, const char *a2, int a3);
int __fastcall sub_DCF8(int a1, const char *a2, int a3);
int __fastcall sub_DDE0(int a1, const char *a2, int a3);
int __fastcall sub_DF20(int a1, const char *a2, int a3, int a4);
int __fastcall sub_DF4C(int a1, const char *a2);
void __fastcall sub_E018(int a1, const char *a2);
char *__fastcall sub_E13C(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_E238(int a1, const char *a2, int a3);
_DWORD *__fastcall sub_E31C(int a1, const char *a2, char *a3);
int __fastcall sub_E3E8(int a1, const char *a2, int a3);
int __fastcall sub_E694(int a1, int a2, int a3, int a4);
char *__fastcall sub_E778(char *result, int a2, int a3);
int __fastcall sub_E8D8(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_E9E0(int result, int a2, int a3, int a4);
int __fastcall sub_EA24(int result, int a2, int a3, int a4);
int __fastcall sub_EAB0(int result, int a2, int a3);
int __fastcall sub_EAE4(int result);
int __fastcall sub_EB0C(int result, int a2, int a3, int a4);
void __fastcall sub_EB34(int *a1, int a2, int a3);
int __fastcall sub_F228(int a1, int a2, signed int a3);
int __fastcall sub_F70C(int a1, int a2);
signed int __fastcall sub_FB40(int a1, char *a2);
int __fastcall sub_FC28(int a1, int (__fastcall ***a2)(_DWORD, _DWORD), int a3);
signed int __fastcall sub_FCE0(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_10210(int, int, char *s, int, int); // idb
int __fastcall sub_102CC(int a1, int a2, char *a3);
_DWORD *__fastcall sub_103D0(_DWORD *result, const char *a2, const char *a3, int a4, int a5, int a6);
char *__fastcall sub_104E8(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7);
char *__fastcall sub_108F4(char *result, int a2, int a3, int a4, int a5, int a6, int a7, char a8);
int sub_11258(); // weak
int __fastcall sub_112C4(int a1, int a2, int a3, int a4);
void *__fastcall sub_112F4(void *result, int a2, int a3, int a4);
_DWORD *__fastcall sub_1137C(_DWORD *result, int a2, int a3);
void __fastcall sub_113B8(int a1, int a2, int a3, int a4);
int __fastcall sub_113E0(int a1, int a2, int a3, int a4);
void __fastcall sub_11404(int a1, int a2, int a3, int a4);
void __fastcall sub_1142C(int a1, int a2, int a3, int a4);
void __fastcall sub_11454(int a1, int a2, int a3, int a4);
void *__fastcall sub_114AC(void *result, int a2, int a3, int a4);
_DWORD *__fastcall sub_11534(_DWORD *result, int a2, int a3);
void __fastcall sub_11570(int a1, int a2, int a3, int a4);
int __fastcall sub_11688(int a1);
signed int __fastcall sub_116D4(int a1, int a2, char *a3, int a4);
signed int __fastcall sub_1172C(const char *a1, int a2, signed int a3, void *a4, signed int a5);
_BYTE *__fastcall sub_119B8(_BYTE *result);
int __fastcall sub_11A70(const char *a1, const char *a2);
signed int __fastcall sub_11BC8(_BYTE *a1, _BYTE *a2, int a3);
_BYTE *__fastcall sub_12140(_BYTE *a1, _BYTE *a2);
_BYTE *__fastcall sub_121F8(_BYTE *a1, _BYTE *a2);
signed int __fastcall sub_12208(int a1, _BYTE *a2, int a3);
_BYTE *__fastcall sub_122EC(_BYTE *result, int a2, int a3);
char *__fastcall sub_12330(char *a1, const char *a2, size_t a3);
_DWORD *__fastcall sub_12354(_DWORD *result, int a2, unsigned int a3);
int sub_12440(char *a1, size_t a2, const char *a3, ...);
int __fastcall sub_12498(char *a1, size_t a2, const char *a3, void *a4);
int __fastcall sub_124C8(char *a1, size_t a2, const char *a3, void *a4, _BYTE *a5);
char *__fastcall sub_1250C(const char *a1, const char *a2, unsigned int a3, signed int a4);
signed int __fastcall sub_12944(unsigned int a1);
unsigned int *__fastcall sub_129B0(int a1, unsigned int a2, _BYTE *a3, int a4);
char *__fastcall sub_12B7C(char *result, _DWORD *a2, signed int a3, int a4);
int __fastcall sub_12C04(int a1, _BYTE *a2, int a3, char a4);
int __fastcall sub_12C90(const char *a1);
signed int __fastcall sub_13234(const char *a1, int a2, int a3, int a4);
char *__fastcall sub_1325C(const char *a1, char *a2, signed int a3);
char *__fastcall sub_1335C(const char *a1, const char *a2, signed int a3);
signed int __fastcall sub_13390(const char *a1, int a2, int a3, int a4);
_BYTE *__fastcall sub_133C8(_BYTE *result, char a2);
int __fastcall sub_13450(const char *a1, size_t a2);
size_t __fastcall sub_1350C(const char *a1, int a2, int a3, int a4);
const char *__fastcall sub_1353C(const char *result, void *a2, int a3);
const char *__fastcall sub_135BC(const char *a1, int a2, int a3, int a4);
signed int __fastcall sub_13640(_BYTE *a1, int a2, unsigned __int8 a3);
signed int __fastcall sub_13738(const char *a1, int a2);
int __fastcall sub_1381C(char *buf, size_t size, char *src, char *src); // idb
signed int __fastcall sub_13A80(int a1);
int __fastcall sub_13AF0(int, char *s, int, int, int, char); // idb
char *__fastcall sub_13BE8(const char *a1, signed int a2, int a3, int a4);
signed int __fastcall sub_13CC0(const char *a1, signed int a2, char *a3, signed int a4);
int __fastcall sub_13EA8(int a1, char *a2, size_t a3, char *a4, unsigned int a5);
void __fastcall sub_13FD0(char *a1, int a2, int a3, int a4);
void __fastcall sub_140DC(char *a1, int a2, int a3);
int __fastcall sub_14108(int a1, int a2, _DWORD *a3);
int __fastcall sub_141B0(int result, int a2);
signed int __fastcall sub_1428C(int a1, _BYTE *a2, signed int *a3);
int sub_142AC(); // weak
int __fastcall sub_142BC(int a1, const char *a2, _DWORD *a3);
void *__fastcall sub_14328(void *result);
int sub_14354(); // weak
void *sub_14404();
void *sub_1441C();
int __fastcall sub_14438(int, int, char *s, int, int); // idb
void **__fastcall sub_145D4(void **result, signed int a2);
int __fastcall sub_14678(int a1, int a2, int a3, int a4);
int __fastcall sub_146A4(int a1, int a2, int a3, int a4);
int __fastcall sub_146D0(int a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_1472C(_DWORD *result, void *a2, int a3, int a4);
int __fastcall sub_14768(int result, int a2, int a3, int a4);
int __fastcall sub_147B8(int a1, int a2, int a3, int a4);
int __fastcall sub_147F8(int a1, int a2, int a3, int a4);
int __fastcall sub_14854(int a1, int a2, _BYTE *a3, int a4);
int __fastcall sub_148A8(int a1, int a2, int *a3, int a4);
int __fastcall sub_14954(int a1, int a2, int a3, int a4);
int __fastcall sub_14A64(int a1, int a2, int a3, int a4);
int __fastcall sub_14C40(int a1, int a2, int a3);
int __fastcall sub_14C74(int result, int a2, int a3);
_DWORD *__fastcall sub_14CD8(_DWORD *result, _BYTE *a2, int a3, int a4);
int __fastcall sub_14D70(int a1, const char *a2);
_DWORD *__fastcall sub_14E58(_DWORD *result, _BYTE *a2, int a3);
int __fastcall sub_14F00(int a1, int a2, _DWORD **a3);
int __fastcall sub_15130(int a1, int a2, int a3, int a4);
signed int __fastcall sub_1515C(int a1);
int __fastcall sub_15250(int a1, int a2, int a3);
_DWORD *__fastcall sub_15360(_DWORD *result, int a2, _BYTE *a3, int a4);
signed int __fastcall sub_155C0(int a1, int a2, _BYTE *a3, int a4, char a5);
int __fastcall sub_15784(int a1, int a2, int a3, int a4);
int __fastcall sub_157D0(int result, int a2, int a3);
char *__fastcall sub_15818(char *result, const void *a2, int a3, int a4);
char *__fastcall sub_15870(char *result, const char *a2, int a3, int a4);
char *__fastcall sub_159D8(char *a1, const char *a2, void *a3);
char *__fastcall sub_15A10(char *a1, const char *a2, int a3, int a4);
int __fastcall sub_15EE8(int a1, int a2, int a3);
int __fastcall sub_15F8C(int result, int a2);
signed int __fastcall sub_1602C(int a1, int a2, int a3);
int __fastcall sub_160E4(int a1, int a2, int a3, int a4);
int __fastcall sub_161B8(int a1, int a2, int a3, int a4, char a5);
int __fastcall sub_16580(int a1, int a2, size_t a3, int a4);
int __fastcall sub_16648(int a1, int a2, _DWORD *a3);
void *__fastcall sub_166D0(void *result, signed int a2, int a3, int a4);
void *__fastcall sub_16744(void *a1, char *a2, int a3, int a4);
int __fastcall sub_167E4(int a1, int a2);
void *__fastcall sub_16870(void *a1, const char *a2, int a3, int a4);
int __fastcall sub_168A0(int a1);
char *__fastcall sub_168CC(int a1);
char *__fastcall sub_168F0(int a1);
void *__fastcall sub_169D0(void *a1, const char *a2, int a3, int a4);
int __fastcall sub_16AB8(int a1, const char *a2);
_DWORD *__fastcall sub_16E50(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_16E7C(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_16FA0(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_16FE8(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_171E8(int a1);
unsigned int __fastcall sub_17618(int a1, int a2, int a3);
int *__fastcall sub_178A0(unsigned int a1, int a2, unsigned int a3, int (__fastcall *a4)(int, unsigned int, unsigned int), int a5);
int __fastcall sub_17E3C(int a1, int a2, int a3, int a4);
int __fastcall sub_17E58(int a1, int a2);
int __fastcall sub_17E6C(int a1, int a2, int a3, int a4);
void __fastcall sub_17ED8(int a1, int a2, int a3, int a4);
int __fastcall sub_17F24(int a1, int a2);
int sub_18074(); // weak
int __fastcall sub_18110(int a1);
int (*sub_18120())();
int __fastcall sub_18138(int a1, int a2, int a3, int a4);
int __fastcall sub_18168(int result, int a2, int a3);
int __fastcall sub_1824C(int a1, unsigned int a2, int a3);
signed int __fastcall sub_182E8(int a1);
signed int __fastcall sub_18344(int a1, int a2, int a3, int a4);
signed int __fastcall sub_18390(int a1, int a2, int a3, int a4);
signed int __fastcall sub_183F8(int a1, int a2, int a3, int a4);
int __fastcall sub_18420(int a1, int a2, int a3, int a4);
signed int __fastcall sub_184A4(int a1, int a2, int a3, int a4);
int __fastcall sub_184E4(int a1, int a2, int a3, int a4);
signed int __fastcall sub_184F4(int a1, const char *a2, int a3, int a4);
signed int __fastcall sub_18638(int a1, int a2);
int __fastcall sub_186F4(int a1, int a2, const char *a3);
signed int __fastcall sub_1877C(int a1, const char **a2, int a3, int a4);
void __fastcall sub_187D4(int a1, int a2, const char *a3);
int sub_188C8(); // weak
int __fastcall sub_18900(int a1, int a2, _DWORD *a3);
int __fastcall sub_189B0(int a1);
int __fastcall sub_18AA8(int a1);
void *__fastcall sub_18B7C(void *result, int a2, int a3, int a4);
void *__fastcall sub_18BE4(void *result, int a2, int a3, int a4);
int __fastcall sub_18C64(int a1, int a2);
int __fastcall sub_19034(int a1, int a2);
void __fastcall sub_19404(int a1, int a2);
void __fastcall sub_19BF4(int a1, int a2, int a3, int a4);
void __fastcall sub_19DF8(int a1, const char *a2, int *a3);
int __fastcall sub_19E2C(int result);
signed int sub_19E40();
void sub_19E50();
signed int __fastcall sub_19E60(int a1);
signed int __fastcall sub_19EF0(int a1, int a2, int a3, int a4);
int sub_19F1C();
int __fastcall sub_19FAC(int a1, int a2, int a3, int a4);
int __fastcall sub_19FD8(int a1, int a2, int a3, int a4);
int __fastcall sub_1A01C(int a1, int a2, int a3, int a4);
signed int sub_1A044();
void sub_1A054();
int __fastcall sub_1A064(int a1);
int __fastcall sub_1A074(int result, int a2);
int __fastcall sub_1A090(int result, int a2, int a3, int a4);
int __fastcall sub_1A0BC(int result);
int __fastcall sub_1A0D4(int result);
int __fastcall sub_1A0E8(int result, _DWORD *a2, _DWORD *a3);
int __fastcall sub_1A108(int result, _DWORD *a2, _DWORD *a3, int a4);
void sub_1A130();
char *__fastcall sub_1A140(char *result, _DWORD *a2, _DWORD *a3, void *a4);
void sub_1A1B8();
int __fastcall sub_1A1C8(_DWORD **a1, int a2, int a3, int a4);
signed int sub_1A1E8();
signed int sub_1A1F8();
_BOOL4 __fastcall sub_1A208(int a1, int a2, int a3, int a4);
void sub_1A228();
unsigned int __fastcall sub_1A238(int a1, _BYTE *a2, int a3, unsigned int a4);
int __fastcall sub_1A2B8(int a1, int a2, int a3, int a4);
int __fastcall sub_1A30C(int a1, const char *a2, int a3, int a4);
int __fastcall sub_1A334(int a1);
int __fastcall sub_1A35C(int a1);
_BOOL4 __fastcall sub_1A3AC(int a1);
int __fastcall sub_1A3C4(const char *a1, int a2, int a3, int a4);
int __fastcall sub_1A410(int result, int a2);
int __fastcall sub_1A440(int a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, char a5);
int __fastcall sub_1A50C(int a1);
void __fastcall sub_1BEE4(int a1, int a2, signed int a3, signed int a4);
int __fastcall sub_1C298(int a1);
signed int __fastcall sub_1C550(int a1);
int __fastcall sub_1C568(int a1, int a2, int a3, int a4);
int __fastcall sub_1C630(int a1, int a2, int a3, int a4);
signed int __fastcall sub_1C670(int a1, int a2, int a3, signed int a4, signed int a5);
int __fastcall sub_1C7A4(int a1, signed int a2, int a3, int a4);
int __fastcall sub_1C954(int a1);
int __fastcall sub_1C964(int a1);
int __fastcall sub_1C978(int a1);
int __fastcall sub_1C988(int result, char a2);
int __fastcall sub_1C99C(int result);
int __fastcall sub_1C9B0(int result);
void __fastcall sub_1CAA8(int a1, int a2, int a3, int a4);
int __fastcall sub_1CB40(int result, int a2);
void sub_1CD10();
int __fastcall sub_1CD40(int result, int a2);
void sub_1CFD0();
int __fastcall ceill(int a1, int a2, __int64 _R2);
void sinf();
int __fastcall sub_1D538(int a1, int a2, int a3, int a4, int a5);
char *__fastcall sub_1DD48(char *result, _DWORD *a2);
unsigned int __fastcall sub_1DD8C(int a1, int a2, int a3, int *a4);
int __fastcall sub_1DEFC(int a1, int a2);
char *__fastcall sub_1DF70(int a1, _BYTE *a2, int a3);
int __fastcall sub_1E6B8(int a1);
void __fastcall sub_1E728(int a1);
void __cdecl operator delete(void *); // idb
int __fastcall sub_1E8C0(char *a1, int a2, int a3, int a4);
int __fastcall sub_1E9D4(unsigned int a1);

//-------------------------------------------------------------------------
// Data declarations

// extern face_e Error;
_UNKNOWN loc_FFFE; // weak
_UNKNOWN unk_1EAA8; // weak
__int16 word_1EAB0 = 47; // weak
char aGame_1[7] = "/game/"; // weak
_UNKNOWN unk_1EFA8; // weak
_UNKNOWN unk_1FC94; // weak
char aU_0[2] = "î"; // weak
_DWORD dword_20FF4[4] = { 3, 4, 4, 6 }; // idb
_UNKNOWN unk_21004; // weak
_UNKNOWN unk_21110; // weak
char *off_28550[4] = { "CREATION", "CONNECTION", "PREINITIALIZATION", "INITIALIZATION" }; // weak
void *off_285C0 = (void *)0x7F69; // weak
void *off_285D0 = (void *)0x69AD; // weak
void *off_286D8 = (void *)0xC811; // weak
void *off_28730 = (void *)0xC7A1; // weak
void *off_28750 = (void *)0xB0E9; // weak
void *off_287C8 = (void *)0xB395; // weak
void *off_28820 = (void *)0xB30D; // weak
void *off_28870 = (void *)0xC8B5; // weak
void *off_28908 = (void *)0x142BD; // weak
void *off_28960 = &_cxa_pure_virtual; // weak
void *off_28988 = &_cxa_pure_virtual; // weak
void *off_289C8 = (void *)0x19E61; // weak
void *off_28AE0 = (void *)0x1B2C1; // weak
void *off_28B18 = (void *)0x1A045; // weak
int GLOBAL_OFFSET_TABLE_ = 166856; // weak
_UNKNOWN unk_29000; // weak
int dword_29004 = 1; // weak
char *off_29008[24] =
{
  "engine.so",
  "VCvarQuery001",
  "inputsystem.so",
  "InputSystemVersion001",
  "materialsystem.so",
  "VMaterialSystem080",
  "datacache.so",
  "VDataCache003",
  "datacache.so",
  "MDLCache004",
  "datacache.so",
  "VStudioDataCache005",
  "studiorender.so",
  "VStudioRender025",
  "vphysics.so",
  "VPhysics031",
  "video_services.so",
  "IVideoServices002",
  "vguimatsurface.so",
  "VGUI_Surface030",
  "vgui2.so",
  "VGUI_ivgui008",
  "engine.so",
  "VENGINE_LAUNCHER_API_VERSION004"
}; // weak
int dword_29070 = 4294967295; // weak
__int16 word_29074 = 0; // weak
__int16 word_29076 = 0; // weak
__int16 word_29078 = 0; // weak
int dword_2907C = 0; // weak
int dword_29080 = 0; // weak
int dword_29084 = 0; // weak
void *off_2908C = &unk_2A604; // weak
int dword_29090 = 4294967295; // weak
char byte_29094 = '\x01'; // weak
char *off_29098 = "unknown"; // weak
int (__fastcall *off_2909C)(_DWORD) = (int (__fastcall *)(_DWORD))0xCD71; // weak
int (__fastcall *off_290A0)(_DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD))0xCD51; // weak
char byte_29120; // weak
_UNKNOWN unk_29128; // weak
int (__fastcall *dword_29228)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_29240; // weak
int dword_29244; // weak
int dword_29248; // weak
char byte_29358; // weak
_UNKNOWN unk_29460; // weak
_UNKNOWN unk_29564; // weak
char byte_2A5AC; // weak
_UNKNOWN unk_2A5B0; // weak
char byte_2A5B4; // weak
int dword_2A5E8; // weak
int dword_2A5EC; // weak
int dword_2A5F0; // weak
int dword_2A6BC; // weak
int dword_2A6C0; // weak
char algn_2A6C4[4]; // weak
char byte_2A6C8; // weak
int dword_2A6CC; // weak
_UNKNOWN unk_2A7D4; // weak
_UNKNOWN unk_2A7EC; // weak
int dword_2A82C; // weak
int dword_2A830; // weak
int dword_2A834; // weak
_UNKNOWN unk_2A838; // weak
int dword_2A83C; // weak
char byte_2A840; // weak
char byte_2A841; // weak
_UNKNOWN unk_2B83C; // weak
_UNKNOWN unk_2B928; // weak
int dword_2B940; // weak
int dword_2B944; // weak
int dword_2B948; // weak
char byte_2B950[4112]; // idb
char byte_2CB80; // weak
int dword_2CB84; // weak
int dword_2CB88; // weak
_UNKNOWN unk_2CB9C; // weak
_UNKNOWN cvar; // weak
_UNKNOWN unk_2CBA4; // weak
_UNKNOWN unk_2D5BC; // weak
int dword_2DEF4; // weak
int dword_2DF08; // weak
int dword_2DF5C; // weak
int dword_2DF88; // weak
int dword_2DF8C; // weak
_UNKNOWN unk_2E2D8; // weak
int dword_2E2F4; // weak
int dword_2E344; // weak
int (__fastcall *dword_2E348)(_DWORD); // weak
int dword_2E34C; // weak
int dword_2E350; // weak
int dword_2E35C; // weak
int dword_2E360; // weak
int dword_2E364; // weak
int dword_2E368; // weak
int dword_2E36C; // weak
int dword_2E370; // weak
int dword_2E374; // weak
int dword_2E378; // weak
int dword_2E37C; // weak
int dword_2E380; // weak
int dword_2E384; // weak
int dword_2E388; // weak
int dword_2E3BC; // weak
int dword_2E3C0; // weak
int dword_2E3C4; // weak
int dword_2E3C8; // weak
int dword_2E3CC; // weak
int dword_2E3D0; // weak
int dword_2E3D4; // weak
int dword_2E3D8; // weak
int dword_2E3DC; // weak
int dword_2E3E0; // weak
int dword_2E3E4; // weak
int dword_2E3E8; // weak
int dword_2E3EC; // weak
int dword_2E3F0; // weak
int dword_2E3F4; // weak
int dword_2E3F8; // weak
int dword_2E3FC; // weak
int dword_2E400; // weak
// extern _UNKNOWN ctype_; weak
// extern _UNKNOWN toupper_tab_; weak
// extern _UNKNOWN _sF; weak
// extern _UNKNOWN g_pVCR; weak
// extern _UNKNOWN tolower_tab_; weak


//----- (000033B0) --------------------------------------------------------
int j_memcmp(const void *s1, const void *s2, size_t n)
{
  return memcmp(s1, s2, n);
}

//----- (0000346C) --------------------------------------------------------
int __fastcall j_SDL_GL_CreateContext(int a1)
{
  return SDL_GL_CreateContext(a1);
}
// 3470: using guessed type int __fastcall SDL_GL_CreateContext(_DWORD);

//----- (000034C8) --------------------------------------------------------
int j_strcmp(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}

//----- (000034FC) --------------------------------------------------------
void *j_memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (0000350C) --------------------------------------------------------
int j_unlink(const char *name)
{
  return unlink(name);
}

//----- (00003858) --------------------------------------------------------
int j_dlclose(void *handle)
{
  return dlclose(handle);
}

//----- (000038CC) --------------------------------------------------------
char *j_strncat(char *dest, const char *src, size_t n)
{
  return strncat(dest, src, n);
}

//----- (00003A1C) --------------------------------------------------------
int j_SDL_GL_DeleteContext()
{
  return SDL_GL_DeleteContext();
}
// 3A20: using guessed type int SDL_GL_DeleteContext(void);

//----- (00003BDC) --------------------------------------------------------
int j_Error()
{
  return ((int (*)(void))Error)();
}
// 3BE0: invalid function type has been ignored

//----- (00003BEC) --------------------------------------------------------
int j_strcasecmp(const char *s1, const char *s2)
{
  return strcasecmp(s1, s2);
}

//----- (00003C20) --------------------------------------------------------
int start()
{
  return _cxa_finalize(&unk_29000);
}
// 3834: using guessed type int __fastcall _cxa_finalize(_DWORD);

//----- (0000443C) --------------------------------------------------------
int __fastcall sub_443C(const char **a1, const char **a2)
{
  int *v3; // [sp+0h] [bp+0h]@1

  v3 = (int *)&v3;
  return sub_11A70(*a1, *a2);
}

//----- (00004450) --------------------------------------------------------
int __fastcall sub_4450(int a1, const char *a2, char *a3)
{
  int v3; // lr@0
  const char *v4; // r4@1
  int v5; // r5@1
  char *v6; // r6@1
  int result; // r0@1
  const char *v8; // r0@8
  int v9; // r1@14
  int v10; // r0@15
  int v11; // [sp+8h] [bp+0h]@11
  int v12; // [sp+10Ch] [bp+104h]@11
  int v13; // [sp+22Ch] [bp+224h]@1

  v4 = a2;
  v5 = a1;
  v13 = v3;
  v6 = a3;
  result = sub_11A70(a2, "game_lv");
  if ( !result )
  {
    if ( !*(_BYTE *)(v5 + 13) )
      return result;
    v4 = "game";
  }
  result = sub_11A70(v4, "game_hd");
  if ( !result )
  {
    if ( !*(_BYTE *)(v5 + 12) )
      return result;
    v4 = "game";
  }
  if ( !sub_12140(v6, ".vpk") && !sub_11A70(v4, "game") )
  {
    v10 = CommandLine_Tier0(0, v9);
    if ( (*(int (**)(void))(*(_DWORD *)v10 + 40))() )
    {
      sub_12440((char *)&v12, 0x104u, "%s_tempcontent", v6);
      (*(void (**)(void))(**(_DWORD **)(v5 + 8) + 28))();
    }
  }
  v8 = *(const char **)(v5 + 4);
  if ( v8 && sub_11A70(v8, "english") )
  {
    if ( strstr(v6, "_english") )
    {
      sub_12440((char *)&v12, 0x104u, "_%s", *(_DWORD *)(v5 + 4));
      sub_13AF0((int)v6, "_english", (int)&v12, (int)&v11, 260, 1);
      (*(void (**)(void))(**(_DWORD **)(v5 + 8) + 28))();
    }
  }
  return (*(int (**)(void))(**(_DWORD **)(v5 + 8) + 28))();
}
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);

//----- (000045A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_45A0(const char *a1, int a2, int a3, int a4)
{
  int v4; // r4@0
  int v5; // r5@0 OVERLAPPED
  int v7; // r7@0
  int v8; // lr@0
  unsigned int v9; // r6@1
  char *v10; // r4@1
  char v12; // [sp+4h] [bp+4h]@1
  _BYTE v13[3]; // [sp+5h] [bp+5h]@4
  int v14; // [sp+10Ch] [bp+10Ch]@1
  __int64 v15; // [sp+110h] [bp+110h]@1
  int v16; // [sp+118h] [bp+118h]@1
  int v17; // [sp+11Ch] [bp+11Ch]@1

  v16 = v7;
  v17 = v8;
  v15 = *(_QWORD *)&v5;
  v9 = a2;
  v14 = v4;
  v10 = (char *)a1;
  sub_13390(a1, a2, a3, a4);
  sub_133C8(v10, 47);
  sub_13CC0(v10, 4, &v12, 260);
  if ( v12 != 47 || sub_11A70(v13, "bin") )
  {
    sub_1250C(v10, (const char *)&word_1EAB0, v9, -1);
    sub_1250C(v10, "bin", v9, -1);
    sub_133C8(v10, 47);
  }
  return 1;
}
// 45A0: could not find valid save-restore pair for r4
// 45A0: could not find valid save-restore pair for r5
// 45A0: could not find valid save-restore pair for r6
// 45A0: could not find valid save-restore pair for r7
// 45A0: variables would overlap: r5.4 and r5.8
// 45A0: variables would overlap: r6.4 and r5.8
// 1EAB0: using guessed type __int16 word_1EAB0;

//----- (0000464C) --------------------------------------------------------
_BYTE *__fastcall sub_464C(char *a1, size_t a2)
{
  const char *v2; // r4@1

  v2 = a1;
  getcwd(a1, a2);
  *(_WORD *)&v2[strlen(v2)] = 47;
  return sub_133C8(v2, 47);
}
// 464C: could not find valid save-restore pair for r4
// 464C: could not find valid save-restore pair for r7
// 1EAB0: using guessed type __int16 word_1EAB0;

//----- (00004684) --------------------------------------------------------
int __fastcall sub_4684(int result)
{
  int *v5; // [sp+0h] [bp+0h]@1

  __asm { VMOV.I32        D16, #0 }
  v5 = (int *)&v5;
  *(_BYTE *)(result + 14) = 0;
  *(_BYTE *)(result + 13) = 0;
  *(_BYTE *)(result + 12) = 0;
  __asm { VST1.32         {D16}, [R0] }
  return result;
}

//----- (000046A4) --------------------------------------------------------
int __fastcall sub_46A4(int result)
{
  *(_BYTE *)(result + 5) = 1;
  *(_DWORD *)result = 0;
  *(_BYTE *)(result + 4) = 0;
  *(_BYTE *)(result + 7) = 0;
  *(_BYTE *)(result + 8) = 0;
  return result;
}

//----- (000046E8) --------------------------------------------------------
_BYTE *__fastcall sub_46E8(_BYTE *result)
{
  int *v6; // [sp+0h] [bp+0h]@1

  __asm { VMOV.I32        D16, #0 }
  v6 = (int *)&v6;
  *result = 1;
  _R3 = (int)(result + 4);
  __asm { VST1.32         {D16}, [R3] }
  return result;
}

//----- (00004730) --------------------------------------------------------
int __fastcall sub_4730(int a1, int a2)
{
  __int64 v2; // r4@0
  int v3; // lr@0
  int v4; // r0@1
  int v5; // r4@1
  int (__fastcall *v6)(int, const char *, int); // r5@1
  int v7; // r1@1
  int v8; // r0@1
  int v9; // r0@1
  int v11; // [sp+0h] [bp+0h]@1
  int *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v12 = &v11;
  v13 = v3;
  *(_QWORD *)&v11 = v2;
  v4 = CommandLine_Tier0(a1, a2);
  v5 = v4;
  v6 = *(int (__fastcall **)(int, const char *, int))(*(_DWORD *)v4 + 24);
  v8 = CommandLine_Tier0(v4, v7);
  v9 = (*(int (**)(void))(*(_DWORD *)v8 + 24))();
  return v6(v5, "-vproject", v9);
}
// 4730: could not find valid save-restore pair for r4
// 4730: could not find valid save-restore pair for r5
// 4730: could not find valid save-restore pair for r7
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);

//----- (0000476C) --------------------------------------------------------
signed int __fastcall sub_476C(char *a1, int a2)
{
  char *v2; // r5@1
  size_t v3; // r6@1
  char *v4; // r4@1
  char *v5; // r3@2
  int v7; // r0@5
  int v8; // r0@5
  int v9; // r1@5
  int v10; // r0@6
  char *v11; // r0@6
  int v12; // r2@6
  int v13; // r3@6

  v2 = a1;
  v3 = a2;
  *a1 = 0;
  v4 = (char *)(unsigned __int8)byte_29120;
  if ( byte_29120 )
  {
    v5 = (char *)sub_4730((int)a1, a2);
    if ( v5 || (v5 = getenv("VProject")) != 0 )
    {
      sub_12440(v2, v3, "%s%c..%cbin", v5, 47, 47);
      return 1;
    }
  }
  else
  {
    v7 = CommandLine_Tier0(a1, a2);
    v8 = (*(int (**)(void))(*(_DWORD *)v7 + 44))();
    if ( v8 )
    {
      v10 = CommandLine_Tier0(v8, v9);
      v11 = (char *)(*(int (**)(void))(*(_DWORD *)v10 + 44))();
      sub_1381C(v2, v3, v11, v4);
      return sub_45A0(v2, v3, v12, v13);
    }
  }
  return 0;
}
// 476C: could not find valid save-restore pair for r4
// 476C: could not find valid save-restore pair for r5
// 476C: could not find valid save-restore pair for r6
// 476C: could not find valid save-restore pair for r7
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 29120: using guessed type char byte_29120;

//----- (00004818) --------------------------------------------------------
int __fastcall sub_4818(int a1, int a2, const char *a3, int a4)
{
  const char *varg_r2; // ST20_4@1
  int v5; // r6@1
  int v6; // r8@1
  int v7; // r0@1
  int v8; // r1@1
  unsigned int v9; // r3@2
  int v11; // r0@7
  int v12; // r1@7
  int varg_r3; // [sp+24h] [bp+24h]@1

  varg_r2 = a3;
  varg_r3 = a4;
  v5 = a2;
  v6 = a1;
  sub_12498((char *)&unk_29128, 0x100u, a3, &varg_r3);
  v7 = Warning("%s\n", &unk_29128);
  if ( v6 )
  {
    v9 = dword_29004;
    if ( dword_29004 == 1 )
    {
      v11 = CommandLine_Tier0(v7, v8);
      if ( !(*(int (__cdecl **)(int))(*(_DWORD *)v11 + 40))(v11) )
        sub_4730(0, v12);
      v9 = dword_29004;
    }
  }
  else
  {
    v9 = dword_29004;
  }
  if ( v9 <= 1 )
    ((void (*)(const char *, ...))Error)("%s\n", &unk_29128);
  return v5;
}
// 3BE0: invalid function type has been ignored
// 4818: could not find valid save-restore pair for r8
// 365C: using guessed type int Warning(const char *, ...);
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 29004: using guessed type int dword_29004;

//----- (000048D0) --------------------------------------------------------
_BOOL4 __fastcall sub_48D0(const char *a1, const char *a2)
{
  int v2; // lr@0
  const char *v3; // r5@1
  int v5; // [sp+4h] [bp+4h]@1
  int v6; // [sp+114h] [bp+114h]@1

  v6 = v2;
  v3 = a2;
  sub_12330((char *)&v5, a1, 0x104u);
  sub_13738((const char *)&v5, 260);
  sub_1250C((const char *)&v5, v3, 0x104u, -1);
  sub_133C8(&v5, 47);
  return access((const char *)&v5, 0) == 0;
}

//----- (00004930) --------------------------------------------------------
signed int __fastcall sub_4930(const char *a1, unsigned int a2, int a3)
{
  int v3; // r6@1
  size_t v4; // r5@1
  const char *v5; // r4@1
  char *v6; // r8@1
  char *v7; // r3@2
  int v8; // t1@4
  _BYTE *v9; // r0@9
  signed int v10; // r4@14

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (char *)sub_1E9D4(a2);
  sub_12330(v6, v5, v4);
  v6[v4 - 1] = 0;
  if ( v6 < &v6[v4] )
  {
    v7 = v6;
    do
    {
      v8 = *v7++;
      if ( v8 == 92 )
        *(v7 - 1) = 47;
    }
    while ( v7 != &v6[v4] );
  }
  while ( !sub_48D0(v5, "gameinfo.txt") )
  {
    if ( !v3 || !sub_13450(v5, v4) )
    {
      sub_12330((char *)v5, v6, v4);
      v5[v4 - 1] = 0;
      v9 = sub_121F8(v5, &unk_1EAA8);
      if ( !v9 )
      {
LABEL_14:
        v10 = 1;
        goto LABEL_15;
      }
      *(_DWORD *)v9 = 1835099951;
      *((_WORD *)v9 + 2) = *(_WORD *)"e/";
      v9[6] = aGame_1[6];
      memmove(v9 + 6, v9 + 9, v4 - 9 + v5 - v9);
      while ( !sub_48D0(v5, "gameinfo.txt") )
      {
        if ( !v3 || !sub_13450(v5, v4) )
          goto LABEL_14;
      }
      break;
    }
  }
  v10 = 0;
LABEL_15:
  if ( v6 )
    operator delete(v6);
  operator delete(0);
  return v10;
}
// 4930: could not find valid save-restore pair for r4
// 4930: could not find valid save-restore pair for r5
// 4930: could not find valid save-restore pair for r6
// 4930: could not find valid save-restore pair for r7
// 4930: could not find valid save-restore pair for r8
// 4930: could not find valid save-restore pair for r9

//----- (00004A74) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_4A74(int a1, int a2, size_t a3, int a4)
{
  int v4; // r4@0
  int v5; // r5@0 OVERLAPPED
  int v7; // r7@0 OVERLAPPED
  int v9; // r9@0
  int v10; // lr@0
  size_t v11; // r8@1
  char *v12; // r6@1
  int v13; // r4@1
  char *v14; // r5@1
  const char *v15; // r0@2
  int result; // r0@4
  const char *v17; // ST00_4@6
  const char *v18; // r0@7
  char *v19; // r9@7
  char *v20; // r0@15
  unsigned __int8 v21; // [sp+8h] [bp+0h]@12
  int v22; // [sp+14h] [bp+Ch]@1
  __int64 v23; // [sp+18h] [bp+10h]@1
  __int64 v24; // [sp+20h] [bp+18h]@1
  int v25; // [sp+28h] [bp+20h]@1
  int v26; // [sp+2Ch] [bp+24h]@1

  v24 = *(_QWORD *)&v7;
  v11 = a3;
  v23 = *(_QWORD *)&v5;
  v12 = (char *)a2;
  v22 = v4;
  v13 = a1;
  v25 = v9;
  v26 = v10;
  v14 = (char *)*(_BYTE *)(a1 + 4);
  if ( *(_BYTE *)(a1 + 4) )
  {
    v15 = *(const char **)a1;
    if ( v15 )
    {
      if ( sub_48D0(v15, "gameinfo.txt") )
      {
        sub_12330(v12, *(const char **)v13, v11);
        result = 0;
      }
      else
      {
        v17 = *(const char **)v13;
        result = sub_4818(
                   1,
                   1,
                   "Setup file '%s' doesn't exist in subdirectory '%s'.\nCheck your -game parameter or VCONFIG setting.",
                   (int)"gameinfo.txt");
      }
    }
    else
    {
      result = sub_4818(0, 1, "bOnlyUseDirectoryName=1 and pDirectoryName=NULL.", a4);
    }
    return result;
  }
  v18 = (const char *)sub_4730(a1, a2);
  v19 = (char *)v18;
  if ( v18 )
  {
    if ( sub_48D0(v18, "gameinfo.txt") )
    {
      sub_1381C(v12, v11, v19, v14);
      return (int)v14;
    }
    if ( !*(_BYTE *)(v13 + 8) )
      return sub_4818(
               1,
               1,
               "Unable to find %s. Solutions:\n"
               "\n"
               "1. Read http://www.valve-erc.com/srcsdk/faq.html#NoGameDir\n"
               "2. Run vconfig to specify which game you're working on.\n"
               "3. Add -game <path> on the command line where <path> is the directory that %s is in.\n",
               (int)"gameinfo.txt");
LABEL_19:
    sub_12330(v12, "", v11);
    return 0;
  }
  if ( *(_BYTE *)(v13 + 8) )
    goto LABEL_19;
  v21 = 1;
  if ( !dword_29228 || !dword_29228(v13, v12, v11, &v21) || (result = sub_4930(v12, v11, v21)) != 0 )
  {
    v20 = getenv("VProject");
    if ( v20 )
    {
      sub_1381C(v12, v11, v20, 0);
      if ( !sub_4930(v12, v11, 0) )
        return 0;
    }
    Warning("Warning: falling back to auto detection of vproject directory.\n");
    if ( *(_DWORD *)v13 )
      sub_1381C(v12, v11, *(char **)v13, 0);
    else
      sub_1381C(v12, v11, ".", 0);
    if ( !sub_4930(v12, v11, 1) )
      return 0;
    sub_464C(v12, v11);
    if ( !sub_4930(v12, v11, 1) )
      return 0;
    return sub_4818(
             1,
             1,
             "Unable to find %s. Solutions:\n"
             "\n"
             "1. Read http://www.valve-erc.com/srcsdk/faq.html#NoGameDir\n"
             "2. Run vconfig to specify which game you're working on.\n"
             "3. Add -game <path> on the command line where <path> is the directory that %s is in.\n",
             (int)"gameinfo.txt");
  }
  return result;
}
// 4A74: could not find valid save-restore pair for r4
// 4A74: could not find valid save-restore pair for r5
// 4A74: could not find valid save-restore pair for r6
// 4A74: could not find valid save-restore pair for r7
// 4A74: could not find valid save-restore pair for r8
// 4A74: could not find valid save-restore pair for r9
// 4A74: variables would overlap: r5.4 and r5.8
// 4A74: variables would overlap: r6.4 and r5.8
// 4A74: variables would overlap: r7.4 and r7.8
// 4A74: variables would overlap: r8.4 and r7.8
// 365C: using guessed type int Warning(const char *, ...);
// 29228: using guessed type int (__fastcall *dword_29228)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00004D4C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
const char *__fastcall sub_4D4C(int a1, int a2)
{
  int v2; // r4@0
  int v3; // r5@0 OVERLAPPED
  int v5; // r7@0
  int v6; // lr@0
  int v7; // r6@1
  int v8; // r5@1
  const char *result; // r0@1
  int v10; // r3@6
  char v11; // [sp+0h] [bp+0h]@2
  int v12; // [sp+10Ch] [bp+10Ch]@1
  __int64 v13; // [sp+110h] [bp+110h]@1
  int v14; // [sp+118h] [bp+118h]@1
  int v15; // [sp+11Ch] [bp+11Ch]@1

  v13 = *(_QWORD *)&v3;
  v7 = a1;
  v8 = a2;
  v14 = v5;
  v15 = v6;
  v12 = v2;
  result = getenv(*(const char **)(a2 + 36));
  if ( result )
  {
    sub_12330(&v11, result, 0x104u);
    result = (const char *)strlen(&v11);
    if ( result )
      return result;
  }
  else
  {
    v11 = 0;
  }
  if ( v7 )
  {
    result = (const char *)sub_E238(v7, "SteamUserPassphrase", 0);
    if ( result )
      result = (const char *)sub_6580(v8 + 32, "%s", (int)result, v10);
  }
  return result;
}
// 4D4C: could not find valid save-restore pair for r4
// 4D4C: could not find valid save-restore pair for r5
// 4D4C: could not find valid save-restore pair for r6
// 4D4C: could not find valid save-restore pair for r7
// 4D4C: variables would overlap: r5.4 and r5.8
// 4D4C: variables would overlap: r6.4 and r5.8

//----- (00004DC0) --------------------------------------------------------
int __fastcall sub_4DC0(int a1)
{
  int v1; // lr@0
  int v2; // r5@1
  int v3; // r3@1
  int v4; // r1@2
  int v5; // r2@2
  int v6; // r3@2
  int result; // r0@3
  int v8; // [sp+4h] [bp+4h]@1
  int v9; // [sp+11Ch] [bp+11Ch]@1

  v2 = a1;
  v9 = v1;
  (*(void (**)(void))(*(_DWORD *)a1 + 40))();
  if ( sub_476C((char *)&v8, 260) )
  {
    (*(void (__fastcall **)(int, int *, const char *, signed int))(*(_DWORD *)v2 + 28))(v2, &v8, "EXECUTABLE_PATH", 1);
    if ( sub_476C((char *)&v8, 260) )
    {
      sub_13390((const char *)&v8, v4, v5, v6);
      (*(void (__fastcall **)(int, int *, const char *, signed int))(*(_DWORD *)v2 + 28))(v2, &v8, "BASE_PATH", 1);
      result = 0;
    }
    else
    {
      result = sub_4818(0, 3, "FileSystem_GetBaseDir failed.", v6);
    }
  }
  else
  {
    result = sub_4818(0, 3, "FileSystem_GetExecutableDir failed.", v3);
  }
  return result;
}

//----- (00004E60) --------------------------------------------------------
int __fastcall sub_4E60(char *a1, size_t a2, _BYTE *a3)
{
  int v3; // lr@0
  size_t v4; // r6@1
  char *v5; // r8@1
  int v6; // r3@1
  int result; // r0@2
  int v8; // [sp+Ch] [bp+4h]@1
  int v9; // [sp+124h] [bp+11Ch]@1

  v4 = a2;
  v9 = v3;
  v5 = a1;
  *a3 = 0;
  if ( sub_476C((char *)&v8, 260) )
  {
    sub_12440(v5, v4, "%s%cfilesystem_stdio.so", &v8, 47);
    result = 0;
  }
  else
  {
    result = sub_4818(0, 3, "FileSystem_GetExecutableDir failed.", v6);
  }
  return result;
}

//----- (00004EC8) --------------------------------------------------------
int __fastcall sub_4EC8(int a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  int result; // r0@2
  int v6; // [sp+0h] [bp+0h]@1

  v6 = a4;
  v4 = a1;
  if ( (*(int (**)(void))(**(_DWORD **)(a1 + 8) + 20))() )
    result = sub_4818(0, 3, "Should not be using filesystem_steam anymore!", v6);
  else
    result = sub_4DC0(*(_DWORD *)(v4 + 8));
  return result;
}
// 4EC8: could not find valid save-restore pair for r4
// 4EC8: could not find valid save-restore pair for r7

//----- (00004F0C) --------------------------------------------------------
int __fastcall sub_4F0C(int result)
{
  dword_29004 = result;
  return result;
}
// 29004: using guessed type int dword_29004;

//----- (00004F84) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
FILE *__fastcall sub_4F84(const char *a1)
{
  int v1; // r4@0
  int v2; // r5@0 OVERLAPPED
  int v4; // r7@0 OVERLAPPED
  int v6; // r9@0
  int v7; // lr@0
  int v8; // r8@1
  FILE *v9; // r0@1
  FILE *v10; // r5@1
  __int32 v11; // r0@2
  int v12; // r2@2
  int v13; // r3@2
  int v14; // r9@2
  void *v15; // r2@4
  char *v16; // r3@4
  int v17; // r1@4
  int v18; // r2@4
  int v19; // r3@4
  int v20; // r1@6
  int v21; // r2@6
  void *ptr; // [sp+8h] [bp+0h]@2
  int v24; // [sp+Ch] [bp+4h]@2
  int v25; // [sp+10h] [bp+8h]@2
  int v26; // [sp+14h] [bp+Ch]@2
  void *v27; // [sp+18h] [bp+10h]@2
  int v28; // [sp+24h] [bp+1Ch]@1
  __int64 v29; // [sp+28h] [bp+20h]@1
  __int64 v30; // [sp+30h] [bp+28h]@1
  int v31; // [sp+38h] [bp+30h]@1
  int v32; // [sp+3Ch] [bp+34h]@1

  v30 = *(_QWORD *)&v4;
  v8 = (int)a1;
  v29 = *(_QWORD *)&v2;
  v31 = v6;
  v32 = v7;
  v28 = v1;
  v9 = fopen(a1, "rb");
  v10 = v9;
  if ( v9 )
  {
    ptr = 0;
    v24 = 0;
    v25 = 0;
    v27 = 0;
    fseek(v9, 0, 2);
    v11 = ftell(v10);
    v14 = v11 + 1;
    v26 = 0;
    if ( v11 != -1 )
    {
      sub_689C(&ptr, v11 + 1, v12, v13);
      sub_6920(&ptr, 0, v14);
    }
    fseek(v10, 0, 0);
    fread(ptr, 1u, v26 - 1, v10);
    fclose(v10);
    v15 = ptr;
    v16 = (char *)ptr + v26;
    *(v16 - 1) = 0;
    v10 = (FILE *)sub_DB08(32, 0, (int)v15, (int)v16);
    sub_CECC((int)v10, (int)"");
    if ( !sub_10210((int)v10, v8, (char *)ptr, 0, 0) )
    {
      sub_EB0C((int)v10, v17, v18, v19);
      v10 = 0;
    }
    v26 = 0;
    sub_667C((int)&ptr, v17, v18, 0);
    v27 = ptr;
    sub_667C((int)&ptr, v20, v21, (int)ptr);
  }
  return v10;
}
// 4F84: could not find valid save-restore pair for r4
// 4F84: could not find valid save-restore pair for r5
// 4F84: could not find valid save-restore pair for r6
// 4F84: could not find valid save-restore pair for r7
// 4F84: could not find valid save-restore pair for r8
// 4F84: could not find valid save-restore pair for r9
// 4F84: variables would overlap: r5.4 and r5.8
// 4F84: variables would overlap: r6.4 and r5.8
// 4F84: variables would overlap: r7.4 and r7.8
// 4F84: variables would overlap: r8.4 and r7.8

//----- (00005078) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_5078(const char *a1, int *a2, int *a3, int *a4)
{
  int v4; // r4@0
  int v5; // r5@0 OVERLAPPED
  int v7; // r7@0 OVERLAPPED
  int v9; // r9@0
  int v10; // lr@0
  int *v11; // r9@1
  int *v12; // r8@1
  int *v13; // r6@1
  FILE *v14; // r0@1
  int v15; // r0@2
  int v16; // r1@2
  int v17; // r2@2
  int v18; // r3@2
  int v19; // r0@3
  int v20; // r1@3
  int v21; // r2@3
  int v22; // r3@3
  int result; // r0@4
  int v24; // [sp+4h] [bp+4h]@1
  int v25; // [sp+10Ch] [bp+10Ch]@1
  __int64 v26; // [sp+110h] [bp+110h]@1
  __int64 v27; // [sp+118h] [bp+118h]@1
  int v28; // [sp+120h] [bp+120h]@1
  int v29; // [sp+124h] [bp+124h]@1

  v28 = v9;
  v29 = v10;
  v11 = a4;
  v27 = *(_QWORD *)&v7;
  v12 = a3;
  v26 = *(_QWORD *)&v5;
  v13 = a2;
  v25 = v4;
  sub_12330((char *)&v24, a1, 0x104u);
  sub_13738((const char *)&v24, 260);
  sub_1250C((const char *)&v24, "gameinfo.txt", 0x104u, -1);
  sub_133C8(&v24, 47);
  v14 = sub_4F84((const char *)&v24);
  *v13 = (int)v14;
  if ( v14 )
  {
    v15 = sub_DBF0((int)v14, "FileSystem", 0);
    *v12 = v15;
    if ( v15 )
    {
      v19 = sub_DBF0(v15, "SearchPaths", 0);
      *v11 = v19;
      if ( v19 )
      {
        result = 0;
      }
      else
      {
        sub_EB0C(*v13, v20, v21, v22);
        result = sub_4818(1, 2, "%s is not a valid format.", (int)&v24);
      }
    }
    else
    {
      sub_EB0C(*v13, v16, v17, v18);
      result = sub_4818(1, 2, "%s is not a valid format.", (int)&v24);
    }
  }
  else
  {
    result = sub_4818(1, 1, "%s is missing.", (int)&v24);
  }
  return result;
}
// 5078: could not find valid save-restore pair for r4
// 5078: could not find valid save-restore pair for r5
// 5078: could not find valid save-restore pair for r6
// 5078: could not find valid save-restore pair for r7
// 5078: could not find valid save-restore pair for r8
// 5078: could not find valid save-restore pair for r9
// 5078: variables would overlap: r5.4 and r5.8
// 5078: variables would overlap: r6.4 and r5.8
// 5078: variables would overlap: r7.4 and r7.8
// 5078: variables would overlap: r8.4 and r7.8

//----- (0000515C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_515C(int a1)
{
  int v1; // r4@0
  int v2; // r5@0 OVERLAPPED
  int v4; // r7@0 OVERLAPPED
  int v6; // r9@0 OVERLAPPED
  int v8; // r11@0
  int v9; // lr@0
  int v10; // r11@1
  int v11; // r3@1
  const char *v12; // r0@2
  int result; // r0@3
  int v14; // r4@3
  int v15; // r1@6
  int v16; // r2@6
  int v17; // r3@6
  char *v18; // r0@8
  int v19; // r1@8
  int v20; // r0@8
  char *v21; // r0@8
  int v22; // r1@9
  int v23; // r2@9
  void *v24; // r3@9
  signed int v25; // r5@10
  int v26; // r1@11
  int v27; // r2@11
  int v28; // r3@11
  int v29; // r1@15
  int v30; // r2@15
  int v31; // r3@15
  char *v32; // r5@17
  char *v33; // r0@18
  char *v34; // r3@18
  int v35; // r1@20
  int v36; // r2@20
  int v37; // r3@20
  int v38; // r0@23
  char *v39; // r5@23
  void *v40; // r1@25
  int v41; // r0@25
  int v42; // lr@26
  int v43; // r10@27
  int v44; // r0@28
  size_t v45; // r0@36
  char *v46; // r9@36
  int v47; // r2@36
  int j; // r1@36
  int v49; // r10@36
  void *v50; // r0@41
  void *v51; // r0@42
  void *v52; // r0@55
  void *v53; // r3@55
  signed int v54; // r1@57
  int v55; // r6@61
  int *v56; // r5@62
  int v57; // r10@63
  _BYTE *v58; // r0@63
  _BYTE *v59; // r9@65
  _BYTE *v60; // r0@65
  signed int v61; // r3@66
  _DWORD *v62; // r0@69
  char *v63; // r0@69
  int v64; // r1@69
  int v65; // r3@69
  int v66; // r6@70
  int v67; // r2@72
  signed int v68; // r9@73
  int v69; // r6@75
  int v70; // r6@79
  void *v71; // r0@81
  int v72; // r6@84
  int v73; // r1@84
  int v74; // r2@84
  int v75; // r3@84
  void *v76; // r0@87
  signed int v77; // r6@88
  int v78; // r3@88
  int v79; // r1@88
  int v80; // r2@88
  int v81; // r3@88
  int v82; // r1@88
  int v83; // r2@88
  int v84; // r1@88
  int v85; // r2@88
  int v86; // r3@88
  void *v87; // r0@89
  signed int v88; // r5@92
  int v89; // r1@92
  int v90; // r2@92
  int v91; // r3@92
  void *v92; // r0@95
  int v93; // r1@96
  int v94; // r2@96
  int v95; // r1@96
  int v96; // r2@96
  int v97; // r9@101
  int v98; // r5@103
  signed int v99; // r8@103
  int v100; // r6@105
  char *v101; // r3@106
  int v102; // r1@106
  unsigned __int8 v103; // cf@108
  size_t v104; // r0@112
  char *v105; // r5@112
  signed int v106; // r8@112
  int i; // r1@112
  int v108; // r6@112
  void *v109; // r1@113
  int v110; // r3@113
  int v111; // r2@114
  int v112; // r8@115
  int v113; // [sp+0h] [bp+0h]@42
  const char *v114; // [sp+4h] [bp+4h]@16
  const char *v115; // [sp+8h] [bp+8h]@16
  const char *v116; // [sp+Ch] [bp+Ch]@24
  const char *v117; // [sp+10h] [bp+10h]@16
  const char *v118; // [sp+14h] [bp+14h]@16
  char *v119; // [sp+18h] [bp+18h]@16
  const char *v120; // [sp+1Ch] [bp+1Ch]@24
  int *v121; // [sp+20h] [bp+20h]@3
  int *v122; // [sp+24h] [bp+24h]@6
  const char *v123; // [sp+28h] [bp+28h]@24
  const char *v124; // [sp+2Ch] [bp+2Ch]@24
  _DWORD *v125; // [sp+30h] [bp+30h]@15
  const char *v126; // [sp+34h] [bp+34h]@16
  const char *v127; // [sp+38h] [bp+38h]@24
  const char *v128; // [sp+3Ch] [bp+3Ch]@10
  int v129; // [sp+40h] [bp+40h]@3
  int v130; // [sp+48h] [bp+48h]@3
  int v131; // [sp+50h] [bp+50h]@3
  int v132; // [sp+58h] [bp+58h]@23
  void *v133; // [sp+60h] [bp+60h]@20
  int v134; // [sp+64h] [bp+64h]@20
  signed int v135; // [sp+68h] [bp+68h]@20
  signed int v136; // [sp+6Ch] [bp+6Ch]@20
  void *v137; // [sp+70h] [bp+70h]@20
  int v138; // [sp+78h] [bp+78h]@6
  int v139; // [sp+17Ch] [bp+17Ch]@16
  int v140; // [sp+280h] [bp+280h]@9
  int v141; // [sp+284h] [bp+284h]@9
  int v142; // [sp+288h] [bp+288h]@9
  void *v143; // [sp+28Ch] [bp+28Ch]@9
  int v144; // [sp+290h] [bp+290h]@9
  int v145; // [sp+388h] [bp+388h]@11
  int v146; // [sp+494h] [bp+494h]@1
  __int64 v147; // [sp+498h] [bp+498h]@1
  __int64 v148; // [sp+4A0h] [bp+4A0h]@1
  __int64 v149; // [sp+4A8h] [bp+4A8h]@1
  int v150; // [sp+4B0h] [bp+4B0h]@1
  int v151; // [sp+4B4h] [bp+4B4h]@1

  v150 = v8;
  v151 = v9;
  v10 = a1;
  v148 = *(_QWORD *)&v4;
  v149 = *(_QWORD *)&v6;
  v147 = *(_QWORD *)&v2;
  v146 = v1;
  v11 = *(_DWORD *)(a1 + 8);
  if ( !v11 )
    return sub_4818(0, 3, "FileSystem_LoadSearchPaths: Invalid parameters specified.", v11);
  v12 = *(const char **)a1;
  if ( !v12 )
    return sub_4818(0, 3, "FileSystem_LoadSearchPaths: Invalid parameters specified.", v11);
  v121 = &v129;
  result = sub_5078(v12, &v129, &v130, &v131);
  v14 = result;
  if ( result )
    return result;
  v122 = &v138;
  if ( !sub_476C((char *)&v138, 260) )
    return sub_4818(0, 3, "FileSystem_GetBaseDir failed.", v17);
  sub_13390((const char *)&v138, v15, v16, v17);
  v18 = sub_12330((char *)(v10 + 14), *(const char **)v10, 0x200u);
  v20 = CommandLine_Tier0(v18, v19);
  v21 = (char *)(*(int (**)(void))(*(_DWORD *)v20 + 24))();
  if ( v21 )
  {
    v140 = v14;
    v141 = v14;
    v142 = v14;
    v143 = (void *)v14;
    v144 = v14;
    sub_140DC(v21, (int)",", (int)&v140);
    v24 = v143;
    if ( (signed int)v143 > 0 )
    {
      v25 = 0;
      v128 = "Bad -insert_search_path - Can't resolve pathname for '%s'";
      do
      {
        sub_12C90(*(const char **)(v140 + 4 * v25));
        sub_1381C((char *)&v145, 0x104u, *(char **)(v140 + 4 * v25), (char *)&v138);
        sub_133C8(&v145, 47);
        if ( !sub_13640(&v145, 47, 1u) )
          ((void (__fastcall *)(const char *, int *))Error)(v128, &v145);
        sub_13234((const char *)&v145, v26, v27, v28);
        sub_4450(v10, "GAME", (char *)&v145);
        sub_4450(v10, "MOD", (char *)&v145);
        v24 = v143;
        ++v25;
      }
      while ( (signed int)v143 > v25 );
    }
    sub_6600((int)&v140, v22, v23, v24);
  }
  v125 = (_DWORD *)sub_D420(v131);
  if ( !v125 )
    goto LABEL_97;
  v119 = "";
  v128 = (const char *)&v139;
  v118 = "|gameinfo_path|";
  v115 = "|all_source_engine_paths|";
  v114 = "FileSystem_AddLoadedSearchPath - Can't resolve pathname for '%s'";
  v117 = "?";
  v126 = "materials";
  do
  {
    v32 = (char *)sub_E238((int)v125, 0, (int)v119);
    if ( v32 == sub_12140(v32, v118) )
    {
      v32 += 15;
      v34 = *(char **)v10;
    }
    else
    {
      v33 = sub_12140(v32, v115);
      v34 = (char *)&v138;
      if ( v32 == v33 )
        v32 += 25;
    }
    v133 = 0;
    v134 = 0;
    v135 = 0;
    v136 = 0;
    v137 = 0;
    sub_1381C((char *)&v139, 0x104u, v32, v34);
    sub_133C8(&v139, 47);
    if ( !sub_13640(&v139, 47, 1u) )
      ((void (__fastcall *)(const char *, int *))Error)(v114, &v139);
    sub_13234((const char *)&v139, v35, v36, v37);
    if ( !sub_12140(v32, v117) && !sub_12140(v32, "*") )
    {
      v104 = strlen((const char *)&v139);
      v105 = (char *)sub_1E9D4(v104 + 1);
      strcpy(v105, (const char *)&v139);
      v106 = v136;
      i = v134;
      v108 = v136 + 1;
      if ( v136 + 1 <= v134 || v135 < 0 )
      {
        v109 = v133;
        v110 = v136 + 1;
      }
      else
      {
        if ( v135 )
        {
          for ( i = v135 + v136 / v135 * v135; v108 > i; i = (i + v108) / 2 )
            ;
        }
        else if ( v134 || (i = 8, v108 > 8) )
        {
          do
          {
            i *= 2;
            if ( v108 <= i )
              break;
            i *= 2;
          }
          while ( v108 > i );
        }
        v134 = i;
        if ( v133 )
        {
          v109 = realloc(v133, 4 * i);
          v133 = v109;
          v110 = v136 + 1;
        }
        else
        {
          v109 = malloc(4 * i);
          v110 = v106 + 1;
          v133 = v109;
        }
      }
      v136 = v110;
      v111 = v110 - v106 - 1;
      v137 = v109;
      if ( v111 > 0 )
      {
        v112 = 4 * v108 - 4;
        memmove((char *)v109 + 4 * v108, (char *)v109 + v112, 4 * v111);
        v109 = v133;
      }
      else
      {
        v112 = 4 * v106;
      }
      if ( (char *)v109 + v112 )
      {
        *(_DWORD *)((char *)v109 + v112) = v105;
        v56 = &v145;
        goto LABEL_69;
      }
LABEL_110:
      v56 = &v145;
      goto LABEL_69;
    }
    v38 = *(_DWORD *)(v10 + 8);
    v132 = 0;
    v39 = (char *)(*(int (**)(void))(*(_DWORD *)v38 + 108))();
    if ( !v39 )
      goto LABEL_57;
    v127 = "readme.txt";
    v124 = "Tried to add %s as a search path.\n\nThis is probably not what you intended.\n\nCheck %s for more info\n";
    v123 = "maps";
    v120 = "resource";
    v116 = "scripts";
    do
    {
      if ( *v39 == 46 || !(*(int (**)(void))(**(_DWORD **)(v10 + 8) + 116))() && !sub_12140(v39, ".vpk") )
        goto LABEL_33;
      sub_1353C((const char *)&v139, &v140, 260);
      sub_13738((const char *)&v140, 260);
      sub_1250C((const char *)&v140, v39, 0x104u, -1);
      v45 = strlen((const char *)&v140);
      v46 = (char *)sub_1E9D4(v45 + 1);
      strcpy(v46, (const char *)&v140);
      v47 = v136;
      j = v134;
      v49 = v136 + 1;
      if ( v136 + 1 > v134 && v135 >= 0 )
      {
        if ( v135 )
        {
          for ( j = v135 + v136 / v135 * v135; v49 > j; j = (j + v49) / 2 )
            ;
          goto LABEL_41;
        }
        if ( v134 || (j = 8, v49 > 8) )
        {
          do
            j *= 2;
          while ( v49 > j );
          v50 = v133;
          v134 = j;
          if ( !v133 )
          {
LABEL_55:
            v113 = v136;
            v52 = malloc(4 * j);
            v53 = v52;
            v40 = v52;
            v41 = v49;
            v133 = v53;
            v47 = v113;
            goto LABEL_26;
          }
        }
        else
        {
LABEL_41:
          v50 = v133;
          v134 = j;
          if ( !v133 )
            goto LABEL_55;
        }
        v113 = v136;
        v51 = realloc(v50, 4 * j);
        v133 = v51;
        v40 = v51;
        v47 = v113;
        v41 = v136 + 1;
        goto LABEL_26;
      }
      v40 = v133;
      v41 = v136 + 1;
LABEL_26:
      v136 = v41;
      v42 = v41 - v47 - 1;
      v137 = v40;
      if ( v42 > 0 )
      {
        v44 = 4 * v49;
        v43 = 4 * v49 - 4;
        memmove((char *)v40 + v44, (char *)v40 + v43, 4 * v42);
        v40 = v133;
      }
      else
      {
        v43 = 4 * v47;
      }
      if ( (char *)v40 + v43 )
        *(_DWORD *)((char *)v40 + v43) = v46;
      if ( !sub_11A70(v39, v126)
        || !sub_11A70(v39, v123)
        || !sub_11A70(v39, v120)
        || !sub_11A70(v39, v116)
        || !sub_11A70(v39, "sound")
        || !sub_11A70(v39, "models") )
      {
        sub_1353C((const char *)&v139, &v145, 260);
        sub_13738((const char *)&v145, 260);
        sub_1250C((const char *)&v145, v127, 0x104u, -1);
        ((void (__fastcall *)(const char *, int *, int *))Error)(v124, &v140, &v145);
      }
LABEL_33:
      v39 = (char *)(*(int (**)(void))(**(_DWORD **)(v10 + 8) + 112))();
    }
    while ( v39 );
    (*(void (**)(void))(**(_DWORD **)(v10 + 8) + 120))();
LABEL_57:
    v54 = v136;
    if ( v136 > 1 )
    {
      if ( v133 )
      {
        qsort(v133, v136, 4u, (__compar_fn_t)sub_443C);
      }
      else
      {
        v97 = v136 - 1;
        do
        {
          if ( v97 > 0 )
          {
            v98 = 0;
            v99 = 1;
            while ( 1 )
            {
              v100 = v98 + 4;
              ++v99;
              if ( sub_443C((const char **)((char *)v133 + v98), (const char **)((char *)v133 + v98 + 4)) < 0 )
              {
                v101 = (char *)v133;
                v102 = *(_DWORD *)((char *)v133 + v98);
                *(_DWORD *)((char *)v133 + v98) = *(_DWORD *)((char *)v133 + v100);
                *(_DWORD *)&v101[v100] = v102;
              }
              if ( v99 > v97 )
                break;
              v98 += 4;
            }
          }
          v103 = __CFADD__(v97--, -1);
        }
        while ( v103 );
      }
      v54 = v136;
    }
    v55 = v54 - 1;
    if ( v54 - 1 <= 0 )
      goto LABEL_110;
    v56 = &v145;
    v127 = (const char *)&unk_1EFA8;
    do
    {
      v57 = 4 * v55;
      sub_12330((char *)&v145, *((const char **)v133 + v55--), 0x104u);
      v58 = sub_121F8(&v145, v127);
      if ( v58 )
      {
        *v58 = 0;
        while ( 1 )
        {
          v59 = *(_BYTE **)((char *)v133 + v57 - 4);
          v60 = sub_121F8(*(_BYTE **)((char *)v133 + v57 - 4), &v145);
          if ( v59 != v60 )
            break;
          operator delete(v60);
          v61 = v136;
          if ( v136 - v55 - 1 > 0 )
          {
            memmove((char *)v133 + v57 - 4, (char *)v133 + v57, 4 * (v136 - v55 - 1));
            v61 = v136;
          }
          --v55;
          v57 -= 4;
          v136 = v61 - 1;
          if ( v55 == -1 )
            goto LABEL_69;
        }
      }
    }
    while ( v55 > 0 );
LABEL_69:
    v62 = v125;
    *v56 = 0;
    v56[1] = 0;
    v56[2] = 0;
    v56[3] = 0;
    v56[4] = 0;
    v63 = (char *)sub_CF08(v62);
    sub_140DC(v63, (int)"+", (int)v56);
    v65 = v56[3];
    if ( v65 > 0 )
    {
      v66 = 0;
      do
      {
        sub_12C90(*(const char **)(*v56 + 4 * v66));
        v65 = v56[3];
        ++v66;
      }
      while ( v65 > v66 );
    }
    v67 = v136;
    if ( v136 > 0 )
    {
      v68 = 0;
      do
      {
        if ( v65 > 0 )
        {
          v69 = 0;
          do
          {
            sub_4450(v10, *(const char **)(*v56 + 4 * v69), *((char **)v133 + v68));
            v65 = v56[3];
            ++v69;
          }
          while ( v65 > v69 );
        }
        v67 = v136;
        ++v68;
      }
      while ( v136 > v68 );
    }
    if ( v65 > 0 )
    {
      v70 = 0;
      do
      {
        v71 = *(void **)(*v56 + 4 * v70);
        if ( v71 )
          operator delete(v71);
        v65 = v56[3];
        ++v70;
      }
      while ( v70 < v65 );
    }
    v72 = 0;
    v56[3] = 0;
    sub_65D8((int)v56, v64, v67, v65);
    v74 = v56[3];
    v75 = *v56;
    v56[4] = *v56;
    if ( v74 > 0 )
    {
      while ( 1 )
      {
        v76 = *(void **)(v75 + 4 * v72++);
        operator delete(v76);
        v75 = v56[3];
        if ( v72 >= v75 )
          break;
        v75 = *v56;
      }
    }
    v77 = 0;
    v56[3] = 0;
    sub_65D8((int)v56, v73, v74, v75);
    v78 = *v56;
    v56[3] = 0;
    v56[4] = v78;
    sub_65D8((int)v56, v79, v80, v78);
    v81 = *v56;
    v56[4] = *v56;
    sub_65D8((int)v56, v82, v83, v81);
    v86 = v136;
    if ( v136 > 0 )
    {
      do
      {
        v87 = (void *)*((_DWORD *)v133 + v77);
        if ( v87 )
          operator delete(v87);
        v86 = v136;
        ++v77;
      }
      while ( v77 < v136 );
    }
    v88 = 0;
    v136 = 0;
    sub_65D8((int)&v133, v84, v85, v86);
    v90 = v136;
    v91 = (int)v133;
    v137 = v133;
    if ( v136 > 0 )
    {
      while ( 1 )
      {
        v92 = *(void **)(v91 + 4 * v88++);
        operator delete(v92);
        v91 = v136;
        if ( v88 >= v136 )
          break;
        v91 = (int)v133;
      }
    }
    v136 = 0;
    sub_65D8((int)&v133, v89, v90, v91);
    v136 = 0;
    v137 = v133;
    sub_65D8((int)&v133, v93, v94, (int)v133);
    v137 = v133;
    sub_65D8((int)&v133, v95, v96, (int)v133);
    v125 = (_DWORD *)sub_D440((int)v125);
  }
  while ( v125 );
LABEL_97:
  sub_EB0C(v129, v29, v30, v31);
  (*(void (**)(void))(**(_DWORD **)(v10 + 8) + 44))();
  (*(void (**)(void))(**(_DWORD **)(v10 + 8) + 44))();
  (*(void (**)(void))(**(_DWORD **)(v10 + 8) + 44))();
  (*(void (**)(void))(**(_DWORD **)(v10 + 8) + 44))();
  (*(void (**)(void))(**(_DWORD **)(v10 + 8) + 44))();
  (*(void (**)(void))(**(_DWORD **)(v10 + 8) + 44))();
  return 0;
}
// 3BE0: invalid function type has been ignored
// 515C: could not find valid save-restore pair for r4
// 515C: could not find valid save-restore pair for r5
// 515C: could not find valid save-restore pair for r6
// 515C: could not find valid save-restore pair for r7
// 515C: could not find valid save-restore pair for r8
// 515C: could not find valid save-restore pair for r9
// 515C: could not find valid save-restore pair for r10
// 515C: could not find valid save-restore pair for r11
// 515C: variables would overlap: r5.4 and r5.8
// 515C: variables would overlap: r6.4 and r5.8
// 515C: variables would overlap: r7.4 and r7.8
// 515C: variables would overlap: r8.4 and r7.8
// 515C: variables would overlap: r9.4 and r9.8
// 515C: variables would overlap: r10.4 and r9.8
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);

//----- (0000599C) --------------------------------------------------------
int __fastcall sub_599C(int a1, const char *a2, int a3)
{
  int v3; // lr@0
  int v4; // r6@1
  const char *v5; // r8@1
  int v6; // r5@1
  char *v7; // r0@1
  int result; // r0@2
  const char *v9; // r0@6
  int v10; // r3@8
  FILE *v11; // r0@9
  const char *v12; // r1@9
  int v13; // r6@9
  int v14; // r1@11
  int v15; // r2@11
  int v16; // r3@11
  char v17; // [sp+0h] [bp+0h]@2
  int v18; // [sp+104h] [bp+104h]@9
  int v19; // [sp+21Ch] [bp+21Ch]@1

  v4 = a1;
  v19 = v3;
  v5 = a2;
  v6 = a3;
  v7 = getenv(*(const char **)(a3 + 68));
  if ( v7 )
  {
    sub_12330(&v17, v7, 0x104u);
    result = strlen(&v17);
    if ( result )
      return result;
  }
  else
  {
    v17 = 0;
  }
  if ( v4 && (v9 = (const char *)sub_E238(v4, "SteamAppUser", 0)) != 0 )
  {
    sub_12330(&v17, v9, 0x104u);
  }
  else
  {
    sub_12330((char *)&v18, v5, 0x104u);
    sub_13738((const char *)&v18, 260);
    sub_1250C((const char *)&v18, "config\\SteamAppData.vdf", 0x104u, -1);
    v11 = sub_4F84((const char *)&v18);
    v13 = (int)v11;
    if ( !v11 || (v12 = (const char *)sub_E238((int)v11, "AutoLoginUser", 0)) == 0 )
    {
      ((void (__fastcall *)(const char *, const char *))Error)("Can't find steam app user info.", v12);
      v12 = 0;
    }
    sub_12330(&v17, v12, 0x104u);
    sub_EB0C(v13, v14, v15, v16);
  }
  sub_119B8(&v17);
  return sub_6580(v6 + 64, "%s", (int)&v17, v10);
}
// 3BE0: invalid function type has been ignored

//----- (00005A90) --------------------------------------------------------
int __fastcall sub_5A90(int a1, const char *a2, int a3)
{
  int v3; // lr@0
  int v4; // r5@1
  FILE *v5; // r4@1
  int v6; // r1@1
  int v7; // r2@1
  int v8; // r3@1
  int v10; // [sp+0h] [bp+0h]@1
  int v11; // [sp+104h] [bp+104h]@1
  int v12; // [sp+214h] [bp+214h]@1

  v12 = v3;
  v4 = a3;
  sub_12330((char *)&v10, a2, 0x104u);
  sub_13738((const char *)&v10, 260);
  sub_1250C((const char *)&v10, "steaminfo.txt", 0x104u, -1);
  v5 = sub_4F84((const char *)&v10);
  sub_599C((int)v5, (const char *)&v11, v4);
  sub_4D4C((int)v5, v4);
  if ( v5 )
    sub_EB0C((int)v5, v6, v7, v8);
  return 0;
}

//----- (000060FC) --------------------------------------------------------
int __fastcall sub_60FC(int a1, int a2, int a3, int a4)
{
  int v4; // lr@0
  const char *v5; // r6@1
  int v6; // r5@1
  int v7; // r4@1
  char *v9; // r0@3
  char *v10; // r9@3
  size_t v11; // r0@4
  int v12; // r2@4
  int v13; // r3@4
  int v14; // r8@4
  size_t v15; // r2@5
  char *v16; // r0@8
  char *v17; // r9@8
  size_t v18; // r0@9
  int v19; // r2@9
  int v20; // r3@9
  int v21; // r8@9
  size_t v22; // r2@10
  char *v23; // r0@13
  char *v24; // r9@13
  size_t v25; // r0@14
  int v26; // r2@14
  int v27; // r3@14
  int v28; // r8@14
  size_t v29; // r2@15
  char *v30; // r0@18
  int v31; // r1@18
  int v32; // r2@18
  char *v33; // r9@18
  size_t v34; // r0@19
  int v35; // r2@19
  int v36; // r3@19
  int v37; // r8@19
  size_t v38; // r2@20
  char *v39; // r8@26
  int v40; // r1@27
  int v41; // r2@27
  int v42; // r1@27
  int v43; // r2@27
  int v44; // r1@30
  int v45; // r2@30
  int v46; // r1@30
  int v47; // r2@30
  int v48; // r1@33
  int v49; // r2@33
  int v50; // r1@33
  int v51; // r2@33
  int v52; // r1@36
  int v53; // r2@36
  int v54; // r3@37
  int v55; // r0@45
  int v56; // r3@52
  int v57; // [sp+0h] [bp+0h]@45
  int v58; // [sp+8h] [bp+8h]@45
  int v59; // [sp+10h] [bp+10h]@45
  char v60; // [sp+18h] [bp+18h]@3
  char *name; // [sp+1Ch] [bp+1Ch]@3
  unsigned __int8 v62; // [sp+20h] [bp+20h]@4
  void *dest; // [sp+24h] [bp+24h]@3
  int v64; // [sp+28h] [bp+28h]@3
  int v65; // [sp+2Ch] [bp+2Ch]@3
  size_t v66; // [sp+30h] [bp+30h]@3
  void *v67; // [sp+34h] [bp+34h]@3
  char v68; // [sp+38h] [bp+38h]@8
  char *v69; // [sp+3Ch] [bp+3Ch]@8
  unsigned __int8 v70; // [sp+40h] [bp+40h]@9
  void *v71; // [sp+44h] [bp+44h]@8
  int v72; // [sp+48h] [bp+48h]@8
  int v73; // [sp+4Ch] [bp+4Ch]@8
  size_t v74; // [sp+50h] [bp+50h]@8
  void *v75; // [sp+54h] [bp+54h]@8
  char v76; // [sp+58h] [bp+58h]@13
  char *v77; // [sp+5Ch] [bp+5Ch]@13
  unsigned __int8 v78; // [sp+60h] [bp+60h]@14
  void *v79; // [sp+64h] [bp+64h]@13
  int v80; // [sp+68h] [bp+68h]@13
  int v81; // [sp+6Ch] [bp+6Ch]@13
  size_t v82; // [sp+70h] [bp+70h]@13
  void *v83; // [sp+74h] [bp+74h]@13
  unsigned __int8 v84; // [sp+78h] [bp+78h]@18
  char *v85; // [sp+7Ch] [bp+7Ch]@18
  unsigned __int8 v86; // [sp+80h] [bp+80h]@19
  void *v87; // [sp+84h] [bp+84h]@18
  int v88; // [sp+88h] [bp+88h]@18
  int v89; // [sp+8Ch] [bp+8Ch]@18
  size_t v90; // [sp+90h] [bp+90h]@18
  void *v91; // [sp+94h] [bp+94h]@18
  int v92; // [sp+B4h] [bp+B4h]@1

  v5 = (const char *)(a1 + 9);
  v6 = a1;
  v92 = v4;
  v7 = sub_4A74(a1, a1 + 9, 0x200u, a4);
  if ( v7 )
    return v7;
  setenv("VProject", v5, 1);
  dest = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v60 = 1;
  name = "SteamAppId";
  v9 = getenv("SteamAppId");
  v10 = v9;
  if ( v9 )
  {
    v62 = 1;
    v11 = strlen(v9);
    v14 = v11 + 1;
    v66 = 0;
    if ( v11 == -1 )
    {
      v15 = 0;
    }
    else
    {
      sub_689C(&dest, v14, v12, v13);
      sub_6920(&dest, 0, v14);
      v15 = v66;
    }
    memcpy(dest, v10, v15);
  }
  else
  {
    v62 = 0;
  }
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v69 = "SteamUserPassphrase";
  v75 = 0;
  v68 = 1;
  v16 = getenv("SteamUserPassphrase");
  v17 = v16;
  if ( v16 )
  {
    v70 = 1;
    v18 = strlen(v16);
    v21 = v18 + 1;
    v74 = 0;
    if ( v18 == -1 )
    {
      v22 = 0;
    }
    else
    {
      sub_689C(&v71, v18 + 1, v19, v20);
      sub_6920(&v71, 0, v21);
      v22 = v74;
    }
    memcpy(v71, v17, v22);
  }
  else
  {
    v70 = 0;
  }
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v77 = "SteamAppUser";
  v83 = 0;
  v76 = 1;
  v23 = getenv("SteamAppUser");
  v24 = v23;
  if ( v23 )
  {
    v78 = 1;
    v25 = strlen(v23);
    v28 = v25 + 1;
    v82 = 0;
    if ( v25 == -1 )
    {
      v29 = 0;
    }
    else
    {
      sub_689C(&v79, v25 + 1, v26, v27);
      sub_6920(&v79, 0, v28);
      v29 = v82;
    }
    memcpy(v79, v24, v29);
  }
  else
  {
    v78 = 0;
  }
  v87 = 0;
  v88 = 0;
  v89 = 0;
  v90 = 0;
  v85 = "path";
  v91 = 0;
  v84 = 1;
  v30 = getenv("path");
  v33 = v30;
  if ( v30 )
  {
    v86 = 1;
    v34 = strlen(v30);
    v37 = v34 + 1;
    v90 = 0;
    if ( v34 == -1 )
    {
      v38 = 0;
    }
    else
    {
      sub_689C(&v87, v34 + 1, v35, v36);
      sub_6920(&v87, 0, v37);
      v38 = v90;
    }
    memcpy(v87, v33, v38);
  }
  else
  {
    v86 = 0;
  }
  if ( !*(_BYTE *)(v6 + 7) )
    goto LABEL_56;
  v7 = *(_BYTE *)(v6 + 5);
  if ( *(_BYTE *)(v6 + 5) )
  {
    v39 = &v60;
    v55 = sub_5078(v5, &v57, &v58, &v59);
    if ( v55 )
    {
      v7 = v55;
      v39 = &v60;
    }
    else
    {
      v7 = sub_5A90(v58, v5, (int)&v60);
      if ( !v7 )
      {
        v60 = 0;
        sub_EB0C(v57, v31, v32, v56);
      }
    }
    v54 = v84;
    goto LABEL_38;
  }
  if ( !*(_BYTE *)(v6 + 6) )
  {
LABEL_56:
    v54 = v84;
    v7 = 0;
    v39 = &v60;
LABEL_38:
    if ( v54 )
    {
      if ( v86 )
        sub_6580((int)&v84, "%s", (int)v87, v86);
      else
        setenv(v85, "", 1);
    }
    goto LABEL_27;
  }
  v39 = &v60;
  v84 = *(_BYTE *)(v6 + 5);
LABEL_27:
  v90 = 0;
  sub_667C((int)&v87, v31, v32, 0);
  v91 = v87;
  sub_667C((int)&v87, v40, v41, (int)v87);
  if ( v76 )
  {
    if ( v78 )
      sub_6580((int)&v76, "%s", (int)v79, v78);
    else
      setenv(v77, "", 1);
  }
  v82 = 0;
  sub_667C((int)&v79, v42, v43, 0);
  v83 = v79;
  sub_667C((int)&v79, v44, v45, (int)v79);
  if ( v68 )
  {
    if ( v70 )
      sub_6580((int)&v68, "%s", (int)v71, v70);
    else
      setenv(v69, "", 1);
  }
  v74 = 0;
  sub_667C((int)&v71, v46, v47, 0);
  v75 = v71;
  sub_667C((int)&v71, v48, v49, (int)v71);
  if ( v60 )
  {
    if ( v62 )
      sub_6580((int)v39, "%s", (int)dest, v62);
    else
      setenv(name, "", 1);
  }
  v66 = 0;
  sub_667C((int)&dest, v50, v51, 0);
  v67 = dest;
  sub_667C((int)&dest, v52, v53, (int)dest);
  return v7;
}

//----- (00006580) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_6580(int a1, const char *a2, int a3, int a4)
{
  int v4; // r4@0
  int v5; // r5@0 OVERLAPPED
  int v7; // r7@0
  int v8; // lr@0
  int v9; // r6@1
  int v11; // [sp+8h] [bp+8h]@1
  int v12; // [sp+1008h] [bp+1008h]@1
  __int64 v13; // [sp+100Ch] [bp+100Ch]@1
  int v14; // [sp+1014h] [bp+1014h]@1
  int v15; // [sp+1018h] [bp+1018h]@1
  const char *varg_r1; // [sp+101Ch] [bp+101Ch]@1
  int varg_r2; // [sp+1020h] [bp+1020h]@1
  int varg_r3; // [sp+1024h] [bp+1024h]@1

  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  v14 = v7;
  v15 = v8;
  v13 = *(_QWORD *)&v5;
  v9 = a1;
  v12 = v4;
  sub_12498((char *)&v11, 0x1000u, a2, &varg_r2);
  return setenv(*(const char **)(v9 + 4), (const char *)&v11, 1);
}
// 6580: could not find valid save-restore pair for r4
// 6580: could not find valid save-restore pair for r5
// 6580: could not find valid save-restore pair for r6
// 6580: could not find valid save-restore pair for r7
// 6580: variables would overlap: r5.4 and r5.8
// 6580: variables would overlap: r6.4 and r5.8

//----- (000065D8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_65D8(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 65D8: could not find valid save-restore pair for r4
// 65D8: could not find valid save-restore pair for r7
// 65D8: variables would overlap: r3.4 and r3.8
// 65D8: variables would overlap: r4.4 and r3.8

//----- (00006600) --------------------------------------------------------
int __fastcall sub_6600(int a1, int a2, int a3, void *a4)
{
  __int64 v4; // r4@0
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r2@1
  int v8; // r5@2
  int v9; // r5@7
  int v10; // r1@7
  int v11; // r2@7
  int v12; // r3@7
  void *v13; // r0@10
  int v14; // r3@11
  int v15; // r1@11
  int v16; // r2@11
  int v17; // r3@11
  int v18; // r1@11
  int v19; // r2@11
  __int64 v21; // [sp+0h] [bp+0h]@1
  __int64 *v22; // [sp+8h] [bp+8h]@1
  int v23; // [sp+Ch] [bp+Ch]@1

  v21 = v4;
  v6 = a1;
  v22 = &v21;
  v23 = v5;
  v7 = *(_DWORD *)(a1 + 12);
  if ( v7 > 0 )
  {
    v8 = 0;
    do
    {
      a4 = *(void **)(*(_DWORD *)v6 + 4 * v8++);
      if ( a4 )
      {
        operator delete(a4);
        v7 = *(_DWORD *)(v6 + 12);
      }
    }
    while ( v8 < v7 );
  }
  v9 = 0;
  *(_DWORD *)(v6 + 12) = 0;
  sub_65D8(v6, a2, v7, (int)a4);
  v11 = *(_DWORD *)(v6 + 12);
  v12 = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 16) = *(_DWORD *)v6;
  if ( v11 > 0 )
  {
    while ( 1 )
    {
      v13 = *(void **)(v12 + 4 * v9++);
      operator delete(v13);
      v12 = *(_DWORD *)(v6 + 12);
      if ( v9 >= v12 )
        break;
      v12 = *(_DWORD *)v6;
    }
  }
  *(_DWORD *)(v6 + 12) = 0;
  sub_65D8(v6, v10, v11, v12);
  v14 = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)(v6 + 16) = v14;
  sub_65D8(v6, v15, v16, v14);
  v17 = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 16) = *(_DWORD *)v6;
  sub_65D8(v6, v18, v19, v17);
  return v6;
}
// 6600: could not find valid save-restore pair for r4
// 6600: could not find valid save-restore pair for r5
// 6600: could not find valid save-restore pair for r7

//----- (0000667C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_667C(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 667C: could not find valid save-restore pair for r4
// 667C: could not find valid save-restore pair for r7
// 667C: variables would overlap: r3.4 and r3.8
// 667C: variables would overlap: r4.4 and r3.8

//----- (000066A4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_66A4(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r3@1
  int v8; // r1@1
  int v9; // r2@1
  __int64 v11; // [sp+0h] [bp+0h]@1
  __int64 *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v11 = *(_QWORD *)&a4;
  v6 = a1;
  v12 = &v11;
  v13 = v5;
  *(_DWORD *)(a1 + 12) = 0;
  sub_667C(a1, a2, a3, 0);
  v7 = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 16) = *(_DWORD *)v6;
  sub_667C(v6, v8, v9, v7);
  return v6;
}
// 66A4: could not find valid save-restore pair for r4
// 66A4: could not find valid save-restore pair for r7
// 66A4: variables would overlap: r3.4 and r3.8
// 66A4: variables would overlap: r4.4 and r3.8

//----- (000066C8) --------------------------------------------------------
int __fastcall sub_66C8(int a1, int a2, int a3)
{
  __int64 v3; // r4@0
  int v4; // lr@0
  int v5; // r4@1
  int v6; // r3@4
  int v7; // r1@4
  int v8; // r2@4
  int v10; // [sp+0h] [bp+0h]@1
  int *v11; // [sp+8h] [bp+8h]@1
  int v12; // [sp+Ch] [bp+Ch]@1

  v11 = &v10;
  v12 = v4;
  *(_QWORD *)&v10 = v3;
  v5 = a1;
  if ( *(_BYTE *)a1 )
  {
    if ( *(_BYTE *)(a1 + 8) )
      sub_6580(a1, "%s", *(_DWORD *)(a1 + 12), *(_BYTE *)(a1 + 8));
    else
      setenv(*(const char **)(a1 + 4), "", 1);
  }
  *(_DWORD *)(v5 + 24) = 0;
  sub_667C(v5 + 12, a2, a3, 0);
  v6 = *(_DWORD *)(v5 + 12);
  *(_DWORD *)(v5 + 28) = v6;
  sub_667C(v5 + 12, v7, v8, v6);
  return v5;
}
// 66C8: could not find valid save-restore pair for r4
// 66C8: could not find valid save-restore pair for r5
// 66C8: could not find valid save-restore pair for r7

//----- (00006728) --------------------------------------------------------
int __fastcall sub_6728(int a1, int a2, int a3)
{
  __int64 v3; // r4@0
  int v4; // lr@0
  int v5; // r4@1
  int v6; // r3@4
  int v7; // r1@4
  int v8; // r2@4
  int v9; // r1@4
  int v10; // r2@4
  int v11; // r3@7
  int v12; // r1@7
  int v13; // r2@7
  int v14; // r1@7
  int v15; // r2@7
  int v16; // r3@10
  int v17; // r1@10
  int v18; // r2@10
  int v19; // r1@10
  int v20; // r2@10
  int v21; // r3@13
  int v22; // r1@13
  int v23; // r2@13
  int v25; // [sp+0h] [bp+0h]@1
  int *v26; // [sp+8h] [bp+8h]@1
  int v27; // [sp+Ch] [bp+Ch]@1

  v26 = &v25;
  v27 = v4;
  *(_QWORD *)&v25 = v3;
  v5 = a1;
  if ( *(_BYTE *)(a1 + 96) )
  {
    if ( *(_BYTE *)(a1 + 104) )
      sub_6580(a1 + 96, "%s", *(_DWORD *)(a1 + 108), *(_BYTE *)(a1 + 104));
    else
      setenv(*(const char **)(a1 + 100), "", 1);
  }
  *(_DWORD *)(v5 + 120) = 0;
  sub_667C(v5 + 108, a2, a3, 0);
  v6 = *(_DWORD *)(v5 + 108);
  *(_DWORD *)(v5 + 124) = v6;
  sub_667C(v5 + 108, v7, v8, v6);
  if ( *(_BYTE *)(v5 + 64) )
  {
    if ( *(_BYTE *)(v5 + 72) )
      sub_6580(v5 + 64, "%s", *(_DWORD *)(v5 + 76), *(_BYTE *)(v5 + 72));
    else
      setenv(*(const char **)(v5 + 68), "", 1);
  }
  *(_DWORD *)(v5 + 88) = 0;
  sub_667C(v5 + 76, v9, v10, 0);
  v11 = *(_DWORD *)(v5 + 76);
  *(_DWORD *)(v5 + 92) = v11;
  sub_667C(v5 + 76, v12, v13, v11);
  if ( *(_BYTE *)(v5 + 32) )
  {
    if ( *(_BYTE *)(v5 + 40) )
      sub_6580(v5 + 32, "%s", *(_DWORD *)(v5 + 44), *(_BYTE *)(v5 + 40));
    else
      setenv(*(const char **)(v5 + 36), "", 1);
  }
  *(_DWORD *)(v5 + 56) = 0;
  sub_667C(v5 + 44, v14, v15, 0);
  v16 = *(_DWORD *)(v5 + 44);
  *(_DWORD *)(v5 + 60) = v16;
  sub_667C(v5 + 44, v17, v18, v16);
  if ( *(_BYTE *)v5 )
  {
    if ( *(_BYTE *)(v5 + 8) )
      sub_6580(v5, "%s", *(_DWORD *)(v5 + 12), *(_BYTE *)(v5 + 8));
    else
      setenv(*(const char **)(v5 + 4), "", 1);
  }
  *(_DWORD *)(v5 + 24) = 0;
  sub_667C(v5 + 12, v19, v20, 0);
  v21 = *(_DWORD *)(v5 + 12);
  *(_DWORD *)(v5 + 28) = v21;
  sub_667C(v5 + 12, v22, v23, v21);
  return v5;
}
// 6728: could not find valid save-restore pair for r4
// 6728: could not find valid save-restore pair for r5
// 6728: could not find valid save-restore pair for r7

//----- (0000689C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_689C(void *result, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r6@1
  _DWORD *v9; // r4@1
  int i; // r1@1
  int v11; // r5@1
  void *v12; // r3@2
  signed int v13; // r2@4
  void *v14; // r0@8
  int v15; // r5@9
  int v16; // [sp+0h] [bp+0h]@1
  __int64 v17; // [sp+8h] [bp+8h]@1
  int *v18; // [sp+10h] [bp+10h]@1
  int v19; // [sp+14h] [bp+14h]@1

  v18 = &v16;
  v19 = v7;
  v17 = *(_QWORD *)&v5;
  v8 = a2;
  *(_QWORD *)&v16 = *(_QWORD *)&a4;
  v9 = result;
  i = *((_DWORD *)result + 1);
  v11 = *((_DWORD *)result + 3) + v8;
  if ( v11 <= i || (v13 = *((_DWORD *)result + 2), v13 < 0) )
  {
    v12 = *(void **)result;
LABEL_3:
    v9[3] = v11;
    v9[4] = v12;
    return result;
  }
  if ( v13 )
  {
    for ( i = v13 + (v11 - 1) / v13 * v13; v11 > i; i = (v11 + i) / 2 )
      ;
  }
  else if ( i || (i = 32, v11 > 32) )
  {
    do
    {
      i *= 2;
      if ( v11 <= i )
        break;
      i *= 2;
    }
    while ( v11 > i );
  }
  v14 = *(void **)result;
  v9[1] = i;
  if ( !v14 )
  {
    result = malloc(i);
    v12 = result;
    *v9 = result;
    goto LABEL_3;
  }
  result = realloc(v14, i);
  v15 = v9[3];
  *v9 = result;
  v9[4] = result;
  v9[3] = v15 + v8;
  return result;
}
// 689C: could not find valid save-restore pair for r4
// 689C: could not find valid save-restore pair for r5
// 689C: could not find valid save-restore pair for r6
// 689C: could not find valid save-restore pair for r7
// 689C: variables would overlap: r3.4 and r3.8
// 689C: variables would overlap: r4.4 and r3.8
// 689C: variables would overlap: r5.4 and r5.8
// 689C: variables would overlap: r6.4 and r5.8

//----- (00006920) --------------------------------------------------------
_DWORD *__fastcall sub_6920(_DWORD *result, int a2, int a3)
{
  signed int v3; // r3@1
  bool v4; // zf@1
  bool v5; // nf@1

  v3 = result[3] - a2 - a3;
  v4 = result[3] - a2 == a3;
  v5 = v3 < 0;
  if ( v3 > 0 )
  {
    v4 = a3 == 0;
    v5 = a3 < 0;
  }
  if ( !v5 && !v4 )
    result = j_memmove((void *)(a2 + a3 + *result), (const void *)(a2 + *result), v3);
  return result;
}
// 6920: could not find valid save-restore pair for r4
// 6920: could not find valid save-restore pair for r7

//----- (00006958) --------------------------------------------------------
void sub_6958()
{
  ;
}

//----- (00006968) --------------------------------------------------------
int __fastcall sub_6968(int a1, int a2)
{
  int v2; // lr@0
  _DWORD *v4; // [sp+0h] [bp+0h]@1
  int v5; // [sp+4h] [bp+4h]@1

  v4 = &v4;
  v5 = v2;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_29240 + 24))(dword_29240, a2);
}
// 6968: could not find valid save-restore pair for r7
// 29240: using guessed type int dword_29240;

//----- (00006984) --------------------------------------------------------
void sub_6984()
{
  dword_2E364 = 0;
  dword_29240 = 0;
  dword_29244 = 0;
}
// 29240: using guessed type int dword_29240;
// 29244: using guessed type int dword_29244;
// 2E364: using guessed type int dword_2E364;

//----- (000069AC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_69AC(int a1)
{
  int v1; // r4@0
  int v2; // r5@0 OVERLAPPED
  int v4; // r7@0
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r1@1
  int v10; // r0@1
  int v15; // r0@1
  int v16; // r1@1
  int v17; // r2@1
  int v18; // r3@1
  int v19; // r0@1
  int v20; // r2@1
  int v21; // r3@1
  int v22; // r2@1
  int v23; // r3@1
  signed int v24; // r5@1
  int v26; // r0@4
  int v27; // r2@6
  int v28; // r3@6
  int v29; // r0@7
  int v30; // r0@7
  int v31; // r1@7
  int v32; // r0@7
  int v33; // r0@7
  int v34; // r1@7
  int v35; // r0@8
  int v36; // r2@8
  int v37; // r3@8
  int v38; // r0@9
  int v39; // r0@10
  int v40; // r1@10
  int v41; // r2@10
  int v42; // r3@10
  int v43; // r0@11
  int v44; // r6@12
  int v45; // r0@13
  int v46; // r1@13
  int v47; // r0@13
  int v48; // r0@13
  const char *v49; // r1@13
  int v50; // r0@15
  int v53; // r0@16
  char v54; // [sp+3h] [bp+3h]@6
  int v55; // [sp+4h] [bp+4h]@1
  int v56; // [sp+6Ch] [bp+6Ch]@6
  int v57; // [sp+17Ch] [bp+17Ch]@1
  __int64 v58; // [sp+180h] [bp+180h]@1
  int v59; // [sp+188h] [bp+188h]@1
  int v60; // [sp+18Ch] [bp+18Ch]@1

  v59 = v4;
  v60 = v5;
  v58 = *(_QWORD *)&v2;
  v57 = v1;
  v6 = a1;
  v7 = sub_17F24(a1, (int)"VFileSystem022");
  v8 = (*(int (**)(void))(*(_DWORD *)v7 + 404))();
  v10 = CommandLine_Tier0(v8, v9);
  *(_BYTE *)(v6 + 344) = (*(int (**)(void))(*(_DWORD *)v10 + 12))() != 0;
  ((void (*)(void))Plat_FloatTime)();
  __asm { VMOV.F64        D8, D0 }
  memcpy(&v55, off_29008, 0x68u);
  sub_187D4(v6, dword_29248, "AndroidServicesVersion001");
  v19 = sub_1C630(v15, v16, v17, v18);
  sub_187D4(v6, v19, "SDLMgrInterface001");
  v24 = sub_1877C(v6, (const char **)&v55, v20, v21);
  if ( !v24 )
    goto LABEL_20;
  v26 = sub_184F4(v6, "sourcevr.so", v22, v23);
  if ( v26 != -1 )
    sub_186F4(v6, v26, "SourceVirtualReality001");
  if ( !sub_4E60((char *)&v56, 0x104u, &v54)
    && (((v29 = sub_184F4(v6, (const char *)&v56, v27, v28),
          v30 = sub_186F4(v6, v29, "QueuedLoaderVersion004"),
          v32 = CommandLine_Tier0(v30, v31),
          (v33 = (*(int (**)(void))(*(_DWORD *)v32 + 40))()) == 0)
      || (v35 = CommandLine_Tier0(v33, v34), (v33 = (*(int (**)(void))(*(_DWORD *)v35 + 40))()) != 0))
     && (v38 = CommandLine_Tier0(v33, v34), !(*(int (**)(void))(*(_DWORD *)v38 + 40))())
     || ((v39 = sub_184F4(v6, "p4lib.so", v36, v37), sub_186F4(v6, v39, "VP4001"))
      || (v53 = CommandLine_Tier0(0, v40), (*(int (**)(void))(*(_DWORD *)v53 + 40))()))
     && (v43 = sub_184F4(v6, "vstdlib.so", v41, v42), sub_186F4(v6, v43, "VProcessUtils001")))
    && (v44 = sub_17F24(v6, (int)"VMaterialSystem080")) != 0 )
  {
    v45 = sub_17F24(v6, (int)"VENGINE_LAUNCHER_API_VERSION004");
    dword_29240 = v45;
    v47 = CommandLine_Tier0(v45, v46);
    v48 = (*(int (**)(void))(*(_DWORD *)v47 + 40))();
    v49 = "shaderapidx9.so";
    if ( v48 )
      v49 = "shaderapiempty.so";
    v50 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v44 + 24))(v44, v49);
    Plat_FloatTime(v50);
    __asm
    {
      VSUB.F64        D0, D0, D8
      VCVT.F32.F64    S16, D0
      VCVT.F64.F32    D16, S16
      VMOV            R2, R3, D16
    }
    COM_TimestampedLog("LoadAppSystems:  Took %.4f secs to load libraries and get factories.");
  }
  else
  {
LABEL_20:
    v24 = 0;
  }
  return v24;
}
// 69AC: could not find valid save-restore pair for r4
// 69AC: could not find valid save-restore pair for r5
// 69AC: could not find valid save-restore pair for r6
// 69AC: could not find valid save-restore pair for r7
// 69AC: variables would overlap: r5.4 and r5.8
// 69AC: variables would overlap: r6.4 and r5.8
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 3790: using guessed type int __fastcall COM_TimestampedLog(_DWORD);
// 3924: using guessed type int __fastcall Plat_FloatTime(_DWORD);
// 29008: using guessed type char *off_29008[24];
// 29240: using guessed type int dword_29240;
// 29248: using guessed type int dword_29248;

//----- (00006D14) --------------------------------------------------------
_BYTE *__fastcall sub_6D14(int a1, int a2)
{
  int v2; // r0@1
  const char *v3; // r1@1

  byte_29358 = 0;
  v2 = CommandLine_Tier0(a1, a2);
  v3 = (const char *)(*(int (**)(void))(*(_DWORD *)v2 + 12))();
  if ( v3 )
    strcpy(&byte_29358, v3);
  return sub_133C8(&byte_29358, 47);
}
// 6D14: could not find valid save-restore pair for r7
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 29358: using guessed type char byte_29358;

//----- (00006D8C) --------------------------------------------------------
int __fastcall sub_6D8C(int a1, int a2)
{
  int v2; // lr@0
  int result; // r0@2
  int v4; // r0@3
  _DWORD *v5; // [sp+0h] [bp+0h]@1
  int v6; // [sp+4h] [bp+4h]@1

  v5 = &v5;
  v6 = v2;
  if ( *(_BYTE *)(a1 + 344) )
  {
    result = (*(int (**)(void))(*(_DWORD *)dword_29244 + 36))();
  }
  else
  {
    v4 = CommandLine_Tier0(a1, a2);
    result = (*(int (**)(void))(*(_DWORD *)v4 + 24))();
  }
  return result;
}
// 6D8C: could not find valid save-restore pair for r7
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 29244: using guessed type int dword_29244;

//----- (00006DC8) --------------------------------------------------------
int __fastcall sub_6DC8(int a1, int a2)
{
  int v2; // lr@0
  int result; // r0@2
  int v4; // r0@3
  _DWORD *v5; // [sp+0h] [bp+0h]@1
  int v6; // [sp+4h] [bp+4h]@1

  v5 = &v5;
  v6 = v2;
  if ( *(_BYTE *)(a1 + 344) )
  {
    result = (*(int (**)(void))(*(_DWORD *)dword_29244 + 40))();
  }
  else
  {
    v4 = CommandLine_Tier0(a1, a2);
    result = (*(int (**)(void))(*(_DWORD *)v4 + 24))();
  }
  return result;
}
// 6DC8: could not find valid save-restore pair for r7
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 29244: using guessed type int dword_29244;

//----- (00006E38) --------------------------------------------------------
int sub_6E38()
{
  int result; // r0@1

  result = dword_29070;
  if ( dword_29070 != -1 )
  {
    close(dword_29070);
    dword_29070 = -1;
    result = j_unlink((const char *)&unk_29460);
  }
  return result;
}
// 6E38: could not find valid save-restore pair for r4
// 29070: using guessed type int dword_29070;

//----- (00006E7C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_6E7C(int a1, int a2)
{
  int v2; // r4@0
  int v3; // r5@0 OVERLAPPED
  __int64 v5; // r7@0
  int v6; // r9@0
  int v7; // lr@0
  int v8; // r4@1
  signed int v9; // r6@1
  int v10; // r0@3
  int result; // r0@3
  int v12; // r1@3
  int v13; // r0@4
  const char *v14; // r0@4
  int v15; // r0@5
  int v16; // r0@5
  int v17; // r0@7
  int v18; // r0@7
  int v19; // r1@7
  int v20; // r0@7
  int v21; // [sp+4h] [bp+4h]@5
  int v22; // [sp+10Ch] [bp+10Ch]@1
  __int64 v23; // [sp+110h] [bp+110h]@1
  __int64 v24; // [sp+118h] [bp+118h]@1
  int v25; // [sp+120h] [bp+120h]@1
  int v26; // [sp+124h] [bp+124h]@1

  v24 = v5;
  v23 = *(_QWORD *)&v3;
  v25 = v6;
  v26 = v7;
  v22 = v2;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = CommandLine_Tier0(a1, a2);
    result = (*(int (**)(void))(*(_DWORD *)v10 + 36))() - 1;
    if ( v8 >= result )
      break;
    v13 = CommandLine_Tier0(result, v12);
    v14 = (const char *)(*(int (**)(void))(*(_DWORD *)v13 + 44))();
    a1 = sub_11A70(v14, "-game");
    if ( !a1 )
    {
      v15 = CommandLine_Tier0(0, a2);
      ++v8;
      ++v9;
      v16 = (*(int (**)(void))(*(_DWORD *)v15 + 44))();
      a1 = sub_12440((char *)&v21, 0x104u, "\"%s\"", v16);
    }
    ++v8;
  }
  if ( v9 > 1 )
  {
    v17 = CommandLine_Tier0(result, v12);
    v18 = (*(int (**)(void))(*(_DWORD *)v17 + 16))();
    v20 = CommandLine_Tier0(v18, v19);
    result = (*(int (**)(void))(*(_DWORD *)v20 + 20))();
  }
  return result;
}
// 6E7C: could not find valid save-restore pair for r4
// 6E7C: could not find valid save-restore pair for r5
// 6E7C: could not find valid save-restore pair for r6
// 6E7C: could not find valid save-restore pair for r7
// 6E7C: could not find valid save-restore pair for r8
// 6E7C: could not find valid save-restore pair for r9
// 6E7C: variables would overlap: r5.4 and r5.8
// 6E7C: variables would overlap: r6.4 and r5.8
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);

//----- (00006F34) --------------------------------------------------------
int __fastcall sub_6F34(int a1, const char *a2)
{
  int v2; // lr@0
  int v3; // r6@1
  const char *v4; // r8@1
  int v5; // r5@1
  int (__fastcall *v6)(int, _BYTE *, char *, const char *); // r9@1
  char *v7; // r10@1
  char *v8; // r0@1
  int result; // r0@1
  int v10; // r5@1
  int v11; // r6@2
  size_t v12; // r0@2
  int v13; // [sp+Ch] [bp+4h]@1
  _BYTE v14[3]; // [sp+11h] [bp+9h]@1
  int v15; // [sp+134h] [bp+12Ch]@1

  v15 = v2;
  v3 = a1 + 4128;
  v4 = a2;
  v5 = dword_2E35C + 4;
  v6 = *(int (__fastcall **)(int, _BYTE *, char *, const char *))(*(_DWORD *)(dword_2E35C + 4) + 8);
  v7 = sub_168CC(a1 + 4152);
  v8 = sub_168CC(v3 + 8);
  sub_80A0((int)&v13, (int)"%s\\%s\\%s", (int)v7, (int)v8);
  result = v6(v5, v14, "at", "GAME");
  v10 = result;
  if ( result )
  {
    (*(void (__fastcall **)(int, char *, signed int, int))(*(_DWORD *)(dword_2E35C + 4) + 4))(
      dword_2E35C + 4,
      "\"",
      1,
      result);
    v11 = dword_2E35C;
    v12 = strlen(v4);
    (*(void (__fastcall **)(int, const char *, size_t, int))(*(_DWORD *)(v11 + 4) + 4))(v11 + 4, v4, v12, v10);
    (*(void (__fastcall **)(int, const char *, signed int, int))(*(_DWORD *)(dword_2E35C + 4) + 4))(
      dword_2E35C + 4,
      "\"\n",
      2,
      v10);
    result = (*(int (__fastcall **)(int, int))(*(_DWORD *)(dword_2E35C + 4) + 12))(dword_2E35C + 4, v10);
  }
  return result;
}
// 2E35C: using guessed type int dword_2E35C;

//----- (00007018) --------------------------------------------------------
char *__fastcall sub_7018(int a1, int a2)
{
  int v2; // lr@0
  int v3; // r5@1
  int v4; // r0@1
  char *result; // r0@1
  int v6; // r1@1
  const char *v7; // r4@1
  int v8; // r0@3
  int v9; // r1@3
  int v10; // r0@4
  void *v11; // r0@4
  const char *v12; // r1@4
  int v13; // r1@6
  int v14; // r2@6
  int v15; // r3@6
  int v16; // r2@6
  int v17; // r3@6
  int v18; // r8@7
  int v19; // r10@7
  int v20; // r0@8
  void *v21; // r8@8
  int v22; // r0@8
  int v23; // r2@8
  int v24; // r3@8
  char *v25; // r6@8
  char *v26; // r0@8
  int v27; // r0@8
  int v28; // r1@8
  int v29; // r0@8
  int v30; // r1@8
  char *v31; // r5@9
  int v32; // r0@11
  int v33; // r1@11
  int v34; // r4@12
  void (__fastcall *v35)(int, _BYTE *, const char *); // r6@12
  char *v36; // r8@12
  char *v37; // r0@12
  const char *v38; // [sp+8h] [bp+0h]@4
  int v39; // [sp+Ch] [bp+4h]@8
  int v40; // [sp+110h] [bp+108h]@8
  int v41; // [sp+214h] [bp+20Ch]@6
  _BYTE v42[3]; // [sp+219h] [bp+211h]@12
  int v43; // [sp+33Ch] [bp+334h]@1

  v3 = a1;
  v43 = v2;
  v4 = CommandLine_Tier0(a1, a2);
  result = (char *)(*(int (**)(void))(*(_DWORD *)v4 + 12))();
  v7 = result;
  if ( !result )
  {
    v8 = CommandLine_Tier0(0, v6);
    result = (char *)(*(int (**)(void))(*(_DWORD *)v8 + 12))();
    if ( result )
    {
      v38 = v7;
      *(_BYTE *)v3 = 1;
      v10 = CommandLine_Tier0(result, v9);
      v11 = (void *)(*(int (**)(void))(*(_DWORD *)v10 + 12))();
      if ( v11
        && (v12 = v38) != 0
        && (sub_12330((char *)&v41, v38, 0x104u),
            sub_13234((const char *)&v41, v13, v14, v15),
            sub_133C8(&v41, 47),
            v11 = (void *)strlen((const char *)&v41),
            (signed int)v11 > 0) )
      {
        v18 = v3 + 4128;
        v19 = v3 + 4136;
        v11 = sub_169D0((void *)(v3 + 4136), (const char *)&v41, v16, v17);
      }
      else
      {
        v18 = v3 + 4128;
        v19 = v3 + 4136;
      }
      v20 = CommandLine_Tier0(v11, v12);
      v21 = (void *)(v18 + 24);
      v22 = (*(int (**)(void))(*(_DWORD *)v20 + 24))();
      sub_12440((char *)&v39, 0x104u, "%s/%s", &byte_29358, v22);
      sub_133C8(&v39, 47);
      sub_169D0(v21, (const char *)&v39, v23, v24);
      v25 = sub_168CC((int)v21);
      v26 = sub_168CC(v19);
      sub_12440((char *)&v40, 0x104u, "%s\\%s", v25, v26);
      (*(void (**)(void))(*(_DWORD *)dword_2E35C + 68))();
      v27 = (*(int (**)(void))(*(_DWORD *)dword_2E35C + 264))();
      v29 = CommandLine_Tier0(v27, v28);
      if ( !(*(int (**)(void))(*(_DWORD *)v29 + 40))() )
      {
        v32 = CommandLine_Tier0(0, v30);
        if ( !(*(int (**)(void))(*(_DWORD *)v32 + 40))() )
        {
          sub_7FE4(v3 + 4100, v33);
          v34 = dword_2E35C;
          v35 = *(void (__fastcall **)(int, _BYTE *, const char *))(*(_DWORD *)dword_2E35C + 60);
          v36 = sub_168CC((int)v21);
          v37 = sub_168CC(v19);
          sub_80A0((int)&v41, (int)"%s\\%s\\%s", (int)v36, (int)v37);
          v35(v34, v42, "GAME");
        }
      }
      v31 = (char *)(v3 + 1);
      getcwd(v31, 0x1000u);
      result = sub_1250C(v31, (const char *)&word_1EAB0, 0x1000u, 1);
    }
  }
  return result;
}
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 1EAB0: using guessed type __int16 word_1EAB0;
// 29358: using guessed type char byte_29358;
// 2E35C: using guessed type int dword_2E35C;

//----- (00007220) --------------------------------------------------------
signed int __fastcall sub_7220(int a1)
{
  int v1; // lr@0
  int v2; // r8@1
  int v3; // r1@3
  int v4; // r1@3
  int v5; // r2@3
  int v6; // r3@3
  signed int result; // r0@5
  int v8; // r2@7
  int v9; // r0@8
  void *v10; // r5@8
  void (__fastcall *v11)(void *, char *, int); // r9@8
  int v12; // r1@8
  int v13; // r0@8
  int v14; // r0@8
  int v15; // r1@8
  int v16; // r1@10
  int v17; // r1@10
  int (*v18)(); // [sp+0h] [bp+0h]@1
  char v19; // [sp+8h] [bp+8h]@7
  _BYTE *v20; // [sp+Ch] [bp+Ch]@7
  int v21; // [sp+10h] [bp+10h]@7
  int v22; // [sp+14h] [bp+14h]@10
  char *v23; // [sp+18h] [bp+18h]@10
  int v24; // [sp+1Ch] [bp+1Ch]@10
  int v25; // [sp+20h] [bp+20h]@10
  int v26; // [sp+24h] [bp+24h]@10
  char v27; // [sp+28h] [bp+28h]@10
  int v28; // [sp+2Ch] [bp+2Ch]@3
  char v29; // [sp+30h] [bp+30h]@3
  char v30; // [sp+31h] [bp+31h]@3
  char v31; // [sp+32h] [bp+32h]@3
  char v32; // [sp+33h] [bp+33h]@3
  _BYTE v33[3]; // [sp+35h] [bp+35h]@7
  int v34; // [sp+254h] [bp+254h]@1

  v34 = v1;
  v2 = a1;
  v18 = sub_18120();
  sub_141B0((int)&v18, 1);
  sub_B838(0, 0);
  sub_1CB40((int)&v18, 1);
  sub_1CD40((int)&v18, 1);
  if ( !dword_2E35C || !dword_2E364 )
    goto LABEL_15;
  sub_46A4((int)&v28);
  v30 = 0;
  v31 = 0;
  v32 = (*(int (**)(void))(*(_DWORD *)dword_2E35C + 20))();
  v29 = 1;
  v28 = sub_6D8C(v2, v3);
  if ( !v28 )
  {
    v28 = sub_6DC8(v2, v4);
    if ( !v28 )
      ((void (__fastcall *)(const char *))Error)("FileSystem_LoadFileSystemModule: no -defaultgamedir or -game specified.");
  }
  if ( sub_60FC((int)&v28, v4, v5, v6)
    || (sub_46E8(&v19),
        v8 = *(_BYTE *)(v2 + 344),
        v20 = v33,
        v21 = dword_2E35C,
        v19 = v8,
        sub_4EC8((int)&v19, (int)v33, v8, dword_2E35C)) )
  {
LABEL_15:
    result = 0;
  }
  else
  {
    v9 = (*(int (**)(void))(*(_DWORD *)v21 + 28))();
    v10 = off_2908C;
    v11 = **(void (__fastcall ***)(void *, char *, int))off_2908C;
    v13 = CommandLine_Tier0(v9, v12);
    v14 = (*(int (**)(void))(*(_DWORD *)v13 + 24))();
    v11(v10, &byte_29358, v14);
    (*(void (**)(void))(*(_DWORD *)off_2908C + 12))();
    sub_7018((int)&unk_29564, v15);
    if ( *(_BYTE *)(v2 + 344) )
      (*(void (**)(void))(*(_DWORD *)dword_2E364 + 228))();
    v22 = sub_19F1C();
    v23 = &byte_29358;
    v24 = sub_6D8C(v2, v16);
    v25 = sub_6DC8(v2, v17);
    v26 = v2;
    v27 = byte_2A5AC;
    (*(void (__fastcall **)(int, int *))(*(_DWORD *)dword_29240 + 20))(dword_29240, &v22);
    result = 1;
  }
  return result;
}
// 3BE0: invalid function type has been ignored
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 2908C: using guessed type void *off_2908C;
// 29240: using guessed type int dword_29240;
// 29358: using guessed type char byte_29358;
// 2A5AC: using guessed type char byte_2A5AC;
// 2E35C: using guessed type int dword_2E35C;
// 2E364: using guessed type int dword_2E364;

//----- (00007464) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_7464(_BYTE *a1, int a2)
{
  int v2; // r4@0
  int v3; // r5@0 OVERLAPPED
  __int64 v5; // r7@0
  int v6; // r9@0 OVERLAPPED
  int v8; // r11@0
  int v9; // lr@0
  _BYTE *v10; // r4@1
  int v11; // r0@3
  _DWORD *v12; // r5@5
  int v13; // r6@5
  int v14; // r4@5
  char *v15; // r9@5
  char *v16; // r0@5
  char *v17; // r0@5
  int v18; // r1@5
  int v19; // r1@5
  int v20; // r2@5
  char *v21; // [sp+Ch] [bp+4h]@5
  int v22; // [sp+14h] [bp+Ch]@5
  _BYTE v23[3]; // [sp+19h] [bp+11h]@5
  int v24; // [sp+124h] [bp+11Ch]@1
  __int64 v25; // [sp+128h] [bp+120h]@1
  __int64 v26; // [sp+130h] [bp+128h]@1
  __int64 v27; // [sp+138h] [bp+130h]@1
  int v28; // [sp+140h] [bp+138h]@1
  int v29; // [sp+144h] [bp+13Ch]@1

  v26 = v5;
  v24 = v2;
  v10 = a1;
  v28 = v8;
  v29 = v9;
  v27 = *(_QWORD *)&v6;
  v25 = *(_QWORD *)&v3;
  if ( *a1 )
  {
    *a1 = 0;
    v11 = CommandLine_Tier0(a1, a2);
    if ( (*(int (**)(void))(*(_DWORD *)v11 + 12))() )
      (*(void (**)(void))(*(_DWORD *)dword_2E35C + 268))();
    v12 = v10 + 4128;
    v13 = (int)(v10 + 4136);
    v21 = v10 + 4152;
    v14 = (int)(v10 + 4100);
    v15 = sub_168CC((int)v21);
    v16 = sub_168CC(v13);
    sub_80A0((int)&v22, (int)"%s\\%s\\%s", (int)v15, (int)v16);
    sub_A6D8((int)v23, (int)"GAME");
    v21 = sub_168CC((int)v21);
    v17 = sub_168CC(v13);
    sub_80A0((int)&v22, (int)"%s\\%s\\%s", (int)v21, (int)v17);
    sub_A6D8((int)v23, (int)"GAME");
    sub_7FE4(v14, v18);
    *(_DWORD *)(v14 + 24) = -1;
    sub_811C(v14 + 4, v19, v20, -1);
    *v12 = -1;
  }
}
// 7464: could not find valid save-restore pair for r4
// 7464: could not find valid save-restore pair for r5
// 7464: could not find valid save-restore pair for r6
// 7464: could not find valid save-restore pair for r7
// 7464: could not find valid save-restore pair for r8
// 7464: could not find valid save-restore pair for r9
// 7464: could not find valid save-restore pair for r10
// 7464: could not find valid save-restore pair for r11
// 7464: variables would overlap: r5.4 and r5.8
// 7464: variables would overlap: r6.4 and r5.8
// 7464: variables would overlap: r9.4 and r9.8
// 7464: variables would overlap: r10.4 and r9.8
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 2E35C: using guessed type int dword_2E35C;

//----- (00007584) --------------------------------------------------------
int __fastcall sub_7584(int a1, int a2)
{
  int v2; // r1@1
  int result; // r0@1

  sub_7464(&unk_29564, a2);
  (*(void (__cdecl **)(void *, int))(*(_DWORD *)off_2908C + 4))(off_2908C, v2);
  sub_1CFD0();
  sub_1CD10();
  result = sub_B8D4();
  if ( byte_2CB80 )
  {
    dword_2CB84 = 0;
    dword_2CB88 = 0;
    byte_2CB80 = 0;
    cvar = 0;
  }
  return result;
}
// 7584: could not find valid save-restore pair for r7
// 2908C: using guessed type void *off_2908C;
// 2CB80: using guessed type char byte_2CB80;
// 2CB84: using guessed type int dword_2CB84;
// 2CB88: using guessed type int dword_2CB88;

//----- (000075C8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_75C8(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  __int64 v8; // r9@0
  int v9; // r11@0
  int v10; // lr@0
  int v11; // r11@1
  int v12; // r3@1
  int v13; // r8@3
  int v14; // r1@3
  int v15; // r2@3
  int v16; // r3@3
  int v17; // r4@3
  _DWORD *v18; // r5@4
  int v19; // r4@7
  int v20; // r2@8
  int v21; // r3@8
  int v22; // r2@11
  int v23; // r3@11
  int v24; // r1@11
  int v25; // r2@11
  int v26; // r3@11
  _BYTE *v27; // r4@11
  size_t v28; // r0@12
  int *v29; // r3@14
  int *v30; // r3@16
  int *v31; // [sp+4h] [bp+4h]@4
  int *v32; // [sp+8h] [bp+8h]@4
  _BYTE *v33; // [sp+Ch] [bp+Ch]@1
  int v34; // [sp+14h] [bp+14h]@3
  int v35; // [sp+11Ch] [bp+11Ch]@1
  __int64 v36; // [sp+120h] [bp+120h]@1
  __int64 v37; // [sp+128h] [bp+128h]@1
  __int64 v38; // [sp+130h] [bp+130h]@1
  int v39; // [sp+138h] [bp+138h]@1
  int v40; // [sp+13Ch] [bp+13Ch]@1

  v39 = v9;
  v40 = v10;
  v11 = (int)a1;
  v37 = *(_QWORD *)&v6;
  v38 = v8;
  v36 = *(_QWORD *)&v4;
  v35 = v3;
  v12 = *a1;
  v33 = a2;
  if ( v12 )
  {
    v13 = (int)(a1 + 4100);
    sub_16E7C(&v34, (int)a2, a3, v12);
    v17 = *(_DWORD *)(v13 + 16);
    if ( v17 == -1 )
    {
LABEL_11:
      sub_7FBC((int)&v34, v14, v15, v16);
      sub_16E7C(&v34, (int)v33, v22, v23);
      sub_9188(v13, (int)&v34);
      sub_7FBC((int)&v34, v24, v25, v26);
      v27 = sub_12140(v33, &byte_29358);
      if ( v27 )
      {
        v28 = strlen(&byte_29358);
        sub_12330((char *)&v34, &v27[v28 + 1], 0x104u);
        sub_133C8(&v34, 47);
        sub_6F34(v11, (const char *)&v34);
      }
    }
    else
    {
      v18 = (_DWORD *)(v11 + 4104);
      v31 = &dword_2907C;
      v32 = &dword_2907C;
      while ( 1 )
      {
        while ( 1 )
        {
          v19 = 32 * v17;
          if ( !(*(int (__fastcall **)(int *, int))v13)(&v34, *v18 + v19 + 16) )
            break;
          v14 = dword_2A5F0 << 31;
          if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
          {
            v29 = v32;
            *v32 = -1;
            v29[1] = -1;
            v29[2] = -1;
            _cxa_guard_release(&dword_2A5F0);
          }
          v17 = *(_DWORD *)(*v18 + v19);
          v16 = v17 + 1;
          if ( v17 == -1 )
            goto LABEL_11;
        }
        if ( !(*(int (__fastcall **)(int, int *))v13)(*v18 + v19 + 16, &v34) )
          break;
        v15 = dword_2A5F0 << 31;
        if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
        {
          v30 = v31;
          *v31 = -1;
          v30[1] = -1;
          v30[2] = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v17 = *(_DWORD *)(v19 + *v18 + 4);
        v16 = v17 + 1;
        if ( v17 == -1 )
          goto LABEL_11;
      }
      sub_7FBC((int)&v34, v14, v20, v21);
    }
  }
}
// 75C8: could not find valid save-restore pair for r4
// 75C8: could not find valid save-restore pair for r5
// 75C8: could not find valid save-restore pair for r6
// 75C8: could not find valid save-restore pair for r7
// 75C8: could not find valid save-restore pair for r8
// 75C8: could not find valid save-restore pair for r9
// 75C8: could not find valid save-restore pair for r10
// 75C8: could not find valid save-restore pair for r11
// 75C8: variables would overlap: r5.4 and r5.8
// 75C8: variables would overlap: r6.4 and r5.8
// 75C8: variables would overlap: r7.4 and r7.8
// 75C8: variables would overlap: r8.4 and r7.8
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29358: using guessed type char byte_29358;
// 2A5F0: using guessed type int dword_2A5F0;

//----- (00007764) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall LauncherMainAndroid(int a1, int a2, int a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  int v8; // r9@0 OVERLAPPED
  int v10; // r11@0
  int v11; // lr@0
  int v12; // r6@1
  int v13; // r8@1
  char *v14; // r5@1
  int v15; // r0@5
  int v16; // r0@5
  int v17; // r1@5
  int v18; // r0@5
  int v19; // r0@7
  int v20; // r0@7
  int v21; // r1@7
  int v22; // r0@8
  void ***v23; // r4@8
  int v24; // r0@8
  int v25; // r1@8
  int v26; // r0@8
  int v27; // r0@8
  int v28; // r1@8
  int v29; // r0@8
  int v30; // r0@8
  int v31; // r1@8
  int v32; // r0@8
  int v33; // r0@8
  int v34; // r1@8
  int v35; // r0@8
  int v36; // r1@8
  int v37; // r0@10
  int v38; // r1@10
  int v39; // r0@11
  int v40; // r1@11
  int v41; // r0@12
  int v42; // r1@12
  int v43; // r0@12
  int v44; // r0@12
  int v45; // r1@12
  int v46; // r0@14
  int v47; // r1@14
  int *v48; // r5@16
  int v49; // r0@16
  int v50; // r1@16
  int v51; // r3@16
  int v52; // r0@16
  void **v53; // r3@18
  int v54; // r2@19
  int v55; // r3@19
  int v56; // r1@19
  int v57; // r2@19
  int v58; // r3@19
  signed int v59; // r6@19
  int v60; // r0@19
  int v61; // r1@19
  int v62; // r2@22
  int *v63; // r6@22
  signed int v64; // r11@22
  char v65; // r3@22
  int *v66; // r2@22
  void ***v67; // r5@22
  int *v68; // r4@22
  int *v69; // r9@23
  __int16 *v70; // r3@24
  __int16 *v71; // r2@31
  int *v72; // r2@42
  int v73; // r1@48
  int v74; // r2@48
  int v75; // r3@48
  int v76; // r1@48
  int v77; // r2@48
  int v78; // r3@48
  int v79; // r1@48
  int v80; // r2@48
  int v81; // r3@48
  int v82; // r1@48
  int v83; // r2@48
  int v84; // r2@48
  int v85; // r3@48
  int v86; // r2@48
  int v87; // r0@48
  int v88; // r1@48
  signed int v89; // r11@48
  char v90; // r3@48
  __int16 *v91; // r3@50
  __int16 *v92; // r2@57
  int *v93; // r6@69
  int v94; // r1@72
  int v95; // r2@72
  int v96; // r3@72
  int v97; // r1@72
  int v98; // r2@72
  int v99; // r3@72
  int v100; // r1@72
  int v101; // r2@72
  int v102; // r3@72
  int v103; // r3@72
  int v104; // r1@72
  int v105; // r2@72
  int v106; // r1@72
  int v107; // r2@72
  int v108; // r3@72
  int v109; // r3@72
  int v110; // r1@72
  int v111; // r2@72
  int v112; // r6@73
  __int16 *v114; // r2@66
  __int16 *v115; // r2@40
  int v116; // r0@78
  int v117; // r0@78
  int v118; // r1@78
  int v119; // r0@78
  int v120; // r0@78
  int v121; // r1@78
  int v122; // r0@78
  int v123; // r0@78
  int v124; // r1@78
  int v125; // r0@78
  int v126; // r0@78
  int v127; // r1@78
  int v128; // r0@78
  int v129; // r0@78
  int v130; // r1@78
  int v131; // r0@78
  int v132; // r0@78
  int v133; // r1@78
  int v134; // r0@78
  int v135; // r0@78
  int v136; // r1@78
  int v137; // r0@78
  int v138; // r0@78
  int v139; // r1@78
  int v140; // r0@78
  int v141; // r0@78
  int v142; // r1@78
  int v143; // r0@78
  int v144; // r0@78
  int v145; // r1@78
  int v146; // r0@78
  int v147; // r0@78
  int v148; // r1@78
  int v149; // r0@78
  int v150; // r0@78
  int v151; // r1@78
  int v152; // r0@78
  FILE *v153; // r8@80
  size_t v154; // r0@81
  signed int v155; // lr@81
  int v156; // r0@86
  int v157; // r0@15
  int *v158; // [sp+4h] [bp+4h]@48
  const char *v159; // [sp+8h] [bp+8h]@16
  const char *v160; // [sp+Ch] [bp+Ch]@16
  const char *v161; // [sp+10h] [bp+10h]@16
  const char *v162; // [sp+14h] [bp+14h]@16
  const char *v163; // [sp+18h] [bp+18h]@16
  void **v164; // [sp+1Ch] [bp+1Ch]@18
  int *v165; // [sp+20h] [bp+20h]@1
  int v166; // [sp+24h] [bp+24h]@21
  int v167; // [sp+28h] [bp+28h]@22
  __int16 *v168; // [sp+2Ch] [bp+2Ch]@22
  __int16 *v169; // [sp+30h] [bp+30h]@22
  __int16 *v170; // [sp+34h] [bp+34h]@22
  int v171; // [sp+38h] [bp+38h]@11
  signed int v172; // [sp+3Ch] [bp+3Ch]@1
  signed int v173; // [sp+40h] [bp+40h]@1
  signed int v174; // [sp+44h] [bp+44h]@1
  int v175; // [sp+48h] [bp+48h]@73
  int v176; // [sp+B0h] [bp+B0h]@16
  int v177; // [sp+B4h] [bp+B4h]@48
  int v178; // [sp+C8h] [bp+C8h]@48
  int v179; // [sp+DCh] [bp+DCh]@45
  int v180; // [sp+E0h] [bp+E0h]@48
  int v181; // [sp+1B0h] [bp+1B0h]@8
  int v182; // [sp+1B4h] [bp+1B4h]@72
  int v183; // [sp+1C8h] [bp+1C8h]@72
  int v184; // [sp+1DCh] [bp+1DCh]@69
  int v185; // [sp+1E0h] [bp+1E0h]@72
  int v186; // [sp+314h] [bp+314h]@1
  __int64 v187; // [sp+318h] [bp+318h]@1
  __int64 v188; // [sp+320h] [bp+320h]@1
  __int64 v189; // [sp+328h] [bp+328h]@1
  int v190; // [sp+330h] [bp+330h]@1
  int v191; // [sp+334h] [bp+334h]@1

  v187 = *(_QWORD *)&v4;
  v12 = a2;
  v190 = v10;
  v191 = v11;
  v188 = *(_QWORD *)&v6;
  v13 = a1;
  v186 = v3;
  v189 = *(_QWORD *)&v8;
  dword_29248 = a3;
  v165 = &GLOBAL_OFFSET_TABLE_;
  v172 = 1432317541;
  v173 = 1414868563;
  v174 = 3681606;
  setenv("LC_ALL", (const char *)&v172, 1);
  setlocale(6, (const char *)&v172);
  v14 = setlocale(6, 0);
  if ( !v14 )
    v14 = "";
  if ( sub_11A70(v14, (const char *)&v172) )
    Warning("WARNING: setlocale('%s') failed, using locale:'%s'. International characters may not work.\n", &v172, v14);
  v15 = BuildCmdLine(v13, v12, 0);
  v16 = Plat_SetCommandLine(v15);
  v18 = CommandLine_Tier0(v16, v17);
  if ( (*(int (**)(void))(*(_DWORD *)v18 + 12))() )
    sleep(5u);
  v19 = SpewOutputFunc(sub_6C04);
  v20 = Plat_VerifyHardwareKeyPrompt(v19);
  if ( !v20 )
    return -1;
  v22 = CommandLine_Tier0(v20, v21);
  v23 = (void ***)&v181;
  v24 = (*(int (**)(void))(*(_DWORD *)v22 + 4))();
  v26 = CommandLine_Tier0(v24, v25);
  v27 = (*(int (**)(void))(*(_DWORD *)v26 + 16))();
  v29 = CommandLine_Tier0(v27, v28);
  v30 = (*(int (**)(void))(*(_DWORD *)v29 + 16))();
  v32 = CommandLine_Tier0(v30, v31);
  v33 = (*(int (**)(void))(*(_DWORD *)v32 + 16))();
  sub_6D14(v33, v34);
  v35 = stat("/tmp/hl2_relaunch", (struct stat *)&v181);
  if ( !v35 )
    v35 = unlink("/tmp/hl2_relaunch");
  v37 = CommandLine_Tier0(v35, v36);
  if ( (*(int (**)(void))(*(_DWORD *)v37 + 12))() )
  {
    v39 = (**(int (__fastcall ***)(int, signed int, void *))v165[192])(v171, 1, &unk_2A5B0);
    if ( !v39 )
    {
      v112 = -1;
      ((void (*)(const char *, ...))Error)("-vcrrecord: can't open '%s' for writing.\n", v171);
      return v112;
    }
  }
  else
  {
    v156 = CommandLine_Tier0(0, v38);
    v39 = (*(int (**)(void))(*(_DWORD *)v156 + 12))();
    if ( v39 )
    {
      v39 = (**(int (__fastcall ***)(int, _DWORD, void *))v165[192])(v171, 0, &unk_2A5B0);
      if ( !v39 )
      {
        v112 = -1;
        ((void (*)(const char *, ...))Error)("-vcrplayback: can't open '%s' for reading.\n", v171);
        return v112;
      }
    }
  }
  v41 = sub_6E7C(v39, v40);
  v43 = CommandLine_Tier0(v41, v42);
  v44 = (*(int (**)(void))(*(_DWORD *)v43 + 12))();
  if ( v44 )
    byte_2A5AC = 1;
  v46 = CommandLine_Tier0(v44, v45);
  if ( !(*(int (**)(void))(*(_DWORD *)v46 + 12))() )
  {
    v157 = CommandLine_Tier0(0, v47);
    (*(void (**)(void))(*(_DWORD *)v157 + 20))();
  }
  v48 = &v176;
  v163 = "-w";
  v162 = "-h";
  v161 = "-width";
  v160 = "-height";
  v49 = chdir(&byte_29358);
  v51 = *(_DWORD *)CommandLine_Tier0(v49, v50);
  v159 = "-sw";
  v52 = (*(int (**)(void))(v51 + 12))();
  if ( v52 )
    LOBYTE(v52) = 1;
  v53 = &off_285D0;
  byte_2A5B4 = v52;
  v164 = &off_285D0;
  do
  {
    sub_18138((int)v23, 0, 0, (int)v53);
    *v23 = v164;
    sub_19FAC((int)v48, (int)v23, v54, v55);
    v59 = sub_184A4((int)v48, v56, v57, v58);
    v60 = sub_18110((int)v48);
    if ( v60 == 3 )
    {
      if ( v59 == 2 )
      {
LABEL_77:
        v166 = 1;
LABEL_78:
        v116 = CommandLine_Tier0(v60, v61);
        v117 = (*(int (**)(void))(*(_DWORD *)v116 + 16))();
        v119 = CommandLine_Tier0(v117, v118);
        v120 = (*(int (**)(void))(*(_DWORD *)v119 + 16))();
        v122 = CommandLine_Tier0(v120, v121);
        v123 = (*(int (**)(void))(*(_DWORD *)v122 + 16))();
        v125 = CommandLine_Tier0(v123, v124);
        v126 = (*(int (**)(void))(*(_DWORD *)v125 + 16))();
        v128 = CommandLine_Tier0(v126, v127);
        v129 = (*(int (**)(void))(*(_DWORD *)v128 + 16))();
        v131 = CommandLine_Tier0(v129, v130);
        v132 = (*(int (**)(void))(*(_DWORD *)v131 + 16))();
        v134 = CommandLine_Tier0(v132, v133);
        v135 = (*(int (**)(void))(*(_DWORD *)v134 + 16))();
        v137 = CommandLine_Tier0(v135, v136);
        v138 = (*(int (**)(void))(*(_DWORD *)v137 + 16))();
        v140 = CommandLine_Tier0(v138, v139);
        v141 = (*(int (**)(void))(*(_DWORD *)v140 + 16))();
        v143 = CommandLine_Tier0(v141, v142);
        v144 = (*(int (**)(void))(*(_DWORD *)v143 + 16))();
        v146 = CommandLine_Tier0(v144, v145);
        v147 = (*(int (**)(void))(*(_DWORD *)v146 + 16))();
        v149 = CommandLine_Tier0(v147, v148);
        v150 = (*(int (**)(void))(*(_DWORD *)v149 + 16))();
        v152 = CommandLine_Tier0(v150, v151);
        (*(void (**)(void))(*(_DWORD *)v152 + 16))();
        goto LABEL_22;
      }
    }
    else if ( v59 == 4 )
    {
      goto LABEL_77;
    }
    v60 = (*(int (**)(void))(**(_DWORD **)v165[177] + 16))();
    v166 = v60;
    if ( !v60 )
      goto LABEL_78;
LABEL_22:
    v62 = v165[190];
    v168 = &word_29074;
    v63 = &dword_2A5EC;
    v167 = v62;
    v64 = *((_WORD *)v48 + 30);
    v65 = dword_2A5EC;
    *v48 = v62 + 8;
    v66 = v48;
    v67 = v23;
    v170 = &word_29074;
    v169 = &word_29074;
    v68 = v66;
    while ( 1 )
    {
      if ( !(v65 & 1) && _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v69 = (_DWORD *)(&loc_FFFE + 1);
      if ( v64 == 0xFFFF )
        v70 = v168;
      else
        v70 = (__int16 *)v68[12];
      if ( v64 != 0xFFFF )
        v70 += 8 * v64;
      if ( (unsigned __int16)*v70 == 0xFFFF )
        break;
      v65 = dword_2A5EC;
      if ( !(dword_2A5EC & 1) )
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          v115 = v170;
          *v170 = -1;
          v115[1] = -1;
          v115[2] = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v65 = dword_2A5EC;
      }
      if ( v64 == 0xFFFF )
        v71 = v169;
      else
        v71 = (__int16 *)v68[12];
      if ( v64 != 0xFFFF )
        v71 += 8 * v64;
      v64 = (unsigned __int16)*v71;
    }
    v72 = v68;
    if ( v64 != 0xFFFF )
      v63 = (_DWORD *)(&loc_FFFE + 1);
    v23 = v67;
    if ( v64 != 0xFFFF )
      v69 = &v179;
    v48 = v72;
    if ( v64 == 0xFFFF )
    {
      v69 = &v179;
    }
    else
    {
      do
      {
        free(*(void **)(v48[12] + 16 * v64 + 8));
        v64 = sub_93F0((int)v69, v64);
      }
      while ( (int *)v64 != v63 );
    }
    sub_8244((int)v69);
    sub_8244((int)v69);
    *((_WORD *)v48 + 32) = -1;
    sub_821C((int)&v180, v73, v74, v75);
    *((_WORD *)v48 + 33) = -1;
    sub_821C((int)&v180, v76, v77, v78);
    v48[9] = 0;
    v168 = &word_29074;
    sub_81F4((int)&v178, v79, v80, (int)&word_29074);
    v81 = v48[6];
    v48[10] = v81;
    v170 = &word_29074;
    sub_81F4((int)&v178, v82, v83, v81);
    v48[4] = 0;
    v158 = &v177;
    v169 = &word_29074;
    sub_81CC((int)&v177, (int)&word_29074, v84, (int)&v177);
    v85 = (int)v158;
    v86 = v48[1];
    v87 = (int)v158;
    v48[5] = v86;
    sub_81CC(v87, v88, v86, v85);
    v89 = *((_WORD *)v23 + 30);
    *v23 = (void **)(v167 + 8);
    v90 = dword_2A5EC;
    while ( 1 )
    {
      if ( !(v90 & 1) && _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      if ( v89 == 0xFFFF )
        v91 = v168;
      else
        v91 = (__int16 *)v23[12];
      if ( v89 != 0xFFFF )
        v91 += 8 * v89;
      if ( (unsigned __int16)*v91 == 0xFFFF )
        break;
      v90 = dword_2A5EC;
      if ( !(dword_2A5EC & 1) )
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          v114 = v170;
          *v170 = -1;
          v114[1] = -1;
          v114[2] = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v90 = dword_2A5EC;
      }
      if ( v89 == 0xFFFF )
        v92 = v169;
      else
        v92 = (__int16 *)v23[12];
      if ( v89 != 0xFFFF )
        v92 += 8 * v89;
      v89 = (unsigned __int16)*v92;
    }
    if ( v89 == 0xFFFF )
    {
      v93 = &v184;
    }
    else
    {
      v93 = &v184;
      do
      {
        free(v23[12][4 * v89 + 2]);
        v89 = sub_93F0((int)&v184, v89);
      }
      while ( v89 != 0xFFFF );
    }
    sub_8244((int)v93);
    sub_8244((int)v93);
    *((_WORD *)v23 + 32) = -1;
    sub_821C((int)&v185, v94, v95, v96);
    *((_WORD *)v23 + 33) = -1;
    sub_821C((int)&v185, v97, v98, v99);
    v23[9] = 0;
    sub_81F4((int)&v183, v100, v101, v102);
    v103 = (int)v23[6];
    v23[10] = (void **)v103;
    sub_81F4((int)&v183, v104, v105, v103);
    v23[4] = 0;
    sub_81CC((int)&v182, v106, v107, v108);
    v109 = (int)v23[1];
    v23[5] = (void **)v109;
    sub_81CC((int)&v182, v110, v111, v109);
  }
  while ( v166 );
  sub_6E38();
  v112 = stat("/tmp/hl2_relaunch", (struct stat *)&v175);
  if ( v112 || (v153 = fopen("/tmp/hl2_relaunch", "r")) == 0 )
  {
    v112 = 0;
  }
  else
  {
    v154 = fread(v48, 1u, 0x100u, v153);
    v155 = v154;
    if ( (signed int)v154 > 0 )
    {
      if ( v154 >= 0xFF )
        v155 = 255;
      *((_BYTE *)v48 + v155) = v166;
      sub_12440((char *)v23, 0x104u, "xdg-open \"%s\"", v48);
      system((const char *)v23);
    }
    fclose(v153);
    unlink("/tmp/hl2_relaunch");
  }
  return v112;
}
// 3BE0: invalid function type has been ignored
// 7764: could not find valid save-restore pair for r4
// 7764: could not find valid save-restore pair for r5
// 7764: could not find valid save-restore pair for r6
// 7764: could not find valid save-restore pair for r7
// 7764: could not find valid save-restore pair for r8
// 7764: could not find valid save-restore pair for r9
// 7764: could not find valid save-restore pair for r10
// 7764: could not find valid save-restore pair for r11
// 7764: variables would overlap: r5.4 and r5.8
// 7764: variables would overlap: r6.4 and r5.8
// 7764: variables would overlap: r7.4 and r7.8
// 7764: variables would overlap: r8.4 and r7.8
// 7764: variables would overlap: r9.4 and r9.8
// 7764: variables would overlap: r10.4 and r9.8
// 33A4: using guessed type int __fastcall Plat_VerifyHardwareKeyPrompt(_DWORD);
// 34F0: using guessed type int __fastcall Plat_SetCommandLine(_DWORD);
// 365C: using guessed type int Warning(const char *, ...);
// 369C: using guessed type int __fastcall SpewOutputFunc(_DWORD);
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 3918: using guessed type int __fastcall BuildCmdLine(_DWORD, _DWORD, _DWORD);
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 6C04: using guessed type int sub_6C04();
// 285D0: using guessed type void *;
// 28CF0: using guessed type int GLOBAL_OFFSET_TABLE_;
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 29248: using guessed type int dword_29248;
// 29358: using guessed type char byte_29358;
// 2A5AC: using guessed type char byte_2A5AC;
// 2A5B4: using guessed type char byte_2A5B4;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00007F58) --------------------------------------------------------
int sub_7F58()
{
  return 0;
}

//----- (00007F68) --------------------------------------------------------
int __fastcall sub_7F68(int result)
{
  *(_BYTE *)(result + 4) = 1;
  return result;
}

//----- (00007F7C) --------------------------------------------------------
int __fastcall sub_7F7C(int a1, int a2)
{
  __int64 v2; // r4@0
  int v3; // lr@0
  int v4; // r5@1
  int v5; // r0@1
  int v6; // r0@1
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = v2;
  v4 = a2;
  v9 = &v8;
  v10 = v3;
  v5 = (*(int (__fastcall **)(_DWORD))(g_pVCR + 16))(0);
  v6 = GetAssertDialogParent(v5);
  SDL_ShowSimpleMessageBox(0, "VCR Error", v4, v6);
  return (*(int (__fastcall **)(signed int))(g_pVCR + 16))(1);
}
// 7F7C: could not find valid save-restore pair for r4
// 7F7C: could not find valid save-restore pair for r5
// 7F7C: could not find valid save-restore pair for r7
// 3610: using guessed type int __fastcall SDL_ShowSimpleMessageBox(_DWORD, _DWORD, _DWORD, _DWORD);
// 3AC8: using guessed type int __fastcall GetAssertDialogParent(_DWORD);

//----- (00007FBC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_7FBC(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 7FBC: could not find valid save-restore pair for r4
// 7FBC: could not find valid save-restore pair for r7
// 7FBC: variables would overlap: r3.4 and r3.8
// 7FBC: variables would overlap: r4.4 and r3.8

//----- (00007FE4) --------------------------------------------------------
void __fastcall sub_7FE4(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r2@1
  unsigned int v4; // r3@2
  int v5; // r10@3
  unsigned int v6; // r4@3
  int v12; // r3@10
  int v13; // r2@10

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 28);
  if ( v3 != -1 )
  {
    v4 = *(_DWORD *)(a1 + 8);
    if ( v4 )
    {
      v5 = 0;
      v6 = 0;
      while ( 1 )
      {
        if ( v6 >= v4 )
          goto LABEL_13;
        if ( (signed int)v6 <= v3 )
          break;
LABEL_6:
        if ( ++v6 < v4 )
        {
          a2 = v6 + 1;
          v5 += 32;
          if ( v6 != -1 )
            continue;
        }
        goto LABEL_8;
      }
      if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      v12 = *(_DWORD *)(v2 + 4);
      v13 = *(_DWORD *)(v12 + v5);
      if ( v6 == v13 )
      {
        v3 = *(_DWORD *)(v2 + 28);
      }
      else
      {
        sub_7FBC(v12 + v5 + 16, a2, v13, v12);
        *(_DWORD *)(*(_DWORD *)(v2 + 4) + v5 + 4) = *(_DWORD *)(v2 + 24);
        *(_DWORD *)(*(_DWORD *)(v2 + 4) + v5) = v6;
        v3 = *(_DWORD *)(v2 + 28);
        *(_DWORD *)(v2 + 24) = v6;
      }
LABEL_13:
      if ( v6 == v3 )
        goto LABEL_8;
      v4 = *(_DWORD *)(v2 + 8);
      goto LABEL_6;
    }
LABEL_8:
    __asm { VMOV.I64        D16, #0xFFFFFFFF }
    _R5 = v2 + 16;
    __asm { VST1.32         {D16}, [R5] }
  }
}
// 7FE4: could not find valid save-restore pair for r4
// 7FE4: could not find valid save-restore pair for r5
// 7FE4: could not find valid save-restore pair for r6
// 7FE4: could not find valid save-restore pair for r7
// 7FE4: could not find valid save-restore pair for r8
// 7FE4: could not find valid save-restore pair for r9
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29080: using guessed type int dword_29080;
// 29084: using guessed type int dword_29084;
// 2A5F0: using guessed type int dword_2A5F0;

//----- (000080A0) --------------------------------------------------------
int __fastcall sub_80A0(int a1, int a2, int a3, int a4)
{
  int v4; // r4@0
  __int64 v5; // r5@0
  int v6; // r7@0
  int v7; // lr@0
  int v8; // r4@1
  const char *v9; // r2@1
  int v10; // r0@1
  char v12; // [sp+8h] [bp+0h]@1
  int *v13; // [sp+10h] [bp+8h]@1
  int v14; // [sp+18h] [bp+10h]@1
  __int64 v15; // [sp+1Ch] [bp+14h]@1
  int v16; // [sp+24h] [bp+1Ch]@1
  int v17; // [sp+28h] [bp+20h]@1
  const char *varg_r1; // [sp+2Ch] [bp+24h]@1
  int varg_r2; // [sp+30h] [bp+28h]@1
  int varg_r3; // [sp+34h] [bp+2Ch]@1

  varg_r1 = (const char *)a2;
  varg_r2 = a3;
  varg_r3 = a4;
  v16 = v6;
  v17 = v7;
  v15 = v5;
  v14 = v4;
  v8 = a1;
  *(_BYTE *)(a1 + 4) = 1;
  v9 = varg_r1;
  v12 = 0;
  *(_DWORD *)a1 = &off_285C0;
  v13 = &varg_r2;
  v10 = sub_124C8((char *)(a1 + 5), 0x100u, v9, &varg_r2, &v12);
  if ( v12 && !*(_BYTE *)(v8 + 4) && (unsigned int)dword_2A5E8 <= 4 )
    ++dword_2A5E8;
  *(_DWORD *)(v8 + 264) = v10;
  return v8;
}
// 80A0: could not find valid save-restore pair for r4
// 80A0: could not find valid save-restore pair for r5
// 80A0: could not find valid save-restore pair for r6
// 80A0: could not find valid save-restore pair for r7
// 285C0: using guessed type void *;
// 2A5E8: using guessed type int dword_2A5E8;

//----- (0000811C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_811C(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 811C: could not find valid save-restore pair for r4
// 811C: could not find valid save-restore pair for r7
// 811C: variables would overlap: r3.4 and r3.8
// 811C: variables would overlap: r4.4 and r3.8

//----- (00008144) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_8144(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r4@1
  int v9; // r6@1
  int v10; // r1@1
  int v11; // r2@1
  int v12; // r3@1
  int v13; // r1@1
  int v14; // r2@1
  int v15; // r3@1
  __int64 v17; // [sp+0h] [bp+0h]@1
  __int64 v18; // [sp+8h] [bp+8h]@1
  __int64 *v19; // [sp+10h] [bp+10h]@1
  int v20; // [sp+14h] [bp+14h]@1

  v17 = *(_QWORD *)&a4;
  v8 = a1;
  v18 = *(_QWORD *)&v5;
  v9 = a1 + 4;
  v19 = &v17;
  v20 = v7;
  sub_7FE4(a1, a2);
  *(_DWORD *)(v8 + 24) = -1;
  sub_811C(v9, v10, v11, v12);
  *(_DWORD *)(v8 + 28) = -1;
  sub_811C(v9, v13, v14, v15);
  return v8;
}
// 8144: could not find valid save-restore pair for r4
// 8144: could not find valid save-restore pair for r5
// 8144: could not find valid save-restore pair for r6
// 8144: could not find valid save-restore pair for r7
// 8144: variables would overlap: r3.4 and r3.8
// 8144: variables would overlap: r4.4 and r3.8
// 8144: variables would overlap: r5.4 and r5.8
// 8144: variables would overlap: r6.4 and r5.8

//----- (000081CC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_81CC(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 81CC: could not find valid save-restore pair for r4
// 81CC: could not find valid save-restore pair for r7
// 81CC: variables would overlap: r3.4 and r3.8
// 81CC: variables would overlap: r4.4 and r3.8

//----- (000081F4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_81F4(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 81F4: could not find valid save-restore pair for r4
// 81F4: could not find valid save-restore pair for r7
// 81F4: variables would overlap: r3.4 and r3.8
// 81F4: variables would overlap: r4.4 and r3.8

//----- (0000821C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_821C(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 821C: could not find valid save-restore pair for r4
// 821C: could not find valid save-restore pair for r7
// 821C: variables would overlap: r3.4 and r3.8
// 821C: variables would overlap: r4.4 and r3.8

//----- (00008244) --------------------------------------------------------
int __fastcall sub_8244(int result)
{
  int v1; // r5@1
  unsigned int v2; // r2@1
  unsigned int v3; // r3@2
  unsigned int v4; // r4@3
  int v5; // r1@10
  int v6; // r3@10
  int v7; // r1@10
  bool v8; // zf@10

  v1 = result;
  v2 = *(_WORD *)(result + 22);
  if ( v2 != 0xFFFF )
  {
    v3 = *(_DWORD *)(result + 8);
    if ( v3 )
    {
      v4 = 0;
      while ( 1 )
      {
        if ( v4 >= v3 )
          goto LABEL_15;
        if ( v4 <= v2 )
          break;
LABEL_6:
        v4 = (unsigned __int16)(v4 + 1);
        if ( v4 >= v3 || v4 == 0xFFFF )
          goto LABEL_8;
      }
      if ( !(dword_2A5EC & 1) )
      {
        result = _cxa_guard_acquire(&dword_2A5EC);
        if ( result )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          result = _cxa_guard_release(&dword_2A5EC);
        }
      }
      v5 = *(_DWORD *)(v1 + 4);
      v2 = 16 * v4;
      v6 = *(_WORD *)(v5 + 16 * v4);
      v7 = v5 + 16 * v4;
      v8 = v6 == v4;
      if ( v6 == v4 )
        v2 = *(_WORD *)(v1 + 22);
      else
        LOWORD(v6) = *(_WORD *)(v1 + 20);
      if ( !v8 )
      {
        *(_WORD *)(v7 + 2) = v6;
        *(_WORD *)(*(_DWORD *)(v1 + 4) + v2) = v4;
        v2 = *(_WORD *)(v1 + 22);
        *(_WORD *)(v1 + 20) = v4;
      }
LABEL_15:
      if ( v4 == v2 )
        goto LABEL_8;
      v3 = *(_DWORD *)(v1 + 8);
      goto LABEL_6;
    }
LABEL_8:
    *(_WORD *)(v1 + 16) = -1;
    *(_WORD *)(v1 + 18) = 0;
  }
  return result;
}
// 8244: could not find valid save-restore pair for r4
// 8244: could not find valid save-restore pair for r5
// 8244: could not find valid save-restore pair for r6
// 8244: could not find valid save-restore pair for r7
// 8244: could not find valid save-restore pair for r8
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (000082F0) --------------------------------------------------------
int __fastcall sub_82F0(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r4@1
  int v4; // r3@2
  int v5; // r8@5
  int v6; // r1@5
  int v7; // r6@5
  int v8; // r3@6
  int v9; // r9@7
  int *v10; // r2@7
  int *v11; // r3@11
  int v12; // r3@14
  int *v13; // r2@15
  int result; // r0@18
  int v15; // r3@20
  int *v16; // r2@21
  int v17; // r2@27
  int v18; // r10@30
  int v19; // r2@31
  int *v20; // r10@32
  int v21; // r3@35
  int *v22; // r2@35
  int v23; // r3@51
  int *v24; // r2@52

  v2 = a2;
  v3 = a1;
  if ( dword_2A5F0 << 31 < 0 )
  {
    v4 = 1;
    if ( a2 != -1 )
      goto LABEL_5;
LABEL_44:
    v5 = -32;
    v6 = 1;
    v7 = dword_29080;
    if ( v4 )
      goto LABEL_6;
    goto LABEL_45;
  }
  if ( _cxa_guard_acquire(&dword_2A5F0) )
  {
    dword_2907C = -1;
    dword_29080 = -1;
    dword_29084 = -1;
    _cxa_guard_release(&dword_2A5F0);
  }
  v4 = dword_2A5F0 & 1;
  if ( v2 == -1 )
    goto LABEL_44;
LABEL_5:
  v5 = 32 * v2;
  v6 = 1;
  v7 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + 32 * v2 + 4);
  if ( v4 )
    goto LABEL_6;
LABEL_45:
  if ( _cxa_guard_acquire(&dword_2A5F0) )
  {
    dword_2907C = -1;
    dword_29080 = -1;
    dword_29084 = -1;
    _cxa_guard_release(&dword_2A5F0);
  }
  v6 = dword_2A5F0 & 1;
LABEL_6:
  v8 = *(_DWORD *)(v3 + 4);
  if ( v7 == -1 )
  {
    v9 = -32;
    v10 = &dword_2907C;
  }
  else
  {
    v9 = 32 * v7;
    v10 = (int *)(v8 + 32 * v7);
  }
  *(_DWORD *)(v8 + v5 + 4) = *v10;
  if ( !v6 && _cxa_guard_acquire(&dword_2A5F0) )
  {
    dword_2907C = -1;
    dword_29080 = -1;
    dword_29084 = -1;
    _cxa_guard_release(&dword_2A5F0);
  }
  if ( v7 == -1 )
    v11 = &dword_2907C;
  else
    v11 = (int *)(*(_DWORD *)(v3 + 4) + v9);
  if ( *v11 != -1 )
  {
    if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    v12 = *(_DWORD *)(v3 + 4);
    if ( v7 == -1 )
      v13 = &dword_2907C;
    else
      v13 = (int *)(v12 + v9);
    *(_DWORD *)(v12 + 32 * *v13 + 8) = v2;
  }
  result = v7 + 1;
  if ( v7 != -1 )
  {
    if ( !(dword_2A5F0 & 1) )
    {
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
    }
    v15 = *(_DWORD *)(v3 + 4);
    if ( v2 == -1 )
      v16 = &dword_2907C;
    else
      v16 = (int *)(v15 + v5);
    *(_DWORD *)(v15 + v9 + 8) = v16[2];
  }
  if ( v2 == *(_DWORD *)(v3 + 16) )
  {
    *(_DWORD *)(v3 + 16) = v7;
    goto LABEL_38;
  }
  if ( dword_2A5F0 << 31 >= 0 )
  {
    if ( _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    result = v2 + 1;
    v17 = dword_2A5F0 & 1;
    if ( v2 != -1 )
    {
LABEL_30:
      v18 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + v5 + 8);
      if ( v17 )
        goto LABEL_31;
LABEL_64:
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
      v19 = dword_2A5F0 & 1;
      if ( v18 != -1 )
        goto LABEL_32;
      goto LABEL_67;
    }
  }
  else
  {
    v17 = 1;
    result = v2 + 1;
    if ( v2 != -1 )
      goto LABEL_30;
  }
  v18 = dword_29084;
  if ( !v17 )
    goto LABEL_64;
LABEL_31:
  v19 = 1;
  if ( v18 != -1 )
  {
LABEL_32:
    v20 = (int *)(*(_DWORD *)(v3 + 4) + 32 * v18);
    goto LABEL_33;
  }
LABEL_67:
  v20 = &dword_2907C;
LABEL_33:
  if ( v2 == *v20 )
  {
    if ( !v19 )
    {
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
    }
    v21 = *(_DWORD *)(v3 + 4);
    v22 = &dword_2907C;
    if ( v2 != -1 )
      v22 = (int *)(v21 + v5);
    *(_DWORD *)(v21 + 32 * v22[2]) = v7;
  }
  else
  {
    if ( !v19 )
    {
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
    }
    v23 = *(_DWORD *)(v3 + 4);
    if ( v2 == -1 )
      v24 = &dword_2907C;
    else
      v24 = (int *)(v23 + v5);
    *(_DWORD *)(v23 + 32 * v24[2] + 4) = v7;
  }
LABEL_38:
  *(_DWORD *)(*(_DWORD *)(v3 + 4) + v9) = v2;
  if ( v2 != -1 )
    *(_DWORD *)(v5 + *(_DWORD *)(v3 + 4) + 8) = v7;
  return result;
}
// 82F0: could not find valid save-restore pair for r4
// 82F0: could not find valid save-restore pair for r5
// 82F0: could not find valid save-restore pair for r6
// 82F0: could not find valid save-restore pair for r7
// 82F0: could not find valid save-restore pair for r8
// 82F0: could not find valid save-restore pair for r9
// 82F0: could not find valid save-restore pair for r10
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29080: using guessed type int dword_29080;
// 29084: using guessed type int dword_29084;
// 2A5F0: using guessed type int dword_2A5F0;

//----- (0000867C) --------------------------------------------------------
int __fastcall sub_867C(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r4@1
  int v4; // r3@2
  int v5; // r8@5
  int v6; // r6@5
  int v7; // r3@6
  int v8; // r9@7
  int *v9; // r2@7
  int *v10; // r3@11
  int v11; // r3@14
  int *v12; // r2@15
  int result; // r0@18
  int v14; // r3@20
  int *v15; // r2@21
  int v16; // r2@27
  int v17; // r10@30
  int v18; // r2@31
  int *v19; // r10@32
  int v20; // r3@35
  int *v21; // r2@35
  int v22; // r3@50
  int *v23; // r2@51

  v2 = a2;
  v3 = a1;
  if ( dword_2A5F0 << 31 < 0 )
  {
    v4 = 1;
    if ( a2 != -1 )
      goto LABEL_5;
LABEL_44:
    v5 = -32;
    v6 = dword_2907C;
    if ( v4 )
      goto LABEL_6;
    goto LABEL_45;
  }
  if ( _cxa_guard_acquire(&dword_2A5F0) )
  {
    dword_2907C = -1;
    dword_29080 = -1;
    dword_29084 = -1;
    _cxa_guard_release(&dword_2A5F0);
  }
  v4 = dword_2A5F0 & 1;
  if ( v2 == -1 )
    goto LABEL_44;
LABEL_5:
  v5 = 32 * v2;
  v6 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + 32 * v2);
  if ( v4 )
    goto LABEL_6;
LABEL_45:
  if ( _cxa_guard_acquire(&dword_2A5F0) )
  {
    dword_2907C = -1;
    dword_29080 = -1;
    dword_29084 = -1;
    _cxa_guard_release(&dword_2A5F0);
  }
LABEL_6:
  v7 = *(_DWORD *)(v3 + 4);
  if ( v6 == -1 )
  {
    v8 = -32;
    v9 = &dword_2907C;
  }
  else
  {
    v8 = 32 * v6;
    v9 = (int *)(v7 + 32 * v6);
  }
  *(_DWORD *)(v7 + v5) = v9[1];
  if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
  {
    dword_2907C = -1;
    dword_29080 = -1;
    dword_29084 = -1;
    _cxa_guard_release(&dword_2A5F0);
  }
  if ( v6 == -1 )
    v10 = &dword_2907C;
  else
    v10 = (int *)(*(_DWORD *)(v3 + 4) + v8);
  if ( v10[1] != -1 )
  {
    if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    v11 = *(_DWORD *)(v3 + 4);
    if ( v6 == -1 )
      v12 = &dword_2907C;
    else
      v12 = (int *)(v11 + v8);
    *(_DWORD *)(v11 + 32 * v12[1] + 8) = v2;
  }
  result = v6 + 1;
  if ( v6 != -1 )
  {
    if ( !(dword_2A5F0 & 1) )
    {
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
    }
    v14 = *(_DWORD *)(v3 + 4);
    if ( v2 == -1 )
      v15 = &dword_2907C;
    else
      v15 = (int *)(v14 + v5);
    *(_DWORD *)(v14 + v8 + 8) = v15[2];
  }
  if ( v2 == *(_DWORD *)(v3 + 16) )
  {
    *(_DWORD *)(v3 + 16) = v6;
    goto LABEL_38;
  }
  if ( dword_2A5F0 << 31 >= 0 )
  {
    if ( _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    result = v2 + 1;
    v16 = dword_2A5F0 & 1;
    if ( v2 != -1 )
    {
LABEL_30:
      v17 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + v5 + 8);
      if ( v16 )
        goto LABEL_31;
LABEL_63:
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
      v18 = dword_2A5F0 & 1;
      if ( v17 != -1 )
        goto LABEL_32;
      goto LABEL_66;
    }
  }
  else
  {
    v16 = 1;
    result = v2 + 1;
    if ( v2 != -1 )
      goto LABEL_30;
  }
  v17 = dword_29084;
  if ( !v16 )
    goto LABEL_63;
LABEL_31:
  v18 = 1;
  if ( v17 != -1 )
  {
LABEL_32:
    v19 = (int *)(*(_DWORD *)(v3 + 4) + 32 * v17);
    goto LABEL_33;
  }
LABEL_66:
  v19 = &dword_2907C;
LABEL_33:
  if ( v2 == v19[1] )
  {
    if ( !v18 )
    {
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
    }
    v20 = *(_DWORD *)(v3 + 4);
    v21 = &dword_2907C;
    if ( v2 != -1 )
      v21 = (int *)(v20 + v5);
    *(_DWORD *)(v20 + 32 * v21[2] + 4) = v6;
  }
  else
  {
    if ( !v18 )
    {
      result = _cxa_guard_acquire(&dword_2A5F0);
      if ( result )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        result = _cxa_guard_release(&dword_2A5F0);
      }
    }
    v22 = *(_DWORD *)(v3 + 4);
    if ( v2 == -1 )
      v23 = &dword_2907C;
    else
      v23 = (int *)(v22 + v5);
    *(_DWORD *)(v22 + 32 * v23[2]) = v6;
  }
LABEL_38:
  *(_DWORD *)(*(_DWORD *)(v3 + 4) + v8 + 4) = v2;
  if ( v2 != -1 )
    *(_DWORD *)(v5 + *(_DWORD *)(v3 + 4) + 8) = v6;
  return result;
}
// 867C: could not find valid save-restore pair for r4
// 867C: could not find valid save-restore pair for r5
// 867C: could not find valid save-restore pair for r6
// 867C: could not find valid save-restore pair for r7
// 867C: could not find valid save-restore pair for r8
// 867C: could not find valid save-restore pair for r9
// 867C: could not find valid save-restore pair for r10
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29080: using guessed type int dword_29080;
// 29084: using guessed type int dword_29084;
// 2A5F0: using guessed type int dword_2A5F0;

//----- (00008A00) --------------------------------------------------------
void __fastcall sub_8A00(int a1, int a2)
{
  int v2; // r5@0
  int v3; // r6@1
  int v4; // r4@1
  int v5; // r3@2
  int v6; // r2@4
  int *v7; // r3@7
  int v8; // r5@11
  bool v9; // zf@12
  int v10; // r2@21
  int v11; // r5@24
  int v12; // r3@24
  int *v13; // r2@26
  int v14; // r9@27
  int v15; // r3@28
  int *v16; // r2@29
  int v17; // r10@30
  int v18; // r2@30
  int *v19; // r3@32
  int v20; // r3@34
  int *v21; // r2@36
  int v22; // r10@37
  int *v23; // r3@39
  int v24; // r2@40
  int v25; // r3@42
  int *v26; // r3@46
  int v27; // r3@49
  int v28; // r10@52
  int *v29; // r10@54
  int v30; // r3@56
  int v31; // r3@87
  int v32; // r10@90
  int v33; // r3@93
  int v34; // r3@103
  int *v35; // r2@106
  int v36; // r6@107
  int v37; // r3@108
  int *v38; // r2@109
  int v39; // r3@127
  int *v40; // r2@130
  int v41; // r6@131
  int v42; // r3@132
  int *v43; // r2@133
  int v44; // [sp+20h] [bp+20h]@1

  v44 = v2;
  v3 = a2;
  v4 = a1;
  while ( 1 )
  {
    v5 = *(_DWORD *)(v4 + 16);
    if ( v3 == v5 )
      goto LABEL_19;
    if ( dword_2A5F0 << 31 >= 0 )
    {
      if ( _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      v6 = dword_2A5F0 & 1;
    }
    else
    {
      v6 = 1;
    }
    if ( v3 == -1 )
      v7 = &dword_2907C;
    else
      v7 = *(int **)(v4 + 4);
    if ( v3 != -1 )
      v7 += 8 * v3;
    v8 = v7[2];
    if ( !v6 && _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    v9 = v8 == -1;
    if ( v8 == -1 )
      v8 = (int)&dword_2907C;
    else
      v7 = *(int **)(v4 + 4);
    if ( !v9 )
      v8 = (int)&v7[8 * v8];
    if ( *(_DWORD *)(v8 + 12) )
    {
      v5 = *(_DWORD *)(v4 + 16);
LABEL_19:
      *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v5 + 12) = 1;
      JUMPOUT(__CS__, v44);
    }
    if ( dword_2A5F0 << 31 >= 0 )
    {
      if ( _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      v10 = dword_2A5F0 & 1;
      if ( v3 != -1 )
      {
LABEL_24:
        v11 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v3 + 8);
        v12 = 1;
        if ( v10 )
          goto LABEL_25;
        goto LABEL_70;
      }
    }
    else
    {
      v10 = 1;
      if ( v3 != -1 )
        goto LABEL_24;
    }
    v11 = dword_29084;
    v12 = 1;
    if ( v10 )
    {
LABEL_25:
      if ( v11 != -1 )
        goto LABEL_26;
      goto LABEL_73;
    }
LABEL_70:
    if ( _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    v12 = dword_2A5F0 & 1;
    if ( v11 != -1 )
    {
LABEL_26:
      v13 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v11);
      goto LABEL_27;
    }
LABEL_73:
    v13 = &dword_2907C;
LABEL_27:
    v14 = v13[2];
    if ( v12 )
    {
      v15 = 1;
      if ( v11 != -1 )
        goto LABEL_29;
    }
    else
    {
      if ( _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      v15 = dword_2A5F0 & 1;
      if ( v11 != -1 )
      {
LABEL_29:
        v16 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v11);
        goto LABEL_30;
      }
    }
    v16 = &dword_2907C;
LABEL_30:
    v17 = v16[2];
    v18 = 1;
    if ( v15 )
    {
      if ( v17 == -1 )
        goto LABEL_61;
    }
    else
    {
      if ( _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      v18 = dword_2A5F0 & 1;
      if ( v17 == -1 )
      {
LABEL_61:
        v19 = &dword_2907C;
        goto LABEL_33;
      }
    }
    v19 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v17);
LABEL_33:
    if ( v11 == *v19 )
    {
      v20 = 1;
      if ( v18 )
      {
        if ( v14 == -1 )
          goto LABEL_101;
      }
      else
      {
        if ( _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v20 = dword_2A5F0 & 1;
        if ( v14 == -1 )
        {
LABEL_101:
          v21 = &dword_2907C;
          goto LABEL_37;
        }
      }
      v21 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v14);
LABEL_37:
      v22 = v21[1];
      if ( v20 || !_cxa_guard_acquire(&dword_2A5F0) )
      {
        if ( v22 != -1 )
          goto LABEL_39;
      }
      else
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
        if ( v22 != -1 )
        {
LABEL_39:
          v23 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v22);
          goto LABEL_40;
        }
      }
      v23 = &dword_2907C;
LABEL_40:
      v24 = v23[3];
      if ( !v24 )
        goto LABEL_41;
      if ( dword_2A5F0 << 31 >= 0 )
      {
        if ( _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v31 = dword_2A5F0 & 1;
        if ( v3 != -1 )
        {
LABEL_90:
          v32 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v3 + 8);
          if ( v31 )
            goto LABEL_91;
          goto LABEL_123;
        }
      }
      else
      {
        v31 = 1;
        if ( v3 != -1 )
          goto LABEL_90;
      }
      v32 = dword_29084;
      if ( v31 )
        goto LABEL_91;
LABEL_123:
      if ( !_cxa_guard_acquire(&dword_2A5F0) )
      {
LABEL_91:
        if ( v32 != -1 )
          goto LABEL_92;
        goto LABEL_125;
      }
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
      if ( v32 != -1 )
      {
LABEL_92:
        if ( v3 != *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v32 + 4) )
          goto LABEL_93;
        goto LABEL_126;
      }
LABEL_125:
      if ( v3 != dword_29080 )
      {
LABEL_93:
        v33 = *(_DWORD *)(v4 + 4) + 32 * v11;
        goto LABEL_94;
      }
LABEL_126:
      sub_82F0(v4, v11);
      if ( dword_2A5F0 << 31 >= 0 )
      {
        if ( _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v39 = dword_2A5F0 & 1;
      }
      else
      {
        v39 = 1;
      }
      if ( v11 == -1 )
        v40 = &dword_2907C;
      else
        v40 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v11);
      v41 = v40[2];
      if ( !v39 && _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      v42 = *(_DWORD *)(v4 + 4);
      if ( v41 == -1 )
      {
        v33 = v42 - 32;
        v43 = &dword_2907C;
      }
      else
      {
        v33 = v42 + 32 * v41;
        v43 = (int *)v33;
      }
      v14 = v43[2];
      v3 = v11;
LABEL_94:
      *(_DWORD *)(v33 + 12) = 1;
      *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v14 + 12) = 0;
      sub_867C(v4, v14);
    }
    else
    {
      v25 = 1;
      if ( v18 )
      {
        if ( v14 != -1 )
          goto LABEL_44;
      }
      else
      {
        if ( _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v25 = dword_2A5F0 & 1;
        if ( v14 != -1 )
        {
LABEL_44:
          v22 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v14);
          if ( v25 )
            goto LABEL_45;
          goto LABEL_83;
        }
      }
      v22 = dword_2907C;
      if ( v25 )
        goto LABEL_45;
LABEL_83:
      if ( !_cxa_guard_acquire(&dword_2A5F0) )
      {
LABEL_45:
        if ( v22 == -1 )
          goto LABEL_85;
        goto LABEL_46;
      }
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
      if ( v22 == -1 )
      {
LABEL_85:
        v26 = &dword_2907C;
        goto LABEL_47;
      }
LABEL_46:
      v26 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v22);
LABEL_47:
      v24 = v26[3];
      if ( v24 )
      {
        if ( dword_2A5F0 << 31 >= 0 )
        {
          if ( _cxa_guard_acquire(&dword_2A5F0) )
          {
            dword_2907C = -1;
            dword_29080 = -1;
            dword_29084 = -1;
            _cxa_guard_release(&dword_2A5F0);
          }
          v27 = dword_2A5F0 & 1;
          if ( v3 != -1 )
          {
LABEL_52:
            v28 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v3 + 8);
            if ( v27 )
              goto LABEL_53;
            goto LABEL_116;
          }
        }
        else
        {
          v27 = 1;
          if ( v3 != -1 )
            goto LABEL_52;
        }
        v28 = dword_29084;
        if ( v27 )
          goto LABEL_53;
LABEL_116:
        if ( !_cxa_guard_acquire(&dword_2A5F0) )
        {
LABEL_53:
          if ( v28 != -1 )
            goto LABEL_54;
          goto LABEL_118;
        }
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
        if ( v28 != -1 )
        {
LABEL_54:
          v29 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v28);
          goto LABEL_55;
        }
LABEL_118:
        v29 = &dword_2907C;
LABEL_55:
        if ( v3 == *v29 )
        {
          sub_867C(v4, v11);
          if ( dword_2A5F0 << 31 >= 0 )
          {
            if ( _cxa_guard_acquire(&dword_2A5F0) )
            {
              dword_2907C = -1;
              dword_29080 = -1;
              dword_29084 = -1;
              _cxa_guard_release(&dword_2A5F0);
            }
            v34 = dword_2A5F0 & 1;
          }
          else
          {
            v34 = 1;
          }
          if ( v11 == -1 )
            v35 = &dword_2907C;
          else
            v35 = (int *)(*(_DWORD *)(v4 + 4) + 32 * v11);
          v36 = v35[2];
          if ( !v34 && _cxa_guard_acquire(&dword_2A5F0) )
          {
            dword_2907C = -1;
            dword_29080 = -1;
            dword_29084 = -1;
            _cxa_guard_release(&dword_2A5F0);
          }
          v37 = *(_DWORD *)(v4 + 4);
          if ( v36 == -1 )
          {
            v30 = v37 - 32;
            v38 = &dword_2907C;
          }
          else
          {
            v30 = v37 + 32 * v36;
            v38 = (int *)v30;
          }
          v14 = v38[2];
          v3 = v11;
        }
        else
        {
          v30 = *(_DWORD *)(v4 + 4) + 32 * v11;
        }
        *(_DWORD *)(v30 + 12) = 1;
        *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v14 + 12) = 0;
        sub_82F0(v4, v14);
      }
      else
      {
LABEL_41:
        v3 = v14;
        *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v11 + 12) = 1;
        *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v22 + 12) = 1;
        *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32 * v14 + 12) = v24;
      }
    }
  }
}
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29080: using guessed type int dword_29080;
// 29084: using guessed type int dword_29084;
// 2A5F0: using guessed type int dword_2A5F0;

//----- (00009188) --------------------------------------------------------
int __fastcall sub_9188(int a1, int a2)
{
  int v2; // r10@1
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r2@4
  int v6; // r1@4
  int v7; // r11@6
  int v8; // r8@9
  int v9; // r0@10
  unsigned int v10; // r9@10
  int v11; // r6@10
  int v12; // ST04_4@12
  int v13; // r3@17
  int v14; // r2@17
  int v15; // r9@17
  unsigned int v17; // r6@25
  int i; // r1@25
  signed int v19; // r3@28
  int v20; // r0@29
  void *v21; // r0@32
  int v22; // ST04_4@33
  unsigned int v23; // r1@33
  unsigned int v24; // r0@33
  unsigned int v25; // r1@35
  int v26; // ST04_4@38
  int v27; // ST04_4@52

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 16);
  if ( v4 != -1 )
  {
    while ( 1 )
    {
      v7 = 32 * v4;
      if ( (*(int (__fastcall **)(int, int))v2)(v3, *(_DWORD *)(v2 + 4) + 32 * v4 + 16) )
      {
        if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v5 = 1;
        v6 = *(_DWORD *)(*(_DWORD *)(v2 + 4) + v7);
        if ( v6 == -1 )
          goto LABEL_9;
      }
      else
      {
        if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v5 = 0;
        v6 = *(_DWORD *)(*(_DWORD *)(v2 + 4) + v7 + 4);
        if ( v6 == -1 )
          goto LABEL_9;
      }
      v4 = v6;
    }
  }
  v5 = 0;
LABEL_9:
  v8 = *(_DWORD *)(v2 + 24);
  if ( v8 != -1 )
  {
    v9 = *(_DWORD *)(v2 + 4);
    v10 = 32 * v8;
    v11 = v9 + 32 * v8;
    *(_DWORD *)(v2 + 24) = *(_DWORD *)(v11 + 4);
    goto LABEL_11;
  }
  v10 = *(_DWORD *)(v2 + 8);
  v17 = *(_DWORD *)(v2 + 28);
  i = v10;
  if ( v17 >= v10 )
  {
    if ( v10 )
      goto LABEL_40;
    goto LABEL_28;
  }
  if ( v10 <= v17 + 1 )
  {
LABEL_28:
    v19 = *(_DWORD *)(v2 + 12);
    if ( v19 < 0 )
    {
      v24 = *(_DWORD *)(v2 + 8);
      v23 = *(_DWORD *)(v2 + 28);
    }
    else
    {
      v20 = v10 + 1;
      if ( v19 )
      {
        for ( i = v19 + (signed int)v10 / v19 * v19; v20 > i; i = (i + v20) / 2 )
          ;
      }
      else
      {
        if ( !v10 )
          i = 1;
        for ( ; v20 > i; i *= 2 )
          ;
      }
      v21 = *(void **)(v2 + 4);
      *(_DWORD *)(v2 + 8) = i;
      if ( v21 )
      {
        v22 = v5;
        *(_DWORD *)(v2 + 4) = realloc(v21, 32 * i);
        v23 = *(_DWORD *)(v2 + 28);
        v24 = *(_DWORD *)(v2 + 8);
        v5 = v22;
        v17 = *(_DWORD *)(v2 + 28);
        v10 = *(_DWORD *)(v2 + 8);
      }
      else
      {
        v10 = i;
        v27 = v5;
        *(_DWORD *)(v2 + 4) = malloc(32 * i);
        v23 = v17;
        v24 = v10;
        v5 = v27;
      }
    }
    if ( v17 < v10 )
    {
      v25 = v23 + 1;
      if ( v25 < v10 )
      {
        v10 = 32 * v25;
        v8 = v25;
        goto LABEL_41;
      }
      goto LABEL_37;
    }
    if ( !v24 )
    {
LABEL_37:
      v10 = -32;
LABEL_38:
      v26 = v5;
      ((void (__fastcall *)(const char *))Error)("CUtlRBTree overflow!\n");
      v5 = v26;
      goto LABEL_41;
    }
    v8 = v10;
    if ( !v10 )
      goto LABEL_38;
LABEL_40:
    v10 = 0;
    v8 = 0;
    goto LABEL_41;
  }
  v10 = 32 * (v17 + 1);
  v8 = v17 + 1;
LABEL_41:
  v9 = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(v2 + 28) = v8;
  v11 = v9 + v10;
LABEL_11:
  if ( v11 != -16 )
  {
    v12 = v5;
    sub_16E50((_DWORD *)(v11 + 16), v11 + 16, v5);
    v9 = *(_DWORD *)(v2 + 4);
    v5 = v12;
    v11 = v9 + v10;
  }
  *(_DWORD *)(v2 + 32) = v9;
  *(_DWORD *)(v11 + 8) = v4;
  *(_DWORD *)(v11 + 4) = -1;
  *(_DWORD *)v11 = -1;
  *(_DWORD *)(v11 + 12) = 0;
  if ( v4 == -1 )
  {
    *(_DWORD *)(v2 + 16) = v8;
  }
  else if ( v5 )
  {
    *(_DWORD *)(*(_DWORD *)(v2 + 4) + 32 * v4) = v8;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(v2 + 4) + 32 * v4 + 4) = v8;
  }
  sub_8A00(v2, v8);
  v14 = *(_DWORD *)(v2 + 4);
  v15 = v10 + v14;
  ++*(_DWORD *)(v2 + 20);
  if ( v15 != -16 )
    sub_16FA0((_DWORD *)(v15 + 16), v3, v14, v13);
  return v8;
}
// 3BE0: invalid function type has been ignored
// 9188: could not find valid save-restore pair for r4
// 9188: could not find valid save-restore pair for r5
// 9188: could not find valid save-restore pair for r6
// 9188: could not find valid save-restore pair for r7
// 9188: could not find valid save-restore pair for r8
// 9188: could not find valid save-restore pair for r9
// 9188: could not find valid save-restore pair for r10
// 9188: could not find valid save-restore pair for r11
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29080: using guessed type int dword_29080;
// 29084: using guessed type int dword_29084;
// 2A5F0: using guessed type int dword_2A5F0;

//----- (000093F0) --------------------------------------------------------
signed int __fastcall sub_93F0(int a1, unsigned int a2)
{
  unsigned int v2; // r11@1
  int v3; // r4@1
  signed int result; // r0@3
  __int16 *v5; // r3@7
  int v6; // r3@9
  int v7; // r0@10
  __int16 *v8; // r2@13
  __int16 *v9; // r1@17
  int i; // r5@18
  __int16 *v11; // r3@20
  signed int v12; // r2@26
  bool v13; // zf@26
  __int16 *v14; // r2@44
  __int16 *v15; // r3@47
  int v16; // r9@51
  signed int v17; // r2@52
  int v18; // r2@62

  v2 = a2;
  v3 = a1;
  if ( a2 >= *(_DWORD *)(a1 + 8) || *(_WORD *)(a1 + 22) < a2 )
    goto LABEL_3;
  if ( !(dword_2A5EC & 1) && _cxa_guard_acquire(&dword_2A5EC) )
  {
    word_29074 = -1;
    word_29076 = -1;
    word_29078 = -1;
    _cxa_guard_release(&dword_2A5EC);
  }
  v5 = v2 == 0xFFFF ? &word_29074 : *(_DWORD *)(v3 + 4) + 16 * v2;
  if ( (unsigned __int16)*v5 == v2 )
  {
LABEL_3:
    result = 0xFFFF;
  }
  else
  {
    v6 = dword_2A5EC;
    if ( dword_2A5EC << 31 >= 0 )
    {
      if ( _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v6 = dword_2A5EC;
      v7 = dword_2A5EC & 1;
    }
    else
    {
      v7 = 1;
    }
    if ( v2 == 0xFFFF )
      v8 = &word_29074;
    else
      v8 = (__int16 *)(*(_DWORD *)(v3 + 4) + 16 * v2);
    if ( (unsigned __int16)v8[1] == 0xFFFF )
    {
      if ( !v7 )
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v6 = dword_2A5EC;
      }
      if ( v2 == 0xFFFF )
        v14 = &word_29074;
      else
        v14 = (__int16 *)(*(_DWORD *)(v3 + 4) + 16 * v2);
      for ( i = (unsigned __int16)v14[2]; ; i = *(_WORD *)(*(_DWORD *)(v3 + 4) + 16 * i + 4) )
      {
        if ( v6 << 31 >= 0 )
        {
          if ( _cxa_guard_acquire(&dword_2A5EC) )
          {
            word_29074 = -1;
            word_29076 = -1;
            word_29078 = -1;
            _cxa_guard_release(&dword_2A5EC);
          }
          v18 = dword_2A5EC & 1;
        }
        else
        {
          v18 = 1;
        }
        if ( v2 == 0xFFFF )
          v15 = &word_29074;
        else
          v15 = *(__int16 **)(v3 + 4);
        if ( v2 != 0xFFFF )
          v15 += 8 * v2;
        v16 = (unsigned __int16)v15[2];
        if ( !v18 && _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v17 = 0xFFFF;
        if ( v16 == 0xFFFF )
          v15 = &word_29074;
        else
          v17 = *(_DWORD *)(v3 + 4);
        if ( v16 != 0xFFFF )
          v15 = (__int16 *)(v17 + 16 * v16);
        if ( (unsigned __int16)v15[1] != v2 )
          break;
        if ( i == 0xFFFF )
          goto LABEL_3;
        v6 = dword_2A5EC;
        if ( !(dword_2A5EC & 1) )
        {
          if ( _cxa_guard_acquire(&dword_2A5EC) )
          {
            word_29074 = -1;
            word_29076 = -1;
            word_29078 = -1;
            _cxa_guard_release(&dword_2A5EC);
          }
          v6 = dword_2A5EC;
        }
        v2 = i;
      }
    }
    else
    {
      if ( !v7 )
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        LOBYTE(v6) = dword_2A5EC;
      }
      if ( v2 == 0xFFFF )
        v9 = &word_29074;
      else
        v9 = (__int16 *)(*(_DWORD *)(v3 + 4) + 16 * v2);
      for ( i = (unsigned __int16)v9[1]; ; i = *(_WORD *)i )
      {
        if ( !(v6 & 1) && _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        if ( i == 0xFFFF )
          v11 = &word_29074;
        else
          v11 = *(__int16 **)(v3 + 4);
        if ( i != 0xFFFF )
          v11 += 8 * i;
        if ( (unsigned __int16)*v11 == 0xFFFF )
          break;
        LOBYTE(v6) = dword_2A5EC;
        if ( !(dword_2A5EC & 1) )
        {
          if ( _cxa_guard_acquire(&dword_2A5EC) )
          {
            word_29074 = -1;
            word_29076 = -1;
            word_29078 = -1;
            _cxa_guard_release(&dword_2A5EC);
          }
          LOBYTE(v6) = dword_2A5EC;
        }
        v12 = 0xFFFF;
        v13 = i == 0xFFFF;
        if ( i == 0xFFFF )
          i = (int)&word_29074;
        else
          v12 = *(_DWORD *)(v3 + 4);
        if ( !v13 )
          i = v12 + 16 * i;
      }
    }
    result = i;
  }
  return result;
}
// 93F0: could not find valid save-restore pair for r4
// 93F0: could not find valid save-restore pair for r5
// 93F0: could not find valid save-restore pair for r6
// 93F0: could not find valid save-restore pair for r7
// 93F0: could not find valid save-restore pair for r8
// 93F0: could not find valid save-restore pair for r9
// 93F0: could not find valid save-restore pair for r10
// 93F0: could not find valid save-restore pair for r11
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (0000974C) --------------------------------------------------------
int __fastcall sub_974C(int a1)
{
  int v1; // r11@1
  int v2; // r5@1
  signed int v3; // r4@1
  char v4; // r2@1
  __int16 *v5; // r2@3
  signed int v6; // r1@9
  bool v7; // zf@9
  int v8; // r1@23
  int v9; // r2@23
  int v10; // r3@23
  int v11; // r1@23
  int v12; // r2@23
  int v13; // r3@23
  int v14; // r1@23
  int v15; // r2@23
  int v16; // r3@23
  int v17; // r2@23
  int v18; // r1@23
  int v19; // r3@23
  int v20; // r1@23
  int v21; // r2@23
  int v22; // r3@23
  int v23; // r2@23
  int v24; // r1@23
  int v25; // r3@23

  v1 = a1;
  *(_DWORD *)a1 = &off_28960;
  v2 = a1 + 44;
  v3 = *(_WORD *)(a1 + 60);
  v4 = dword_2A5EC;
  while ( 1 )
  {
    if ( !(v4 & 1) && _cxa_guard_acquire(&dword_2A5EC) )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      _cxa_guard_release(&dword_2A5EC);
    }
    if ( v3 == 0xFFFF )
      v5 = &word_29074;
    else
      v5 = *(__int16 **)(v1 + 48);
    if ( v3 != 0xFFFF )
      v5 += 8 * v3;
    if ( (unsigned __int16)*v5 == 0xFFFF )
      break;
    v4 = dword_2A5EC;
    if ( !(dword_2A5EC & 1) )
    {
      if ( _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v4 = dword_2A5EC;
    }
    v6 = 0xFFFF;
    v7 = v3 == 0xFFFF;
    if ( v3 == 0xFFFF )
      v3 = (signed int)&word_29074;
    else
      v6 = *(_DWORD *)(v1 + 48);
    if ( !v7 )
      v3 = v6 + 16 * v3;
    v3 = *(_WORD *)v3;
  }
  for ( ; v3 != 0xFFFF; v3 = sub_93F0(v2, v3) )
    free(*(void **)(*(_DWORD *)(v1 + 48) + 16 * v3 + 8));
  sub_8244(v2);
  sub_8244(v2);
  *(_WORD *)(v1 + 64) = -1;
  sub_821C(v1 + 48, v8, v9, v10);
  *(_WORD *)(v1 + 66) = -1;
  sub_821C(v1 + 48, v11, v12, v13);
  *(_DWORD *)(v1 + 36) = 0;
  sub_81F4(v1 + 24, v14, v15, v16);
  v17 = *(_DWORD *)(v1 + 24);
  *(_DWORD *)(v1 + 40) = v17;
  sub_81F4(v1 + 24, v18, v17, v19);
  *(_DWORD *)(v1 + 16) = 0;
  sub_81CC(v1 + 4, v20, v21, v22);
  v23 = *(_DWORD *)(v1 + 4);
  *(_DWORD *)(v1 + 20) = v23;
  sub_81CC(v1 + 4, v24, v23, v25);
  return v1;
}
// 974C: could not find valid save-restore pair for r4
// 974C: could not find valid save-restore pair for r5
// 974C: could not find valid save-restore pair for r6
// 974C: could not find valid save-restore pair for r7
// 974C: could not find valid save-restore pair for r8
// 974C: could not find valid save-restore pair for r9
// 974C: could not find valid save-restore pair for r10
// 974C: could not find valid save-restore pair for r11
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 28960: using guessed type void *off_28960;
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (000098E4) --------------------------------------------------------
void sub_98E4()
{
  ;
}

//----- (000098F4) --------------------------------------------------------
int __fastcall sub_98F4(int a1)
{
  int result; // r0@2
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  if ( *(_BYTE *)(a1 + 4) )
    result = *(_BYTE *)(a1 + 5);
  else
    result = *(_BYTE *)(a1 + 4);
  return result;
}

//----- (00009948) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_9948(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r4@1
  int v9; // r5@1
  signed int v10; // r2@2
  int v11; // r3@2
  int v12; // r0@6
  int v13; // r2@6
  int v14; // r3@6
  int v16; // [sp+0h] [bp+0h]@1
  __int64 v17; // [sp+8h] [bp+8h]@1
  int *v18; // [sp+10h] [bp+10h]@1
  int v19; // [sp+14h] [bp+14h]@1

  v18 = &v16;
  v19 = v7;
  *(_QWORD *)&v16 = *(_QWORD *)&a4;
  v8 = a1;
  v17 = *(_QWORD *)&v5;
  v9 = *(_BYTE *)(a1 + 5);
  if ( *(_BYTE *)(a1 + 5) )
  {
    v10 = 0;
    v11 = *(_DWORD *)(a1 + 180);
    if ( !v11 )
      goto LABEL_6;
    while ( v11 != 1 )
    {
      if ( !v10 )
        return 0;
      while ( 1 )
      {
        v10 = 1;
        if ( v11 )
          break;
LABEL_6:
        v12 = CommandLine_Tier0(a1, a2);
        a1 = (*(int (__cdecl **)(int))(*(_DWORD *)v12 + 16))(v12);
        v13 = *(_DWORD *)(v8 + 152);
        v14 = *(_DWORD *)(v8 + 136) + 1;
        *(_DWORD *)(v8 + 136) = v14;
        if ( v14 < v13 )
          return v9;
        v11 = *(_DWORD *)(v8 + 180) + 1;
        *(_DWORD *)(v8 + 180) = v11;
      }
    }
  }
  return v9;
}
// 9948: could not find valid save-restore pair for r4
// 9948: could not find valid save-restore pair for r5
// 9948: could not find valid save-restore pair for r6
// 9948: could not find valid save-restore pair for r7
// 9948: variables would overlap: r3.4 and r3.8
// 9948: variables would overlap: r4.4 and r3.8
// 9948: variables would overlap: r5.4 and r5.8
// 9948: variables would overlap: r6.4 and r5.8
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);

//----- (000099AC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_99AC(int result)
{
  int v1; // r4@0
  int v2; // r5@0 OVERLAPPED
  __int64 v4; // r7@0
  int v5; // r9@0 OVERLAPPED
  int v7; // r11@0
  int v8; // lr@0
  int v9; // r4@1
  int v10; // r5@1
  int v11; // r5@3
  char *v12; // r5@3
  char *v13; // r0@3
  int v14; // r0@3
  int v15; // r1@3
  int (***v16)(void); // r0@3
  int v17; // r0@3
  int v18; // r1@3
  int v19; // r0@3
  int v20; // r0@3
  int v21; // r1@3
  int v22; // r0@3
  int v23; // r10@5
  char *v24; // r9@5
  char *v25; // r0@5
  char *v26; // r0@5
  int v27; // r0@5
  int v28; // r1@5
  int v29; // r0@5
  char *v30; // r9@7
  char *v31; // r5@7
  char *v32; // r0@7
  int v33; // r0@7
  int v34; // r1@7
  int (***v35)(void); // r0@7
  int v36; // r0@7
  int v37; // r1@7
  int v38; // r0@7
  int v39; // r1@7
  int v40; // r0@8
  const char *v41; // [sp+14h] [bp+4h]@5
  int v42; // [sp+18h] [bp+8h]@5
  int v43; // [sp+11Ch] [bp+10Ch]@5
  int v44; // [sp+220h] [bp+210h]@5
  int v45; // [sp+420h] [bp+410h]@3
  int v46; // [sp+624h] [bp+614h]@1
  __int64 v47; // [sp+628h] [bp+618h]@1
  __int64 v48; // [sp+630h] [bp+620h]@1
  __int64 v49; // [sp+638h] [bp+628h]@1
  int v50; // [sp+640h] [bp+630h]@1
  int v51; // [sp+644h] [bp+634h]@1

  v48 = v4;
  v46 = v1;
  v9 = result;
  v50 = v7;
  v51 = v8;
  v49 = *(_QWORD *)&v5;
  v47 = *(_QWORD *)&v2;
  v10 = *(_DWORD *)(result + 180);
  if ( v10 )
  {
    if ( v10 == 1 )
    {
      v11 = result + 104;
      (*(void (**)(void))(*(_DWORD *)result + 20))();
      v12 = sub_168CC(v11);
      v13 = sub_168CC(v9 + 56);
      sub_12440((char *)&v45, 0x200u, "%s -reslistdir %s -rebuildaudio", v12, v13);
      v14 = Warning("Caches:  Setting command line:\n'%s'\n", &v45);
      v16 = (int (***)(void))CommandLine_Tier0(v14, v15);
      v17 = (**v16)();
      v19 = CommandLine_Tier0(v17, v18);
      v20 = (*(int (**)(void))(*(_DWORD *)v19 + 16))();
      v22 = CommandLine_Tier0(v20, v21);
      result = (*(int (**)(void))(*(_DWORD *)v22 + 16))();
      ++*(_DWORD *)(v9 + 180);
    }
  }
  else
  {
    v23 = *(_DWORD *)(result + 140) + 32 * *(_DWORD *)(result + 136);
    v24 = sub_168CC(result + 72);
    v25 = sub_168CC(v23);
    sub_12440((char *)&v44, 0x200u, "%s\\%s", v24, v25);
    v26 = sub_168CC(v9 + 40);
    sub_12440((char *)&v42, 0x104u, "%s\\%s", v26, &v44);
    v27 = (*(int (**)(void))(*(_DWORD *)dword_2E35C + 68))();
    v41 = 0;
    v29 = CommandLine_Tier0(v27, v28);
    (*(void (**)(void))(*(_DWORD *)v29 + 12))();
    memset(&v43, 0, 0x104u);
    if ( v41 )
      sub_12330((char *)&v43, v41, 0x104u);
    v30 = sub_168CC(v9 + 104);
    v31 = sub_168CC(v9 + 88);
    v32 = sub_168CC(v23 + 16);
    sub_12440((char *)&v45, 0x200u, "%s %s %s -reslistdir %s", v30, v31, v32, &v44);
    v33 = Warning("Reslists:  Setting command line:\n'%s'\n", &v45);
    v35 = (int (***)(void))CommandLine_Tier0(v33, v34);
    v36 = (**v35)();
    v38 = CommandLine_Tier0(v36, v37);
    result = (*(int (**)(void))(*(_DWORD *)v38 + 20))();
    if ( (_BYTE)v43 )
    {
      v40 = CommandLine_Tier0(result, v39);
      result = (*(int (**)(void))(*(_DWORD *)v40 + 20))();
    }
  }
  return result;
}
// 99AC: could not find valid save-restore pair for r4
// 99AC: could not find valid save-restore pair for r5
// 99AC: could not find valid save-restore pair for r6
// 99AC: could not find valid save-restore pair for r7
// 99AC: could not find valid save-restore pair for r8
// 99AC: could not find valid save-restore pair for r9
// 99AC: could not find valid save-restore pair for r10
// 99AC: could not find valid save-restore pair for r11
// 99AC: variables would overlap: r5.4 and r5.8
// 99AC: variables would overlap: r6.4 and r5.8
// 99AC: variables would overlap: r9.4 and r9.8
// 99AC: variables would overlap: r10.4 and r9.8
// 365C: using guessed type int Warning(const char *, ...);
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 2E35C: using guessed type int dword_2E35C;

//----- (00009BA0) --------------------------------------------------------
int __fastcall sub_9BA0(int result)
{
  int *v1; // [sp+0h] [bp+0h]@1

  v1 = (int *)&v1;
  if ( *(_BYTE *)(result + 5) )
    result = sub_99AC(result);
  return result;
}

//----- (00009BBC) --------------------------------------------------------
int __fastcall sub_9BBC(int a1)
{
  int v1; // r9@1
  int result; // r0@1
  int v3; // r6@1
  int v4; // r4@2
  char v5; // r3@2
  int *v6; // r3@4
  int v7; // r1@9
  bool v8; // zf@10
  int i; // r2@22
  int v10; // r8@23
  void (__fastcall *v11)(int, char *, size_t, int); // r10@23
  char *v12; // ST00_4@23
  char *v13; // r0@23
  size_t v14; // r0@23

  v1 = a1;
  result = (*(int (__fastcall **)(int))(*(_DWORD *)(dword_2E35C + 4) + 8))(dword_2E35C + 4);
  v3 = result;
  if ( result )
  {
    v4 = *(_DWORD *)(v1 + 16);
    v5 = dword_2A5F0;
    while ( 1 )
    {
      if ( !(v5 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      if ( v4 == -1 )
        v6 = &dword_2907C;
      else
        v6 = *(int **)(v1 + 4);
      if ( v4 != -1 )
        v6 += 8 * v4;
      if ( *v6 == -1 )
        break;
      v5 = dword_2A5F0;
      v7 = dword_2A5F0 << 31;
      if ( !(dword_2A5F0 & 1) )
      {
        if ( _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        v5 = dword_2A5F0;
      }
      v8 = v4 == -1;
      if ( v4 == -1 )
        v4 = (int)&dword_2907C;
      else
        v7 = *(_DWORD *)(v1 + 4);
      if ( !v8 )
        v4 = v7 + 32 * v4;
      v4 = *(_DWORD *)v4;
    }
    for ( i = v4 + 1; v4 != -1; v4 = sub_AA28(v1, v4) )
    {
      v10 = dword_2E35C + 4;
      v11 = *(void (__fastcall **)(int, char *, size_t, int))(*(_DWORD *)(dword_2E35C + 4) + 4);
      v12 = sub_168CC(*(_DWORD *)(v1 + 4) + 32 * v4 + 16);
      v13 = sub_168CC(*(_DWORD *)(v1 + 4) + 32 * v4 + 16);
      v14 = strlen(v13);
      v11(v10, v12, v14, v3);
      (*(void (__fastcall **)(int, char *, signed int, int))(*(_DWORD *)(dword_2E35C + 4) + 4))(
        dword_2E35C + 4,
        "\n",
        1,
        v3);
    }
    (*(void (__fastcall **)(int, int, int))(*(_DWORD *)(dword_2E35C + 4) + 12))(dword_2E35C + 4, v3, i);
    result = 1;
  }
  return result;
}
// 9BBC: could not find valid save-restore pair for r4
// 9BBC: could not find valid save-restore pair for r5
// 9BBC: could not find valid save-restore pair for r6
// 9BBC: could not find valid save-restore pair for r7
// 9BBC: could not find valid save-restore pair for r8
// 9BBC: could not find valid save-restore pair for r9
// 9BBC: could not find valid save-restore pair for r10
// 9BBC: could not find valid save-restore pair for r11
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29080: using guessed type int dword_29080;
// 29084: using guessed type int dword_29084;
// 2A5F0: using guessed type int dword_2A5F0;
// 2E35C: using guessed type int dword_2E35C;

//----- (00009D54) --------------------------------------------------------
void __fastcall sub_9D54(int a1, int a2, int a3, int a4)
{
  int v4; // lr@0
  int v5; // r9@1
  int v6; // r3@1
  int v7; // r1@2
  int v8; // r2@2
  int v9; // r3@2
  signed int v10; // r0@3
  int v11; // r1@3
  int v12; // r2@3
  int v13; // r3@4
  bool v14; // zf@4
  int v15; // r4@9
  bool v16; // zf@9
  int v17; // r2@12
  int v18; // r3@12
  int v19; // r1@12
  int v20; // r2@12
  int v21; // r3@12
  int v22; // [sp+10h] [bp+0h]@12
  int v23; // [sp+20h] [bp+10h]@1
  char v24; // [sp+58h] [bp+48h]@2
  int v25; // [sp+160h] [bp+150h]@1
  int v26; // [sp+37Ch] [bp+36Ch]@1

  v5 = a3;
  v26 = v4;
  sub_12440((char *)&v25, 0x200u, "%s/%s", a2, a4);
  sub_16580((int)&v23, 0, 0, 1);
  if ( (*(int (__fastcall **)(int, int *, const char *, int *))(*(_DWORD *)(dword_2E35C + 4) + 56))(
         dword_2E35C + 4,
         &v25,
         "GAME",
         &v23) )
  {
    while ( 1 )
    {
      sub_14CD8(&v23, &v24, 260, v6);
      v9 = v24;
      if ( !v24 )
        break;
      v10 = strlen(&v24);
      if ( v10 > 0 )
      {
        v13 = *(&v24 + v10 - 1);
        v14 = v13 == 10;
        if ( v13 != 10 )
          v14 = v13 == 13;
        if ( v14 )
        {
          do
          {
            *(&v24 + v10 - 1) = 0;
            v10 = strlen(&v24);
            if ( v10 <= 0 )
              break;
            v15 = *(&v24 + v10 - 1);
            v16 = v15 == 10;
            if ( v15 != 10 )
              v16 = v15 == 13;
          }
          while ( v16 );
        }
      }
      sub_16E50(&v22, v11, v12);
      sub_169D0(&v22, &v24, v17, v18);
      sub_AD74(v5, *(_DWORD *)(v5 + 12), (int)&v22);
      sub_7FBC((int)&v22, v19, v20, v21);
    }
  }
  else
  {
    ((void (*)(const char *, ...))Error)("Unable to maplist file %s\n", &v25);
  }
  sub_7FBC((int)&v23, v7, v8, v9);
}
// 3BE0: invalid function type has been ignored
// 2E35C: using guessed type int dword_2E35C;

//----- (00009E74) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_9E74(int a1, int a2, _BYTE *a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  int v8; // r9@0 OVERLAPPED
  int v10; // r11@0
  int v11; // lr@0
  int v12; // r10@1
  int v13; // r6@1
  int v14; // r4@1
  bool v15; // zf@1
  int v16; // r4@4
  int v17; // r0@4
  int v18; // r1@4
  int v19; // r2@4
  int v20; // r3@4
  int v21; // r11@7
  int v22; // r0@8
  int v23; // r2@8
  int v24; // r3@8
  char *v25; // r0@8
  int v26; // r0@8
  int v27; // r1@8
  int v28; // r0@9
  int v29; // r0@9
  int v30; // r1@9
  int v31; // r2@9
  int v32; // r1@11
  int v33; // r2@11
  int v34; // r3@11
  int v35; // r1@11
  int v36; // r2@11
  int v37; // r2@11
  int v38; // r3@11
  int v39; // r1@11
  int v40; // r2@11
  int v41; // r3@11
  int v42; // r0@12
  int v43; // r0@12
  int v44; // r1@12
  int v45; // r0@12
  void *v46; // r0@12
  int v47; // r2@12
  int v48; // r3@12
  const char *v49; // r1@12
  int v50; // r0@14
  int v51; // r0@14
  int v52; // r1@14
  int v53; // r0@14
  int v54; // r0@14
  int v55; // r1@14
  int v56; // r0@14
  int v57; // r0@14
  int v58; // r1@14
  int v59; // r0@14
  int v60; // r0@14
  int v61; // r1@14
  int v62; // r0@14
  int v63; // r0@14
  int v64; // r1@14
  int v65; // r0@14
  const char *v66; // r0@14
  int v67; // r2@14
  int v68; // r3@14
  void *v69; // r0@14
  int v70; // r1@14
  int v71; // r4@15
  void (__fastcall *v72)(int, const char *, char *); // r5@15
  char *v73; // r0@15
  const char *v74; // r0@16
  int v75; // r2@16
  int v76; // r3@16
  char *v77; // r0@16
  const char *v78; // r0@16
  int v79; // r2@16
  int v80; // r3@16
  char *v81; // r0@16
  const char *v82; // r0@16
  int v83; // r2@16
  int v84; // r3@16
  int v85; // r8@16
  int v86; // r1@17
  int v87; // r2@17
  int v88; // r3@17
  int v89; // r1@18
  int v90; // r2@18
  int v91; // r3@18
  int v92; // r1@19
  int v93; // r2@19
  int v94; // r5@19
  int v95; // r1@20
  int v96; // r2@20
  const char *v97; // r0@20
  int v98; // r2@20
  int v99; // r3@20
  const char *v100; // r0@20
  int v101; // r2@20
  int v102; // r3@20
  int v103; // r1@22
  int v104; // r2@22
  int v105; // r3@22
  int v107; // r1@25
  int v108; // r2@25
  int v109; // r3@25
  int v110; // r3@26
  bool v111; // r2@26
  int v112; // r3@26
  int v113; // r2@27
  int v114; // r0@31
  int v115; // r1@31
  int v116; // r2@31
  int v117; // r3@31
  int v118; // r1@32
  int v119; // r2@32
  int v120; // r3@32
  char *v121; // r0@34
  int v122; // r1@34
  int v123; // r2@34
  int v124; // r3@34
  int *v125; // [sp+14h] [bp+4h]@8
  const char *v126; // [sp+18h] [bp+8h]@16
  char **v127; // [sp+1Ch] [bp+Ch]@4
  int *v128; // [sp+20h] [bp+10h]@4
  char *v129; // [sp+24h] [bp+14h]@16
  const char *v130; // [sp+28h] [bp+18h]@16
  char *v131; // [sp+2Ch] [bp+1Ch]@16
  const char *v132; // [sp+30h] [bp+20h]@16
  const char *v133; // [sp+34h] [bp+24h]@16
  const char *v134; // [sp+38h] [bp+28h]@9
  const char *v135; // [sp+40h] [bp+30h]@12
  int v136; // [sp+48h] [bp+38h]@8
  int v137; // [sp+58h] [bp+48h]@19
  int v138; // [sp+78h] [bp+68h]@11
  int v139; // [sp+88h] [bp+78h]@18
  char *s; // [sp+98h] [bp+88h]@4
  int v141; // [sp+D0h] [bp+C0h]@4
  int v142; // [sp+2D4h] [bp+2C4h]@1
  __int64 v143; // [sp+2D8h] [bp+2C8h]@1
  __int64 v144; // [sp+2E0h] [bp+2D0h]@1
  __int64 v145; // [sp+2E8h] [bp+2D8h]@1
  int v146; // [sp+2F0h] [bp+2E0h]@1
  int v147; // [sp+2F4h] [bp+2E4h]@1

  v145 = *(_QWORD *)&v8;
  v12 = a1;
  v144 = *(_QWORD *)&v6;
  v143 = *(_QWORD *)&v4;
  v13 = a2;
  v146 = v10;
  v147 = v11;
  v142 = v3;
  v14 = *a3;
  v15 = v14 == 43;
  if ( v14 != 43 )
    v15 = v14 == 45;
  if ( v15 )
  {
    v16 = 0;
    Msg("falling back to legacy reslists system\n");
  }
  else
  {
    v16 = 0;
    v128 = &v141;
    v127 = &s;
    sub_12440((char *)&v141, 0x200u, "%s/%s", a2, a3);
    sub_16580((int)&s, 0, 0, 0);
    v17 = (*(int (__fastcall **)(int, int *, const char *, char **))(*(_DWORD *)(dword_2E35C + 4) + 56))(
            dword_2E35C + 4,
            &v141,
            "GAME",
            &s);
    if ( v17 )
    {
      v21 = sub_DB08(32, v18, v19, v20);
      sub_CECC(v21, (int)"reslists");
      if ( sub_10210(v21, (int)"reslists", s, 0, 0) )
      {
        v22 = sub_E238(v21, "maplist", (int)"maplist.txt");
        v125 = &v136;
        sub_16E7C(&v136, v22, v23, v24);
        v25 = sub_168F0((int)&v136);
        sub_9D54(v12, v13, v12 + 160, (int)v25);
        if ( *(_DWORD *)(v12 + 172) <= 0 )
        {
          v121 = sub_168CC((int)&v136);
          ((void (*)(const char *, ...))Error)("Maplist file '%s' empty or missing!!!\n", v121);
          sub_EB0C(v21, v122, v123, v124);
        }
        else
        {
          v134 = 0;
          v28 = CommandLine_Tier0(v26, v27);
          v29 = (*(int (**)(void))(*(_DWORD *)v28 + 12))();
          if ( v29 && v134 )
          {
            sub_AE24(v12 + 160, v30, v31, (int)v134);
            sub_AE58(v12 + 160, v32, v33, v34);
            *(_DWORD *)(v12 + 176) = *(_DWORD *)(v12 + 160);
            sub_16E50(&v138, v35, v36);
            sub_169D0(&v138, v134, v37, v38);
            sub_AD74(v12 + 160, *(_DWORD *)(v12 + 172), (int)&v138);
            sub_7FBC((int)&v138, v39, v40, v41);
          }
          v42 = CommandLine_Tier0(v29, v30);
          v43 = (*(int (**)(void))(*(_DWORD *)v42 + 28))();
          *(_DWORD *)(v12 + 136) = v43;
          v135 = 0;
          v45 = CommandLine_Tier0(v43, v44);
          v46 = (void *)(*(int (**)(void))(*(_DWORD *)v45 + 12))();
          v49 = v135;
          if ( v135 )
            v46 = sub_169D0((void *)(v12 + 120), v135, v47, v48);
          v50 = CommandLine_Tier0(v46, v49);
          v51 = (*(int (**)(void))(*(_DWORD *)v50 + 16))();
          v53 = CommandLine_Tier0(v51, v52);
          v54 = (*(int (**)(void))(*(_DWORD *)v53 + 16))();
          v56 = CommandLine_Tier0(v54, v55);
          v57 = (*(int (**)(void))(*(_DWORD *)v56 + 16))();
          v59 = CommandLine_Tier0(v57, v58);
          v60 = (*(int (**)(void))(*(_DWORD *)v59 + 16))();
          v62 = CommandLine_Tier0(v60, v61);
          v63 = (*(int (**)(void))(*(_DWORD *)v62 + 16))();
          v65 = CommandLine_Tier0(v63, v64);
          v66 = (const char *)(*(int (**)(void))(*(_DWORD *)v65 + 8))();
          v69 = sub_169D0((void *)(v12 + 104), v66, v67, v68);
          if ( v135 )
          {
            v71 = CommandLine_Tier0(v69, v70);
            v72 = *(void (__fastcall **)(int, const char *, char *))(*(_DWORD *)v71 + 20);
            v73 = sub_168CC(v12 + 120);
            v72(v71, "-startmap", v73);
          }
          v74 = (const char *)sub_E238(v21, "basecommandline", (int)"");
          sub_169D0((void *)(v12 + 88), v74, v75, v76);
          v77 = sub_168CC(v12 + 56);
          v78 = (const char *)sub_E238(v21, "finaldir", (int)v77);
          sub_169D0((void *)(v12 + 56), v78, v79, v80);
          v81 = sub_168CC(v12 + 72);
          v82 = (const char *)sub_E238(v21, "workdir", (int)v81);
          sub_169D0((void *)(v12 + 72), v82, v83, v84);
          v85 = 0;
          v133 = "%i";
          v132 = "subdir";
          v131 = "";
          v130 = "addcommands";
          v129 = "";
          v126 = "%s: failed to specify 'subdir' for item %s\n";
          while ( 1 )
          {
            sub_12440((char *)&v137, 0x20u, v133, v85);
            v94 = sub_DBF0(v21, (const char *)&v137, 0);
            if ( !v94 )
              break;
            sub_16E50(&v138, v92, v93);
            sub_16E50(&v139, v95, v96);
            v97 = (const char *)sub_E238(v94, v132, (int)v131);
            sub_169D0(&v138, v97, v98, v99);
            v100 = (const char *)sub_E238(v94, v130, (int)v129);
            sub_169D0(&v139, v100, v101, v102);
            if ( sub_168A0((int)&v138) > 0 )
              sub_AEA8(v12 + 140, *(_DWORD *)(v12 + 152), (int)&v138);
            else
              ((void (__fastcall *)(const char *, int *, int *))Error)(v126, &v141, &v137);
            ++v85;
            sub_7FBC((int)&v139, v86, v87, v88);
            sub_7FBC((int)&v138, v89, v90, v91);
          }
          v110 = *(_DWORD *)(v12 + 152);
          v111 = v110 > 0;
          v112 = v110 - 1;
          *(_BYTE *)(v12 + 5) = v111;
          if ( v112 >= 0 )
          {
            v113 = *(_DWORD *)(v12 + 136);
            if ( v113 >= 0 )
            {
              if ( v112 >= v113 )
                v112 = *(_DWORD *)(v12 + 136);
            }
            else
            {
              v112 = 0;
            }
          }
          *(_DWORD *)(v12 + 136) = v112;
          v114 = CommandLine_Tier0(0, v92);
          if ( (*(int (**)(void))(*(_DWORD *)v114 + 12))() )
          {
            (*(void (__fastcall **)(int))(*(_DWORD *)v12 + 20))(v12);
            *(_BYTE *)(v12 + 5) = 0;
            exit(-1);
          }
          sub_EB0C(v21, v115, v116, v117);
          v16 = *(_BYTE *)(v12 + 5);
        }
        sub_7FBC((int)&v136, v118, v119, v120);
      }
      else
      {
        ((void (*)(const char *, ...))Error)("Unable to parse keyvalues from '%s'\n", &v141);
        sub_EB0C(v21, v107, v108, v109);
      }
    }
    else
    {
      ((void (*)(const char *, ...))Error)("Unable to load '%s'\n", &v141);
    }
    sub_7FBC((int)&s, v103, v104, v105);
  }
  return v16;
}
// 3BE0: invalid function type has been ignored
// 9E74: could not find valid save-restore pair for r4
// 9E74: could not find valid save-restore pair for r5
// 9E74: could not find valid save-restore pair for r6
// 9E74: could not find valid save-restore pair for r7
// 9E74: could not find valid save-restore pair for r8
// 9E74: could not find valid save-restore pair for r9
// 9E74: could not find valid save-restore pair for r10
// 9E74: could not find valid save-restore pair for r11
// 9E74: variables would overlap: r5.4 and r5.8
// 9E74: variables would overlap: r6.4 and r5.8
// 9E74: variables would overlap: r7.4 and r7.8
// 9E74: variables would overlap: r8.4 and r7.8
// 9E74: variables would overlap: r9.4 and r9.8
// 9E74: variables would overlap: r10.4 and r9.8
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 3A48: using guessed type int __fastcall Msg(_DWORD);
// 2E35C: using guessed type int dword_2E35C;

//----- (0000A2FC) --------------------------------------------------------
int __fastcall sub_A2FC(int a1, const char *a2, int a3)
{
  int v3; // lr@0
  const char *v4; // r8@1
  int v5; // r6@1
  int v6; // r5@1
  void *v7; // r4@1
  int v8; // r2@1
  int v9; // r3@1
  char *v10; // r6@1
  char *v11; // r0@1
  int v12; // r2@1
  int v13; // r3@1
  void *v14; // r0@1
  int v15; // r1@1
  int v16; // r0@1
  int result; // r0@1
  _BYTE *v18; // [sp+8h] [bp+0h]@1
  int v19; // [sp+Ch] [bp+4h]@1
  int v20; // [sp+124h] [bp+11Ch]@1

  v20 = v3;
  v4 = (const char *)a3;
  v5 = a1 + 8;
  v6 = a1;
  v7 = (void *)(a1 + 24);
  *(_BYTE *)(a1 + 4) = 1;
  sub_169D0((void *)(a1 + 8), a2, a3, 1);
  sub_169D0(v7, v4, v8, v9);
  v10 = sub_168CC(v5);
  v11 = sub_168CC((int)v7);
  sub_12440((char *)&v19, 0x104u, "%s/%s", v10, v11);
  sub_133C8(&v19, 47);
  sub_119B8(&v19);
  v14 = sub_169D0((void *)(v6 + 40), (const char *)&v19, v12, v13);
  v18 = 0;
  v16 = CommandLine_Tier0(v14, v15);
  result = (*(int (**)(void))(*(_DWORD *)v16 + 12))();
  if ( result )
  {
    if ( v18 )
      result = sub_9E74(v6, (int)&v19, v18);
  }
  return result;
}
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);

//----- (0000A3A4) --------------------------------------------------------
int __fastcall sub_A3A4(int result, const char *a2, int a3)
{
  int *v3; // [sp+0h] [bp+0h]@1

  v3 = (int *)&v3;
  if ( !*(_BYTE *)(result + 4) )
    result = sub_A2FC(result, a2, a3);
  return result;
}

//----- (0000A500) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_A500(int a1, int a2, int a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  __int64 v8; // r9@0
  int v9; // r11@0
  int v10; // lr@0
  int v11; // r8@1
  int v12; // r6@1
  int v13; // r5@1
  int v14; // r1@1
  int v15; // r2@1
  int v16; // r3@1
  int v17; // r1@4
  int v18; // r2@4
  int v19; // r2@4
  int v20; // r2@5
  int v21; // r3@5
  int v22; // r4@6
  int v23; // r1@7
  int v24; // r4@10
  int v25; // r1@11
  int v26; // r2@11
  int v27; // r3@11
  int *v28; // r3@17
  int *v29; // r3@19
  const char *v30; // [sp+14h] [bp+4h]@2
  int *v31; // [sp+18h] [bp+8h]@2
  int *v32; // [sp+1Ch] [bp+Ch]@1
  int *v33; // [sp+20h] [bp+10h]@2
  int *v34; // [sp+24h] [bp+14h]@2
  int v35; // [sp+28h] [bp+18h]@4
  int v36; // [sp+38h] [bp+28h]@1
  int v37; // [sp+70h] [bp+60h]@2
  char v38; // [sp+170h] [bp+160h]@3
  int v39; // [sp+274h] [bp+264h]@5
  _BYTE v40[3]; // [sp+279h] [bp+269h]@5
  int v41; // [sp+384h] [bp+374h]@1
  __int64 v42; // [sp+388h] [bp+378h]@1
  __int64 v43; // [sp+390h] [bp+380h]@1
  __int64 v44; // [sp+398h] [bp+388h]@1
  int v45; // [sp+3A0h] [bp+390h]@1
  int v46; // [sp+3A4h] [bp+394h]@1

  v43 = *(_QWORD *)&v6;
  v11 = a2;
  v42 = *(_QWORD *)&v4;
  v12 = a3;
  v13 = a1;
  v41 = v3;
  v45 = v9;
  v46 = v10;
  v44 = v8;
  v32 = &v36;
  sub_16580((int)&v36, 0, 0, 1);
  if ( (*(int (__fastcall **)(int, int, int, int *))(*(_DWORD *)(dword_2E35C + 4) + 56))(
         dword_2E35C + 4,
         v11,
         v12,
         &v36) )
  {
    v31 = &v37;
    sub_B0A4(&v37, "");
    v30 = "\"%s\"";
    v33 = &dword_2907C;
    v34 = &dword_2907C;
    while ( sub_155C0((int)&v36, (int)&v37, &v38, 260, 1) > 0 )
    {
      sub_119B8(&v38);
      sub_133C8(&v38, 47);
      sub_16E50(&v35, v17, v18);
      if ( v38 == 34 )
      {
        sub_169D0(&v35, &v38, v19, 34);
      }
      else
      {
        sub_80A0((int)&v39, (int)v30, (int)&v38, v38);
        sub_169D0(&v35, v40, v20, v21);
      }
      v22 = *(_DWORD *)(v13 + 16);
      if ( v22 != -1 )
      {
        v23 = *(_DWORD *)(v13 + 4);
        do
        {
          while ( 1 )
          {
            v24 = 32 * v22;
            if ( !(*(int (__fastcall **)(int *, int))v13)(&v35, v23 + v24 + 16) )
              break;
            if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
            {
              v28 = v34;
              *v34 = -1;
              v28[1] = -1;
              v28[2] = -1;
              _cxa_guard_release(&dword_2A5F0);
            }
            v23 = *(_DWORD *)(v13 + 4);
            v22 = *(_DWORD *)(v23 + v24);
            if ( v22 == -1 )
              goto LABEL_14;
          }
          if ( !(*(int (__fastcall **)(int, int *))v13)(*(_DWORD *)(v13 + 4) + v24 + 16, &v35) )
            goto LABEL_15;
          if ( !(dword_2A5F0 & 1) )
          {
            if ( _cxa_guard_acquire(&dword_2A5F0) )
            {
              v29 = v33;
              *v33 = -1;
              v29[1] = -1;
              v29[2] = -1;
              _cxa_guard_release(&dword_2A5F0);
            }
          }
          v23 = *(_DWORD *)(v13 + 4);
          v22 = *(_DWORD *)(v24 + v23 + 4);
        }
        while ( v22 != -1 );
      }
LABEL_14:
      sub_9188(v13, (int)&v35);
LABEL_15:
      sub_7FBC((int)&v35, v25, v26, v27);
    }
  }
  sub_7FBC((int)&v36, v14, v15, v16);
}
// A500: could not find valid save-restore pair for r4
// A500: could not find valid save-restore pair for r5
// A500: could not find valid save-restore pair for r6
// A500: could not find valid save-restore pair for r7
// A500: could not find valid save-restore pair for r8
// A500: could not find valid save-restore pair for r9
// A500: could not find valid save-restore pair for r10
// A500: could not find valid save-restore pair for r11
// A500: variables would overlap: r5.4 and r5.8
// A500: variables would overlap: r6.4 and r5.8
// A500: variables would overlap: r7.4 and r7.8
// A500: variables would overlap: r8.4 and r7.8
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 2A5F0: using guessed type int dword_2A5F0;
// 2E35C: using guessed type int dword_2E35C;

//----- (0000A6D8) --------------------------------------------------------
void __fastcall sub_A6D8(int a1, int a2)
{
  int v2; // r4@0
  __int64 v3; // r5@0
  int v4; // r7@0
  int v5; // lr@0
  int v10; // r1@1
  int v11; // r1@1
  int v12; // r2@1
  int v13; // r3@1
  int v14; // r1@1
  int v15; // r2@1
  int v16; // r3@1
  int (*v17)(); // [sp+0h] [bp+0h]@1
  int v18; // [sp+4h] [bp+4h]@1
  double v19; // [sp+18h] [bp+18h]@1
  int v20; // [sp+20h] [bp+20h]@1
  int v21; // [sp+2Ch] [bp+2Ch]@1
  __int64 v22; // [sp+30h] [bp+30h]@1
  int v23; // [sp+38h] [bp+38h]@1
  int v24; // [sp+3Ch] [bp+3Ch]@1

  __asm
  {
    VMOV.I32        D18, #0
    VMOV.I64        D17, #0xFFFFFFFF
    VMOV.I8         D16, #0xFF
  }
  v23 = v4;
  v24 = v5;
  v22 = v3;
  v21 = v2;
  __asm { VSTR            D18, [R7,#0x40+var_38] }
  v18 = 0;
  v17 = sub_9914;
  __asm
  {
    VSTR            D17, [R7,#0x40+var_30]
    VSTR            D16, [R7,#0x40+var_28]
  }
  v20 = 0;
  sub_A500((int)&v17, a1, a2);
  sub_9BBC((int)&v17);
  sub_7FE4((int)&v17, v10);
  LODWORD(v19) = -1;
  sub_811C((int)&v18, v11, v12, v13);
  HIDWORD(v19) = -1;
  sub_811C((int)&v18, v14, v15, v16);
}
// A6D8: could not find valid save-restore pair for r4
// A6D8: could not find valid save-restore pair for r5
// A6D8: could not find valid save-restore pair for r6
// A6D8: could not find valid save-restore pair for r7
// 9914: using guessed type int sub_9914();

//----- (0000A764) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_A764(int a1, int a2, int a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  int v8; // r9@0
  int v9; // lr@0
  int v14; // r8@1
  int v15; // r5@1
  int v16; // r4@1
  int v17; // r3@1
  char *v18; // r0@2
  int v19; // r1@3
  int v20; // r1@3
  int v21; // r2@3
  int v22; // r3@3
  int v23; // r1@3
  int v24; // r2@3
  int v25; // r3@3
  int (*v26)(); // [sp+0h] [bp+0h]@1
  int v27; // [sp+4h] [bp+4h]@1
  double v28; // [sp+18h] [bp+18h]@3
  int v29; // [sp+20h] [bp+20h]@1
  int v30; // [sp+2Ch] [bp+2Ch]@1
  __int64 v31; // [sp+30h] [bp+30h]@1
  __int64 v32; // [sp+38h] [bp+38h]@1
  int v33; // [sp+40h] [bp+40h]@1
  int v34; // [sp+44h] [bp+44h]@1

  __asm
  {
    VMOV.I32        D18, #0
    VMOV.I64        D17, #0xFFFFFFFF
    VMOV.I8         D16, #0xFF
  }
  v32 = *(_QWORD *)&v6;
  v14 = a3;
  v33 = v8;
  v34 = v9;
  v31 = *(_QWORD *)&v4;
  v15 = a1;
  v30 = v3;
  v16 = 0;
  v17 = *(_DWORD *)(a1 + 12);
  __asm { VSTR            D18, [R7,#0x48+var_40] }
  v27 = 0;
  __asm { VSTR            D17, [R7,#0x48+var_38] }
  v29 = 0;
  v26 = sub_9914;
  __asm { VSTR            D16, [R7,#0x48+var_30] }
  if ( v17 > 0 )
  {
    do
    {
      v18 = sub_168CC(*(_DWORD *)v15 + 16 * v16);
      sub_A500((int)&v26, (int)v18, v14);
      ++v16;
    }
    while ( *(_DWORD *)(v15 + 12) > v16 );
  }
  sub_9BBC((int)&v26);
  sub_7FE4((int)&v26, v19);
  LODWORD(v28) = -1;
  sub_811C((int)&v27, v20, v21, v22);
  HIDWORD(v28) = -1;
  sub_811C((int)&v27, v23, v24, v25);
}
// A764: could not find valid save-restore pair for r4
// A764: could not find valid save-restore pair for r5
// A764: could not find valid save-restore pair for r6
// A764: could not find valid save-restore pair for r7
// A764: could not find valid save-restore pair for r8
// A764: could not find valid save-restore pair for r9
// A764: variables would overlap: r5.4 and r5.8
// A764: variables would overlap: r6.4 and r5.8
// A764: variables would overlap: r7.4 and r7.8
// A764: variables would overlap: r8.4 and r7.8
// 9914: using guessed type int sub_9914();

//----- (0000AA28) --------------------------------------------------------
signed int __fastcall sub_AA28(int a1, int a2)
{
  int v2; // r11@1
  int v3; // r5@1
  int *v5; // r3@7
  int v6; // r3@9
  int v7; // r0@10
  int v8; // r4@13
  int *v9; // r1@16
  int i; // r4@17
  int *v11; // r3@19
  bool v12; // zf@25
  int v13; // r2@25
  int *v14; // r2@44
  int *v15; // r3@47
  int v16; // r9@51
  int v17; // r2@53

  v2 = a2;
  v3 = a1;
  if ( (unsigned int)a2 >= *(_DWORD *)(a1 + 8) || a2 > *(_DWORD *)(a1 + 28) )
    return -1;
  if ( !(dword_2A5F0 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
  {
    dword_2907C = -1;
    dword_29080 = -1;
    dword_29084 = -1;
    _cxa_guard_release(&dword_2A5F0);
  }
  v5 = v2 == -1 ? &dword_2907C : *(_DWORD *)(v3 + 4) + 32 * v2;
  if ( v2 == *v5 )
    return -1;
  v6 = dword_2A5F0;
  if ( dword_2A5F0 << 31 >= 0 )
  {
    if ( _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    v6 = dword_2A5F0;
    v7 = dword_2A5F0 & 1;
    if ( v2 != -1 )
    {
LABEL_13:
      v8 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + 32 * v2 + 4);
      if ( v8 != -1 )
        goto LABEL_14;
LABEL_42:
      if ( !v7 )
      {
        if ( _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = v8;
          dword_29080 = v8;
          dword_29084 = v8;
          _cxa_guard_release(&dword_2A5F0);
        }
        v6 = dword_2A5F0;
      }
      if ( v2 == -1 )
        v14 = &dword_2907C;
      else
        v14 = (int *)(*(_DWORD *)(v3 + 4) + 32 * v2);
      for ( i = v14[2]; ; i = *(_DWORD *)(*(_DWORD *)(v3 + 4) + 32 * i + 8) )
      {
        if ( v6 << 31 >= 0 )
        {
          if ( _cxa_guard_acquire(&dword_2A5F0) )
          {
            dword_2907C = -1;
            dword_29080 = -1;
            dword_29084 = -1;
            _cxa_guard_release(&dword_2A5F0);
          }
          v17 = dword_2A5F0 & 1;
        }
        else
        {
          v17 = 1;
        }
        if ( v2 == -1 )
          v15 = &dword_2907C;
        else
          v15 = *(int **)(v3 + 4);
        if ( v2 != -1 )
          v15 += 8 * v2;
        v16 = v15[2];
        if ( !v17 && _cxa_guard_acquire(&dword_2A5F0) )
        {
          dword_2907C = -1;
          dword_29080 = -1;
          dword_29084 = -1;
          _cxa_guard_release(&dword_2A5F0);
        }
        if ( v16 == -1 )
          v15 = &dword_2907C;
        else
          v17 = *(_DWORD *)(v3 + 4);
        if ( v16 != -1 )
          v15 = (int *)(v17 + 32 * v16);
        if ( v2 != v15[1] )
          break;
        if ( i == -1 )
          return -1;
        v6 = dword_2A5F0;
        if ( !(dword_2A5F0 & 1) )
        {
          if ( _cxa_guard_acquire(&dword_2A5F0) )
          {
            dword_2907C = -1;
            dword_29080 = -1;
            dword_29084 = -1;
            _cxa_guard_release(&dword_2A5F0);
          }
          v6 = dword_2A5F0;
        }
        v2 = i;
      }
      return i;
    }
  }
  else
  {
    v7 = 1;
    if ( v2 != -1 )
      goto LABEL_13;
  }
  v8 = dword_29080;
  if ( dword_29080 == -1 )
    goto LABEL_42;
LABEL_14:
  if ( v7 )
  {
    if ( v2 != -1 )
    {
LABEL_16:
      v9 = (int *)(*(_DWORD *)(v3 + 4) + 32 * v2);
      goto LABEL_17;
    }
  }
  else
  {
    if ( _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    LOBYTE(v6) = dword_2A5F0;
    if ( v2 != -1 )
      goto LABEL_16;
  }
  v9 = &dword_2907C;
LABEL_17:
  for ( i = v9[1]; ; i = *(_DWORD *)i )
  {
    if ( !(v6 & 1) && _cxa_guard_acquire(&dword_2A5F0) )
    {
      dword_2907C = -1;
      dword_29080 = -1;
      dword_29084 = -1;
      _cxa_guard_release(&dword_2A5F0);
    }
    if ( i == -1 )
      v11 = &dword_2907C;
    else
      v11 = *(int **)(v3 + 4);
    if ( i != -1 )
      v11 += 8 * i;
    if ( *v11 == -1 )
      break;
    LOBYTE(v6) = dword_2A5F0;
    if ( !(dword_2A5F0 & 1) )
    {
      if ( _cxa_guard_acquire(&dword_2A5F0) )
      {
        dword_2907C = -1;
        dword_29080 = -1;
        dword_29084 = -1;
        _cxa_guard_release(&dword_2A5F0);
      }
      LOBYTE(v6) = dword_2A5F0;
    }
    v13 = i + 1;
    v12 = i == -1;
    if ( i == -1 )
      i = (int)&dword_2907C;
    else
      v13 = *(_DWORD *)(v3 + 4);
    if ( !v12 )
      i = v13 + 32 * i;
  }
  return i;
}
// AA28: could not find valid save-restore pair for r4
// AA28: could not find valid save-restore pair for r5
// AA28: could not find valid save-restore pair for r6
// AA28: could not find valid save-restore pair for r7
// AA28: could not find valid save-restore pair for r8
// AA28: could not find valid save-restore pair for r9
// AA28: could not find valid save-restore pair for r10
// AA28: could not find valid save-restore pair for r11
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2907C: using guessed type int dword_2907C;
// 29080: using guessed type int dword_29080;
// 29084: using guessed type int dword_29084;
// 2A5F0: using guessed type int dword_2A5F0;

//----- (0000AD74) --------------------------------------------------------
int __fastcall sub_AD74(int a1, int a2, int a3)
{
  int v3; // r6@1
  int v4; // r4@1
  signed int v5; // r1@1
  int v6; // r8@1
  int i; // r3@1
  int v8; // r5@1
  char *v9; // r3@2
  int v10; // r2@3
  int v11; // r5@4
  int v12; // r0@5
  signed int v14; // r2@9
  char *v15; // r0@13
  char *v16; // r0@14
  int v17; // r5@14

  v3 = a2;
  v4 = a1;
  v5 = *(_DWORD *)(a1 + 12);
  v6 = a3;
  i = *(_DWORD *)(a1 + 4);
  v8 = v5 + 1;
  if ( v5 + 1 <= i || (v14 = *(_DWORD *)(a1 + 8), v14 < 0) )
  {
    v9 = *(char **)a1;
  }
  else
  {
    if ( v14 )
    {
      for ( i = v14 + v5 / v14 * v14; v8 > i; i = (i + v8) / 2 )
        ;
    }
    else if ( i || (i = 2, v8 > 2) )
    {
      do
      {
        i *= 2;
        if ( v8 <= i )
          break;
        i *= 2;
      }
      while ( v8 > i );
    }
    v15 = *(char **)a1;
    *(_DWORD *)(v4 + 4) = i;
    if ( v15 )
    {
      v16 = (char *)realloc(v15, 16 * i);
      v17 = *(_DWORD *)(v4 + 12);
      v9 = v16;
      *(_DWORD *)v4 = v16;
      v8 = v17 + 1;
    }
    else
    {
      v9 = (char *)malloc(16 * i);
      *(_DWORD *)v4 = v9;
    }
  }
  *(_DWORD *)(v4 + 12) = v8;
  v10 = v8 - v3 - 1;
  *(_DWORD *)(v4 + 16) = v9;
  if ( v10 > 0 )
  {
    v12 = 16 * (v3 + 1);
    v11 = v12 - 16;
    memmove(&v9[v12], &v9[v12 - 16], 16 * v10);
    v9 = *(char **)v4;
  }
  else
  {
    v11 = 16 * v3;
  }
  if ( &v9[v11] )
    sub_16FA0(&v9[v11], v6, v10, (int)v9);
  return v3;
}
// AD74: could not find valid save-restore pair for r4
// AD74: could not find valid save-restore pair for r5
// AD74: could not find valid save-restore pair for r6
// AD74: could not find valid save-restore pair for r7

//----- (0000AE24) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_AE24(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r6@1
  int v9; // r4@1
  int v10; // r5@2
  int v11; // r0@4
  int v12; // [sp+0h] [bp+0h]@1
  __int64 v13; // [sp+8h] [bp+8h]@1
  int *v14; // [sp+10h] [bp+10h]@1
  int v15; // [sp+14h] [bp+14h]@1

  v13 = *(_QWORD *)&v5;
  v8 = a1;
  v14 = &v12;
  v15 = v7;
  *(_QWORD *)&v12 = *(_QWORD *)&a4;
  v9 = *(_DWORD *)(a1 + 12) - 1;
  if ( v9 >= 0 )
  {
    v10 = 16 * v9;
    do
    {
      --v9;
      v11 = *(_DWORD *)v8 + v10;
      v10 -= 16;
      sub_7FBC(v11, a2, a3, a4);
      a4 = v9 + 1;
    }
    while ( v9 != -1 );
  }
  *(_DWORD *)(v8 + 12) = 0;
}
// AE24: could not find valid save-restore pair for r4
// AE24: could not find valid save-restore pair for r5
// AE24: could not find valid save-restore pair for r6
// AE24: could not find valid save-restore pair for r7
// AE24: variables would overlap: r3.4 and r3.8
// AE24: variables would overlap: r4.4 and r3.8
// AE24: variables would overlap: r5.4 and r5.8
// AE24: variables would overlap: r6.4 and r5.8

//----- (0000AE58) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_AE58(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// AE58: could not find valid save-restore pair for r4
// AE58: could not find valid save-restore pair for r7
// AE58: variables would overlap: r3.4 and r3.8
// AE58: variables would overlap: r4.4 and r3.8

//----- (0000AE80) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_AE80(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r1@1
  int v8; // r2@1
  int v9; // r3@1
  int v10; // r3@1
  int v11; // r1@1
  int v12; // r2@1
  int v14; // [sp+0h] [bp+0h]@1
  int *v15; // [sp+8h] [bp+8h]@1
  int v16; // [sp+Ch] [bp+Ch]@1

  v15 = &v14;
  v16 = v5;
  *(_QWORD *)&v14 = *(_QWORD *)&a4;
  v6 = a1;
  sub_AE24(a1, a2, a3, a4);
  sub_AE58(v6, v7, v8, v9);
  v10 = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 16) = *(_DWORD *)v6;
  sub_AE58(v6, v11, v12, v10);
  return v6;
}
// AE80: could not find valid save-restore pair for r4
// AE80: could not find valid save-restore pair for r7
// AE80: variables would overlap: r3.4 and r3.8
// AE80: variables would overlap: r4.4 and r3.8

//----- (0000AEA8) --------------------------------------------------------
int __fastcall sub_AEA8(int a1, int a2, int a3)
{
  int v3; // r6@1
  int v4; // r4@1
  signed int v5; // r1@1
  int v6; // r8@1
  int i; // r3@1
  int v8; // r5@1
  char *v9; // r1@2
  int v10; // r2@3
  int v11; // r5@4
  int v12; // r0@5
  int v13; // r5@6
  int v14; // r2@7
  int v15; // r3@7
  signed int v17; // r2@9
  char *v18; // r0@13
  char *v19; // r0@14
  int v20; // r5@14

  v3 = a2;
  v4 = a1;
  v5 = *(_DWORD *)(a1 + 12);
  v6 = a3;
  i = *(_DWORD *)(a1 + 4);
  v8 = v5 + 1;
  if ( v5 + 1 <= i || (v17 = *(_DWORD *)(a1 + 8), v17 < 0) )
  {
    v9 = *(char **)a1;
  }
  else
  {
    if ( v17 )
    {
      for ( i = v17 + v5 / v17 * v17; v8 > i; i = (i + v8) / 2 )
        ;
    }
    else if ( i || (i = 1, v8 > 1) )
    {
      do
      {
        i *= 2;
        if ( v8 <= i )
          break;
        i *= 2;
      }
      while ( v8 > i );
    }
    v18 = *(char **)a1;
    *(_DWORD *)(v4 + 4) = i;
    if ( v18 )
    {
      v19 = (char *)realloc(v18, 32 * i);
      v20 = *(_DWORD *)(v4 + 12);
      v9 = v19;
      *(_DWORD *)v4 = v19;
      v8 = v20 + 1;
    }
    else
    {
      v9 = (char *)malloc(32 * i);
      *(_DWORD *)v4 = v9;
    }
  }
  *(_DWORD *)(v4 + 12) = v8;
  v10 = v8 - v3 - 1;
  *(_DWORD *)(v4 + 16) = v9;
  if ( v10 > 0 )
  {
    v12 = 32 * (v3 + 1);
    v11 = v12 - 32;
    memmove(&v9[v12], &v9[v12 - 32], 32 * v10);
    v9 = *(char **)v4;
  }
  else
  {
    v11 = 32 * v3;
  }
  v13 = (int)&v9[v11];
  if ( v13 )
  {
    sub_16FA0((_DWORD *)v13, v6, v10, i);
    sub_16FA0((_DWORD *)(v13 + 16), v6 + 16, v14, v15);
  }
  return v3;
}
// AEA8: could not find valid save-restore pair for r4
// AEA8: could not find valid save-restore pair for r5
// AEA8: could not find valid save-restore pair for r6
// AEA8: could not find valid save-restore pair for r7

//----- (0000AF70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_AF70(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// AF70: could not find valid save-restore pair for r4
// AF70: could not find valid save-restore pair for r7
// AF70: variables would overlap: r3.4 and r3.8
// AF70: variables would overlap: r4.4 and r3.8

//----- (0000AF98) --------------------------------------------------------
void __fastcall sub_AF98(int a1, int a2, int a3, int a4)
{
  int v4; // r8@1
  int v5; // r4@1
  int v6; // r5@2
  int v7; // r6@4
  int v8; // r1@4
  int v9; // r2@4
  int v10; // r3@4

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 12) - 1;
  if ( v5 >= 0 )
  {
    v6 = 32 * v5;
    do
    {
      --v5;
      v7 = *(_DWORD *)v4 + v6;
      v6 -= 32;
      sub_7FBC(v7 + 16, a2, a3, a4);
      sub_7FBC(v7, v8, v9, v10);
      a4 = v5 + 1;
    }
    while ( v5 != -1 );
  }
  *(_DWORD *)(v4 + 12) = 0;
}
// AF98: could not find valid save-restore pair for r4
// AF98: could not find valid save-restore pair for r5
// AF98: could not find valid save-restore pair for r6
// AF98: could not find valid save-restore pair for r7

//----- (0000AFDC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_AFDC(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r1@1
  int v8; // r2@1
  int v9; // r3@1
  int v10; // r3@1
  int v11; // r1@1
  int v12; // r2@1
  int v14; // [sp+0h] [bp+0h]@1
  int *v15; // [sp+8h] [bp+8h]@1
  int v16; // [sp+Ch] [bp+Ch]@1

  v15 = &v14;
  v16 = v5;
  *(_QWORD *)&v14 = *(_QWORD *)&a4;
  v6 = a1;
  sub_AF98(a1, a2, a3, a4);
  sub_AF70(v6, v7, v8, v9);
  v10 = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 16) = *(_DWORD *)v6;
  sub_AF70(v6, v11, v12, v10);
  return v6;
}
// AFDC: could not find valid save-restore pair for r4
// AFDC: could not find valid save-restore pair for r7
// AFDC: variables would overlap: r3.4 and r3.8
// AFDC: variables would overlap: r4.4 and r3.8

//----- (0000B0A4) --------------------------------------------------------
_BYTE *__fastcall sub_B0A4(_BYTE *result, _BYTE *a2)
{
  __int64 v2; // r4@0
  int v3; // lr@0
  bool v4; // zf@1
  _BYTE *v5; // r5@3
  _BYTE *v6; // r4@3
  int v7; // r1@4
  char v8; // r3@9
  _BYTE *v9; // r1@10
  int v10; // t1@11
  __int64 v11; // [sp+0h] [bp+0h]@3
  __int64 *v12; // [sp+8h] [bp+8h]@3
  int v13; // [sp+Ch] [bp+Ch]@3

  v4 = a2 == 0;
  if ( a2 )
    v4 = result == 0;
  v11 = v2;
  v5 = a2;
  v6 = result;
  v12 = &v11;
  v13 = v3;
  v7 = v4 != 0;
  if ( !v4 )
  {
    result = memset(result, v7, 0x100u);
    v8 = *v5;
    if ( *v5 )
    {
      v9 = v5;
      do
      {
        v6[v8] = 1;
        v10 = (v9++)[1];
        v8 = v10;
      }
      while ( v10 );
    }
  }
  return result;
}
// B0A4: could not find valid save-restore pair for r4
// B0A4: could not find valid save-restore pair for r5
// B0A4: could not find valid save-restore pair for r7

//----- (0000B0E8) --------------------------------------------------------
_DWORD *__fastcall sub_B0E8(_DWORD *result)
{
  *result = &off_28750;
  return result;
}
// 28750: using guessed type void *;

//----- (0000B104) --------------------------------------------------------
signed int sub_B104()
{
  return 1;
}

//----- (0000B114) --------------------------------------------------------
int sub_B114()
{
  return dword_29090;
}
// 29090: using guessed type int dword_29090;

//----- (0000B12C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_B12C(int result, int a2, char *a3, int a4)
{
  int v5; // lr@0
  int v6; // r2@4
  __int64 v7; // [sp+0h] [bp+0h]@1
  __int64 *v8; // [sp+8h] [bp+8h]@1
  int v9; // [sp+Ch] [bp+Ch]@1

  *(_DWORD *)(result + 12) = a2;
  v7 = *(_QWORD *)&a4;
  v8 = &v7;
  v9 = v5;
  *(_BYTE *)(result + 8) = 0;
  if ( !a3 )
    a3 = "";
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 16) = a3;
  if ( a4 << 31 >= 0 )
  {
    v6 = dword_2A6BC;
    dword_2A6BC = result;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(result + 4) = v6;
  if ( dword_2A6C0 )
    result = (*(int (__cdecl **)(int))(*(_DWORD *)result + 40))(result);
  return result;
}
// B12C: could not find valid save-restore pair for r4
// B12C: could not find valid save-restore pair for r7
// B12C: variables would overlap: r3.4 and r3.8
// B12C: variables would overlap: r4.4 and r3.8
// 2A6BC: using guessed type int dword_2A6BC;
// 2A6C0: using guessed type int dword_2A6C0;

//----- (0000B178) --------------------------------------------------------
int __fastcall sub_B178(int result)
{
  int v1; // lr@0
  _DWORD *v2; // [sp+0h] [bp+0h]@1
  int v3; // [sp+4h] [bp+4h]@1

  v2 = &v2;
  v3 = v1;
  if ( dword_2A6C0 )
    result = (**(int (__fastcall ***)(_DWORD, _DWORD))dword_2A6C0)(dword_2A6C0, result);
  return result;
}
// B178: could not find valid save-restore pair for r7
// 2A6C0: using guessed type int dword_2A6C0;

//----- (0000B198) --------------------------------------------------------
int __fastcall sub_B198(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(a1 + 12);
}

//----- (0000B1A8) --------------------------------------------------------
_BOOL4 __fastcall sub_B1A8(int a1, int a2)
{
  int *v3; // [sp+0h] [bp+0h]@1

  v3 = (int *)&v3;
  return (a2 & *(_DWORD *)(a1 + 20)) != 0;
}

//----- (0000B1C0) --------------------------------------------------------
int __fastcall sub_B1C0(int result, int a2)
{
  *(_DWORD *)(result + 20) |= a2;
  return result;
}

//----- (0000B1D4) --------------------------------------------------------
int __fastcall sub_B1D4(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(a1 + 16);
}

//----- (0000B1E4) --------------------------------------------------------
int __fastcall sub_B1E4(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_BYTE *)(a1 + 8);
}

//----- (0000B204) --------------------------------------------------------
_DWORD *__fastcall sub_B204(_DWORD *result)
{
  *result = &off_28750;
  return result;
}
// 28750: using guessed type void *off_28750;

//----- (0000B220) --------------------------------------------------------
signed int sub_B220()
{
  return 1;
}

//----- (0000B230) --------------------------------------------------------
int __fastcall sub_B230(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_BYTE *)(a1 + 32) & 1;
}

//----- (0000B248) --------------------------------------------------------
_BOOL4 __fastcall sub_B248(int a1, int a2)
{
  int *v3; // [sp+0h] [bp+0h]@1

  v3 = (int *)&v3;
  return (a2 & *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20)) != 0;
}

//----- (0000B264) --------------------------------------------------------
_BOOL4 __fastcall sub_B264(int a1, int a2)
{
  return sub_B248(a1 - 24, a2);
}

//----- (0000B26C) --------------------------------------------------------
int __fastcall sub_B26C(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16);
}

//----- (0000B280) --------------------------------------------------------
int __fastcall sub_B280(int result, int a2)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  *(_DWORD *)(*(_DWORD *)(result + 28) + 20) |= a2;
  return result;
}

//----- (0000B298) --------------------------------------------------------
int __fastcall sub_B298(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_BYTE *)(*(_DWORD *)(a1 + 28) + 8);
}

//----- (0000B2AC) --------------------------------------------------------
int __fastcall sub_B2AC(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(*(_DWORD *)(a1 + 28) + 12);
}

//----- (0000B2C0) --------------------------------------------------------
int __fastcall sub_B2C0(int a1)
{
  return sub_B2AC(a1 - 24);
}

//----- (0000B2C8) --------------------------------------------------------
int sub_B2C8()
{
  return 0;
}

//----- (0000B2D8) --------------------------------------------------------
int __fastcall sub_B2D8(int result)
{
  int v1; // lr@0
  _DWORD *v2; // [sp+0h] [bp+0h]@1
  int v3; // [sp+4h] [bp+4h]@1

  v2 = &v2;
  v3 = v1;
  if ( dword_2A6C0 )
    result = (**(int (__fastcall ***)(_DWORD, _DWORD))dword_2A6C0)(dword_2A6C0, result);
  return result;
}
// B2D8: could not find valid save-restore pair for r7
// 2A6C0: using guessed type int dword_2A6C0;

//----- (0000B2F8) --------------------------------------------------------
int __fastcall sub_B2F8(int a1, int a2)
{
  int v2; // lr@0
  _DWORD *v4; // [sp+0h] [bp+0h]@1
  int v5; // [sp+4h] [bp+4h]@1

  v4 = &v4;
  v5 = v2;
  return (*(int (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 28) + 56))(*(_DWORD *)(a1 + 28), a2);
}
// B2F8: could not find valid save-restore pair for r7

//----- (0000B30C) --------------------------------------------------------
int __fastcall sub_B30C(int a1, int a2)
{
  return sub_B2F8(a1 - 24, a2);
}

//----- (0000B314) --------------------------------------------------------
int __fastcall sub_B314(int a1, int a2)
{
  int v2; // lr@0
  _DWORD *v4; // [sp+0h] [bp+0h]@1
  int v5; // [sp+4h] [bp+4h]@1

  v4 = &v4;
  v5 = v2;
  return (*(int (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 28) + 60))(*(_DWORD *)(a1 + 28), a2);
}
// B314: could not find valid save-restore pair for r7

//----- (0000B328) --------------------------------------------------------
int __fastcall sub_B328(int a1, int a2)
{
  return sub_B314(a1 - 24, a2);
}

//----- (0000B330) --------------------------------------------------------
int __fastcall sub_B330(int a1, int a2)
{
  int v2; // lr@0
  _DWORD *v4; // [sp+0h] [bp+0h]@1
  int v5; // [sp+4h] [bp+4h]@1

  v4 = &v4;
  v5 = v2;
  return (*(int (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 28) + 64))(*(_DWORD *)(a1 + 28), a2);
}
// B330: could not find valid save-restore pair for r7

//----- (0000B344) --------------------------------------------------------
int __fastcall sub_B344(int a1, int a2)
{
  return sub_B330(a1 - 24, a2);
}

//----- (0000B34C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_B34C(void *a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = *(_QWORD *)&a4;
  v6 = a1;
  v9 = &v8;
  v10 = v5;
  *(_DWORD *)a1 = &off_28750;
  operator delete(a1);
  return v6;
}
// B34C: could not find valid save-restore pair for r4
// B34C: could not find valid save-restore pair for r7
// B34C: variables would overlap: r3.4 and r3.8
// B34C: variables would overlap: r4.4 and r3.8
// 28750: using guessed type void *off_28750;

//----- (0000B370) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_B370(void *a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = *(_QWORD *)&a4;
  v6 = a1;
  v9 = &v8;
  v10 = v5;
  *(_DWORD *)a1 = &off_28750;
  operator delete(a1);
  return v6;
}
// B370: could not find valid save-restore pair for r4
// B370: could not find valid save-restore pair for r7
// B370: variables would overlap: r3.4 and r3.8
// B370: variables would overlap: r4.4 and r3.8
// 28750: using guessed type void *off_28750;

//----- (0000B394) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_B394(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@1
  int result; // r0@3
  __int64 v9; // [sp+0h] [bp+0h]@1
  __int64 *v10; // [sp+8h] [bp+8h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  v9 = *(_QWORD *)&a4;
  v6 = a1;
  v10 = &v9;
  v11 = v5;
  v7 = *(void **)(a1 + 36);
  *(_DWORD *)v6 = &off_287C8;
  *(_DWORD *)(v6 + 24) = &off_28820;
  if ( v7 )
  {
    operator delete(v7);
    *(_DWORD *)(v6 + 36) = 0;
  }
  result = v6;
  *(_DWORD *)v6 = &off_28750;
  return result;
}
// B394: could not find valid save-restore pair for r4
// B394: could not find valid save-restore pair for r7
// B394: variables would overlap: r3.4 and r3.8
// B394: variables would overlap: r4.4 and r3.8
// 28750: using guessed type void *off_28750;
// 287C8: using guessed type void *;
// 28820: using guessed type void *;

//----- (0000B3D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_B3D0(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = (void *)a1;
  sub_B394(a1, a2, a3, a4);
  operator delete(v6);
  return v6;
}
// B3D0: could not find valid save-restore pair for r4
// B3D0: could not find valid save-restore pair for r7
// B3D0: variables would overlap: r3.4 and r3.8
// B3D0: variables would overlap: r4.4 and r3.8

//----- (0000B3EC) --------------------------------------------------------
int __fastcall sub_B3EC(int result)
{
  int v1; // lr@0
  int v8; // [sp+8h] [bp+0h]@1
  float v9; // [sp+Ch] [bp+4h]@8
  int v10; // [sp+10h] [bp+8h]@9
  int v11; // [sp+44h] [bp+3Ch]@1

  v11 = v1;
  _R4 = result;
  _R7 = &v8;
  __asm
  {
    VLDR            S15, [R0,#0x2C]
    VSTR            S0, [R7,#0x40+var_3C]
    VCMP.F32        S15, S0
    VMRS            APSR_nzcv, FPSCR
  }
  if ( !_ZF )
  {
    if ( (*(int (**)(void))(*(_DWORD *)result + 12))()
      && dword_2CB84
      && !(*(int (**)(void))(*(_DWORD *)dword_2CB84 + 112))() )
    {
      __asm { VLDR            S0, [R7,#0x40+var_3C] }
      result = (*(int (**)(void))(*(_DWORD *)dword_2CB84 + 124))();
    }
    else
    {
      result = (*(int (__fastcall **)(int, float *))(*(_DWORD *)_R4 + 68))(_R4, &v9);
      __asm
      {
        VLDR            S15, [R7,#0x40+var_3C]
        VLDR            S16, [R4,#0x2C]
        VCVTR.S32.F32   S14, S15
        VSTR            S15, [R4,#0x2C]
        VSTR            S14, [R4,#0x30]
      }
      if ( !_NF )
      {
        __asm
        {
          VCVT.F64.F32    D16, S15
          VSTR            D16, [SP,#0x48+var_48]
        }
        sub_12440((char *)&v10, 0x20u, "%f", *(_DWORD *)(_R4 + 20) << 19);
        __asm { VMOV.F32        S0, S16 }
        result = (*(int (__fastcall **)(int, int *))(*(_DWORD *)_R4 + 72))(_R4, &v10);
      }
    }
  }
  return result;
}
// 2CB84: using guessed type int dword_2CB84;

//----- (0000B4A4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_B4A4(int result, int a2)
{
  int v2; // r4@0
  int v3; // r5@0 OVERLAPPED
  int v5; // r7@0
  int v6; // lr@0
  int (__fastcall *v14)(int, int *); // r3@5
  int v17; // r3@7
  int v18; // [sp+0h] [bp+0h]@1
  int v19; // [sp+8h] [bp+8h]@8
  int v20; // [sp+34h] [bp+34h]@1
  __int64 v21; // [sp+38h] [bp+38h]@1
  int v22; // [sp+40h] [bp+40h]@1
  int v23; // [sp+44h] [bp+44h]@1

  v22 = v5;
  v23 = v6;
  v21 = *(_QWORD *)&v3;
  _R5 = a2;
  v20 = v2;
  _R4 = result;
  _R7 = &v18;
  if ( *(_DWORD *)(result + 48) != a2 )
  {
    if ( (*(int (**)(void))(*(_DWORD *)result + 12))()
      && dword_2CB84
      && !(*(int (**)(void))(*(_DWORD *)dword_2CB84 + 112))() )
    {
      result = (*(int (**)(void))(*(_DWORD *)dword_2CB84 + 120))();
    }
    else
    {
      __asm { VMOV            S14, R5 }
      v14 = *(int (__fastcall **)(int, int *))(*(_DWORD *)_R4 + 68);
      __asm
      {
        VCVT.F32.S32    S15, S14
        VMOV            R2, S15
      }
      v18 = _R2;
      result = v14(_R4, &v18);
      if ( result )
      {
        __asm
        {
          VLDR            S15, [R7,#0x48+var_48]
          VCVTR.S32.F32   S14, S15
          VMOV            R2, S15
          VMOV            R5, S14
        }
      }
      else
      {
        _R2 = v18;
      }
      v17 = *(_DWORD *)(_R4 + 20);
      __asm { VLDR            S16, [R4,#0x2C] }
      *(_DWORD *)(_R4 + 48) = _R5;
      *(_DWORD *)(_R4 + 44) = _R2;
      if ( !(v17 & 0x1000) )
      {
        sub_12440((char *)&v19, 0x20u, "%d", _R5, v18);
        __asm { VMOV.F32        S0, S16 }
        result = (*(int (__fastcall **)(int, int *))(*(_DWORD *)_R4 + 72))(_R4, &v19);
      }
    }
  }
  return result;
}
// B4A4: could not find valid save-restore pair for r4
// B4A4: could not find valid save-restore pair for r5
// B4A4: could not find valid save-restore pair for r6
// B4A4: could not find valid save-restore pair for r7
// B4A4: variables would overlap: r5.4 and r5.8
// B4A4: variables would overlap: r6.4 and r5.8
// 2CB84: using guessed type int dword_2CB84;

//----- (0000B574) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_B574(int a1, const char *a2)
{
  int v2; // r4@0
  int v3; // r5@0 OVERLAPPED
  int v5; // r7@0
  int v6; // lr@0
  const char *v7; // r5@1
  int result; // r0@6
  int v16; // r3@8
  float v17; // [sp+8h] [bp+0h]@1
  int v18; // [sp+10h] [bp+8h]@7
  int v19; // [sp+3Ch] [bp+34h]@1
  __int64 v20; // [sp+40h] [bp+38h]@1
  int v21; // [sp+48h] [bp+40h]@1
  int v22; // [sp+4Ch] [bp+44h]@1

  v21 = v5;
  v22 = v6;
  v20 = *(_QWORD *)&v3;
  v7 = a2;
  v19 = v2;
  _R4 = a1;
  _R7 = &v17;
  if ( (*(int (**)(void))(*(_DWORD *)a1 + 12))() && dword_2CB84 && !(*(int (**)(void))(*(_DWORD *)dword_2CB84 + 112))() )
  {
    result = (*(int (**)(void))(*(_DWORD *)dword_2CB84 + 116))();
  }
  else
  {
    __asm { VLDR            S16, [R4,#0x2C] }
    if ( v7 )
    {
      _R0 = COERCE_UNSIGNED_INT64(strtod(v7, 0));
      __asm
      {
        VMOV            D16, R0, R1
        VCVT.F32.F64    S15, D16
        VSTR            S15, [R7,#0x48+var_48]
      }
    }
    else
    {
      v17 = 0.0;
    }
    result = (*(int (__fastcall **)(int, float *))(*(_DWORD *)_R4 + 68))(_R4, &v17);
    if ( result )
    {
      __asm { VLDR            S15, [R7,#0x48+var_48] }
      v7 = (const char *)&v18;
      __asm
      {
        VCVT.F64.F32    D16, S15
        VSTR            D16, [SP,#0x50+var_50]
      }
      result = sub_12440((char *)&v18, 0x20u, "%f");
    }
    __asm
    {
      VLDR            S15, [R7,#0x48+var_48]
      VCVTR.S32.F32   S14, S15
    }
    v16 = *(_DWORD *)(_R4 + 20) << 19;
    __asm
    {
      VSTR            S15, [R4,#0x2C]
      VSTR            S14, [R4,#0x30]
    }
    if ( !_NF )
    {
      __asm { VMOV.F32        S0, S16 }
      result = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)_R4 + 72))(_R4, v7);
    }
  }
  return result;
}
// B574: could not find valid save-restore pair for r4
// B574: could not find valid save-restore pair for r5
// B574: could not find valid save-restore pair for r6
// B574: could not find valid save-restore pair for r7
// B574: variables would overlap: r5.4 and r5.8
// B574: variables would overlap: r6.4 and r5.8
// 2CB84: using guessed type int dword_2CB84;

//----- (0000B648) --------------------------------------------------------
int __fastcall sub_B648(int a1, int a2, char *s, int a4, int a5, char a6, char a7, int a8)
{
  int v8; // r10@1
  int v9; // r6@1
  int v10; // r4@1
  char *v15; // r0@1
  unsigned int v16; // r0@3
  void *v17; // r0@3
  const char *v18; // r0@3

  v8 = a4;
  v9 = a2;
  v10 = a1;
  __asm
  {
    VMOV.F32        S17, S0
    VMOV.F32        S16, S1
  }
  *(_DWORD *)(a1 + 28) = a1;
  v15 = s;
  if ( !s )
    v15 = "";
  *(_DWORD *)(v10 + 32) = v15;
  v16 = strlen(v15) + 1;
  *(_DWORD *)(v10 + 40) = v16;
  v17 = (void *)sub_1E9D4(v16);
  *(_DWORD *)(v10 + 36) = v17;
  memcpy(v17, *(const void **)(v10 + 32), *(_DWORD *)(v10 + 40));
  __asm { VSTR            S17, [R4,#0x38] }
  *(_BYTE *)(v10 + 52) = a6;
  __asm { VSTR            S16, [R4,#0x40] }
  v18 = *(const char **)(v10 + 36);
  *(_BYTE *)(v10 + 60) = a7;
  *(_DWORD *)(v10 + 68) = a8;
  _R0 = COERCE_UNSIGNED_INT64(strtod(v18, 0));
  __asm
  {
    VMOV            D16, R0, R1
    VCVT.F32.F64    S15, D16
    VCVTR.S32.F32   S14, S15
    VSTR            S15, [R4,#0x2C]
    VSTR            S14, [R4,#0x30]
  }
  return sub_B12C(v10, v9, (char *)a5, v8);
}
// B648: could not find valid save-restore pair for r4
// B648: could not find valid save-restore pair for r5
// B648: could not find valid save-restore pair for r6
// B648: could not find valid save-restore pair for r7
// B648: could not find valid save-restore pair for r8
// B648: could not find valid save-restore pair for r9
// B648: could not find valid save-restore pair for r10
// B648: could not find valid save-restore pair for r11

//----- (0000B708) --------------------------------------------------------
int __fastcall sub_B708(int a1, const char *a2)
{
  int v2; // lr@0
  const char *v3; // r5@1
  int v4; // r4@1
  signed int v9; // r8@2
  void *v10; // r0@2
  void (__fastcall *v11)(int, int *); // r3@4
  int v13; // [sp+0h] [bp+0h]@1
  int v14; // [sp+1Ch] [bp+1Ch]@1

  v3 = a2;
  v4 = a1;
  v14 = v2;
  __asm { VMOV.F32        S16, S0 }
  memcpy(&v13, *(const void **)(a1 + 36), *(_DWORD *)(a1 + 40));
  if ( v3 )
  {
    v9 = strlen(v3) + 1;
    v10 = *(void **)(v4 + 36);
    if ( v9 > *(_DWORD *)(v4 + 40) )
    {
      if ( v10 )
        operator delete(v10);
      v10 = (void *)sub_1E9D4(v9);
      *(_DWORD *)(v4 + 40) = v9;
      *(_DWORD *)(v4 + 36) = v10;
    }
    memcpy(v10, v3, v9);
  }
  else
  {
    **(_BYTE **)(v4 + 36) = 0;
  }
  v11 = *(void (__fastcall **)(int, int *))(v4 + 68);
  if ( v11 )
  {
    __asm { VMOV.F32        S0, S16 }
    v11(v4 + 24, &v13);
  }
  __asm { VMOV.F32        S0, S16 }
  return (*(int (**)(void))(*(_DWORD *)dword_2CB84 + 80))();
}
// 2CB84: using guessed type int dword_2CB84;

//----- (0000B7B8) --------------------------------------------------------
int __fastcall sub_B7B8(int result, int a2)
{
  int v2; // lr@0
  int (__fastcall *v3)(int); // r3@2
  int (*v4)(void); // r3@5
  _DWORD *v5; // [sp+0h] [bp+0h]@1
  int v6; // [sp+4h] [bp+4h]@1

  v5 = &v5;
  v6 = v2;
  if ( *(_BYTE *)(result + 32) & 2 )
  {
    v3 = *(int (__fastcall **)(int))(result + 24);
    if ( v3 )
      result = v3(a2);
  }
  else if ( *(_BYTE *)(result + 32) & 4 )
  {
    result = *(_DWORD *)(result + 24);
    if ( result )
      result = (**(int (***)(void))result)();
  }
  else
  {
    v4 = *(int (**)(void))(result + 24);
    if ( v4 )
      result = v4();
  }
  return result;
}
// B7B8: could not find valid save-restore pair for r7

//----- (0000B7F0) --------------------------------------------------------
int __fastcall sub_B7F0(int _R0, int _R1)
{
  int v2; // r3@1
  int *v8; // [sp+0h] [bp+0h]@1

  v8 = (int *)&v8;
  v2 = *(_BYTE *)(_R0 + 52);
  if ( *(_BYTE *)(_R0 + 52) )
  {
    __asm
    {
      VLDR            S15, [R0,#0x38]
      VLDR            S14, [R1]
      VCMPE.F32       S14, S15
      VMRS            APSR_nzcv, FPSCR
    }
    if ( _NF )
      goto LABEL_6;
  }
  v2 = *(_BYTE *)(_R0 + 60);
  if ( *(_BYTE *)(_R0 + 60) )
  {
    __asm
    {
      VLDR            S15, [R0,#0x40]
      VLDR            S14, [R1]
      VCMPE.F32       S14, S15
      VMRS            APSR_nzcv, FPSCR
    }
    if ( (unsigned __int8)(_NF ^ _VF) | _ZF )
      return 0;
LABEL_6:
    __asm { VSTR            S15, [R1] }
  }
  return v2;
}

//----- (0000B838) --------------------------------------------------------
int __fastcall sub_B838(int result, char *a2)
{
  char *v2; // r5@1
  int v3; // r2@4
  int v4; // r4@6
  int v5; // r5@7
  int v6; // r3@7
  int v7; // r0@7

  v2 = a2;
  if ( dword_2CB84 && !byte_2A6C8 )
  {
    v3 = *(_DWORD *)dword_2CB84;
    dword_2A6CC = result;
    byte_2A6C8 = 1;
    dword_29090 = (*(int (__fastcall **)(int))(v3 + 20))(dword_2CB84);
    if ( !v2 )
      v2 = algn_2A6C4;
    v4 = dword_2A6BC;
    dword_2A6C0 = (int)v2;
    if ( dword_2A6BC )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 4);
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v4 + 16))(v4, dword_2A6CC);
        v6 = *(_DWORD *)v4;
        v7 = v4;
        v4 = v5;
        (*(void (__fastcall **)(int))(v6 + 40))(v7);
      }
      while ( v5 );
    }
    result = (*(int (**)(void))(*(_DWORD *)dword_2CB84 + 132))();
    dword_2A6BC = 0;
  }
  return result;
}
// B838: could not find valid save-restore pair for r4
// B838: could not find valid save-restore pair for r5
// B838: could not find valid save-restore pair for r6
// B838: could not find valid save-restore pair for r7
// 29090: using guessed type int dword_29090;
// 2A6BC: using guessed type int dword_2A6BC;
// 2A6C0: using guessed type int dword_2A6C0;
// 2A6C8: using guessed type char byte_2A6C8;
// 2A6CC: using guessed type int dword_2A6CC;
// 2CB84: using guessed type int dword_2CB84;

//----- (0000B8D4) --------------------------------------------------------
int sub_B8D4()
{
  __int64 v0; // r4@0
  int v1; // lr@0
  int result; // r0@1
  int v3; // [sp+0h] [bp+0h]@1
  int *v4; // [sp+8h] [bp+8h]@1
  int v5; // [sp+Ch] [bp+Ch]@1

  v4 = &v3;
  v5 = v1;
  *(_QWORD *)&v3 = v0;
  result = dword_2CB84;
  if ( dword_2CB84 )
  {
    if ( byte_2A6C8 )
    {
      result = (*(int (**)(void))(*(_DWORD *)dword_2CB84 + 32))();
      dword_29090 = -1;
      byte_2A6C8 = 0;
    }
  }
  return result;
}
// B8D4: could not find valid save-restore pair for r4
// B8D4: could not find valid save-restore pair for r5
// B8D4: could not find valid save-restore pair for r7
// 29090: using guessed type int dword_29090;
// 2A6C8: using guessed type char byte_2A6C8;
// 2CB84: using guessed type int dword_2CB84;

//----- (0000BB6C) --------------------------------------------------------
char *__fastcall sub_BB6C(_DWORD *a1, const char *a2)
{
  const char *v2; // r8@1
  _DWORD *v3; // r5@1
  signed int v4; // r4@1
  signed int *v5; // r10@1
  int v6; // r6@1
  const char *v7; // r0@4
  char *result; // r0@9

  v2 = a2;
  v3 = a1;
  v4 = 1;
  v5 = a1;
  v6 = *a1;
  if ( *a1 > 1 )
  {
    while ( 1 )
    {
      v7 = "";
      if ( *v5 > v4 )
        v7 = (const char *)v3[259];
      if ( !sub_11A70(v7, v2) )
        break;
      ++v4;
      ++v3;
      if ( v4 == v6 )
        goto LABEL_10;
    }
    if ( v6 <= v4 + 1 )
    {
      result = "";
    }
    else if ( v4 + 1 < *v5 )
    {
      result = (char *)v5[v4 + 259];
    }
    else
    {
      result = "";
    }
  }
  else
  {
LABEL_10:
    result = 0;
  }
  return result;
}
// BB6C: could not find valid save-restore pair for r4
// BB6C: could not find valid save-restore pair for r5
// BB6C: could not find valid save-restore pair for r6
// BB6C: could not find valid save-restore pair for r7
// BB6C: could not find valid save-restore pair for r8
// BB6C: could not find valid save-restore pair for r9

//----- (0000C09C) --------------------------------------------------------
char *__fastcall sub_C09C(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r6@1
  int v5; // r8@1
  char *result; // r0@2

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( dword_2CB84 )
  {
    result = (char *)(*(int (**)(void))(*(_DWORD *)dword_2CB84 + 48))();
    if ( !result )
    {
      *(_DWORD *)(v3 + 4) = &unk_2A7D4;
      *(_DWORD *)v3 = &unk_2A7EC;
      goto LABEL_7;
    }
  }
  else
  {
    result = (char *)&unk_2A7D4;
  }
  *(_DWORD *)(v3 + 4) = result;
  *(_DWORD *)v3 = result + 24;
  if ( (_UNKNOWN *)(result + 24) != &unk_2A7EC )
    return result;
LABEL_7:
  if ( dword_2CB84 )
  {
    if ( v5 )
    {
LABEL_9:
      byte_29094 = 0;
      return result;
    }
LABEL_10:
    result = (char *)Warning("ConVarRef %s doesn't point to an existing ConVar\n", v4);
    goto LABEL_9;
  }
  if ( byte_29094 )
  {
    if ( v5 )
      goto LABEL_9;
    goto LABEL_10;
  }
  return result;
}
// C09C: could not find valid save-restore pair for r4
// C09C: could not find valid save-restore pair for r5
// C09C: could not find valid save-restore pair for r6
// C09C: could not find valid save-restore pair for r7
// 365C: using guessed type int Warning(const char *, ...);
// 29094: using guessed type char byte_29094;
// 2CB84: using guessed type int dword_2CB84;

//----- (0000C148) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_C148(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  sub_C09C(a1, a2, 0);
  return v6;
}
// C148: could not find valid save-restore pair for r4
// C148: could not find valid save-restore pair for r7
// C148: variables would overlap: r3.4 and r3.8
// C148: variables would overlap: r4.4 and r3.8

//----- (0000C1A4) --------------------------------------------------------
_BOOL4 __fastcall sub_C1A4(_DWORD *a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *a1 != (_DWORD)&unk_2A7EC;
}

//----- (0000C1C8) --------------------------------------------------------
int __fastcall sub_C1C8(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r5@1
  int result; // r0@18

  v3 = a1;
  v4 = (*(int (__cdecl **)(int, signed int, int))(*(_DWORD *)a1 + 12))(a1, 4, a3);
  if ( v4 )
  {
    v4 = 1;
    ConMsg(" game");
  }
  if ( (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v3 + 12))(v3, 8) )
  {
    v4 = 1;
    ConMsg(" client");
  }
  if ( (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v3 + 12))(v3, 128) )
  {
    v4 = 1;
    ConMsg(" archive");
  }
  if ( (*(int (__fastcall **)(_DWORD, signed int))(*(_DWORD *)v3 + 12))(v3, 256) )
  {
    v4 = 1;
    ConMsg(" notify");
  }
  if ( (*(int (__fastcall **)(_DWORD, signed int))(*(_DWORD *)v3 + 12))(v3, 64) )
  {
    v4 = 1;
    ConMsg(" singleplayer");
  }
  if ( (*(int (__fastcall **)(_DWORD, signed int))(*(_DWORD *)v3 + 12))(v3, 0x400000) )
  {
    v4 = 1;
    ConMsg(" notconnected");
  }
  if ( (*(int (__fastcall **)(_DWORD, signed int))(*(_DWORD *)v3 + 12))(v3, 0x4000) )
  {
    v4 = 1;
    ConMsg(" cheat");
  }
  if ( (*(int (__fastcall **)(_DWORD, signed int))(*(_DWORD *)v3 + 12))(v3, 0x2000) )
  {
    v4 = 1;
    ConMsg(" replicated");
  }
  if ( (*(int (__fastcall **)(_DWORD, signed int))(*(_DWORD *)v3 + 12))(v3, 0x10000000) )
  {
    ConMsg(" server_can_execute");
    if ( !(*(int (__fastcall **)(_DWORD, signed int))(*(_DWORD *)v3 + 12))(v3, 0x40000000) )
      goto LABEL_23;
LABEL_22:
    ConMsg(" clientcmd_can_execute");
    goto LABEL_23;
  }
  result = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v3 + 12))(v3, 0x40000000);
  if ( result )
    goto LABEL_22;
  if ( v4 )
LABEL_23:
    result = ConMsg("\n");
  return result;
}

//----- (0000C6D8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int (***__fastcall sub_C6D8(int a1, int a2, int a3))(void)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  int v8; // r9@0
  int v9; // lr@0
  int v10; // r8@1
  unsigned int v11; // r4@1
  int (***result)(void); // r0@2
  int (__fastcall *v13)(int, int *); // r3@5
  int *v14; // r6@6
  int v15; // r2@6
  int v16; // r3@6
  int (***v17)(void); // r9@6
  int v18; // r1@7
  int v19; // r2@7
  int v20; // r3@7
  int v21; // [sp+0h] [bp+0h]@7
  int v22; // [sp+10h] [bp+10h]@6
  int v23; // [sp+1014h] [bp+1014h]@1
  __int64 v24; // [sp+1018h] [bp+1018h]@1
  __int64 v25; // [sp+1020h] [bp+1020h]@1
  int v26; // [sp+1028h] [bp+1028h]@1
  int v27; // [sp+102Ch] [bp+102Ch]@1

  v25 = *(_QWORD *)&v6;
  v10 = a3;
  v26 = v8;
  v27 = v9;
  v24 = *(_QWORD *)&v4;
  v23 = v3;
  v11 = ((unsigned int)*(_BYTE *)(a1 + 32) >> 2) & 1;
  if ( v11 )
  {
    result = *(int (****)(void))(a1 + 28);
    if ( result )
      result = (int (***)(void))(**result)();
  }
  else
  {
    v13 = *(int (__fastcall **)(int, int *))(a1 + 28);
    if ( v13 )
    {
      v14 = &v22;
      result = (int (***)(void))v13(a2, &v22);
      v17 = result;
      if ( (signed int)result > 0 )
      {
        do
        {
          sub_16E7C(&v21, (int)v14, v15, v16);
          sub_AD74(v10, *(_DWORD *)(v10 + 12), (int)&v21);
          ++v11;
          sub_7FBC((int)&v21, v18, v19, v20);
          v14 += 16;
        }
        while ( (int (***)(void))v11 != v17 );
        result = (int (***)(void))v11;
      }
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// C6D8: could not find valid save-restore pair for r4
// C6D8: could not find valid save-restore pair for r5
// C6D8: could not find valid save-restore pair for r6
// C6D8: could not find valid save-restore pair for r7
// C6D8: could not find valid save-restore pair for r8
// C6D8: could not find valid save-restore pair for r9
// C6D8: variables would overlap: r5.4 and r5.8
// C6D8: variables would overlap: r6.4 and r5.8
// C6D8: variables would overlap: r7.4 and r7.8
// C6D8: variables would overlap: r8.4 and r7.8

//----- (0000C770) --------------------------------------------------------
signed int __fastcall sub_C770(int a1, int a2)
{
  int v2; // lr@0
  _DWORD *v4; // [sp+0h] [bp+0h]@1
  int v5; // [sp+4h] [bp+4h]@1

  v4 = &v4;
  v5 = v2;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)dword_2CB84 + 24))(dword_2CB84, a2);
  return 1;
}
// C770: could not find valid save-restore pair for r7
// 2CB84: using guessed type int dword_2CB84;

//----- (0000C790) --------------------------------------------------------
void sub_C790()
{
  ;
}

//----- (0000C7A0) --------------------------------------------------------
void sub_C7A0()
{
  sub_C790();
}

//----- (0000C7A8) --------------------------------------------------------
void sub_C7A8()
{
  ;
}

//----- (0000C7B8) --------------------------------------------------------
void sub_C7B8()
{
  sub_C7A8();
}

//----- (0000C7C0) --------------------------------------------------------
void sub_C7C0()
{
  ;
}

//----- (0000C7D0) --------------------------------------------------------
void sub_C7D0()
{
  sub_C7C0();
}

//----- (0000C7D8) --------------------------------------------------------
char *sub_C7D8()
{
  return "";
}

//----- (0000C7F0) --------------------------------------------------------
char *sub_C7F0()
{
  return sub_C7D8();
}

//----- (0000C7F8) --------------------------------------------------------
int sub_C7F8()
{
  return 0;
}

//----- (0000C808) --------------------------------------------------------
int sub_C808()
{
  return sub_C7F8();
}

//----- (0000C810) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_C810(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = *(_QWORD *)&a4;
  v6 = a1;
  v9 = &v8;
  v10 = v5;
  *(_DWORD *)a1 = &off_286D8;
  *(_DWORD *)(a1 + 24) = &off_28730;
  sub_B394(a1, a2, (int)&off_286D8, (int)&off_28730);
  return v6;
}
// C810: could not find valid save-restore pair for r4
// C810: could not find valid save-restore pair for r7
// C810: variables would overlap: r3.4 and r3.8
// C810: variables would overlap: r4.4 and r3.8
// 286D8: using guessed type void *;
// 28730: using guessed type void *;

//----- (0000C838) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_C838(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = *(_QWORD *)&a4;
  v6 = (void *)a1;
  v9 = &v8;
  v10 = v5;
  *(_DWORD *)a1 = &off_286D8;
  *(_DWORD *)(a1 + 24) = &off_28730;
  sub_B394(a1, a2, (int)&off_286D8, (int)&off_28730);
  operator delete(v6);
  return v6;
}
// C838: could not find valid save-restore pair for r4
// C838: could not find valid save-restore pair for r7
// C838: variables would overlap: r3.4 and r3.8
// C838: variables would overlap: r4.4 and r3.8
// 286D8: using guessed type void *off_286D8;
// 28730: using guessed type void *off_28730;

//----- (0000C868) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_C868(char *s2, _DWORD *a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  char *v8; // r5@1
  _DWORD *v9; // r6@1
  int v10; // r4@1
  int result; // r0@7
  __int64 v12; // [sp+0h] [bp+0h]@1
  __int64 v13; // [sp+8h] [bp+8h]@1
  __int64 *v14; // [sp+10h] [bp+10h]@1
  int v15; // [sp+14h] [bp+14h]@1

  v12 = *(_QWORD *)&a4;
  v13 = *(_QWORD *)&v5;
  v8 = s2;
  v9 = a2;
  v14 = &v12;
  v15 = v7;
  v10 = dword_2A82C;
  if ( dword_2A82C )
  {
    while ( strcmp(*(const char **)(v10 + 4), v8) )
    {
      v10 = *(_DWORD *)(v10 + 8);
      if ( !v10 )
        goto LABEL_8;
    }
    if ( v9 )
      *v9 = 0;
    result = (*(int (__cdecl **)(_DWORD))v10)(0);
  }
  else
  {
LABEL_8:
    if ( v9 )
    {
      result = 0;
      *v9 = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// C868: could not find valid save-restore pair for r4
// C868: could not find valid save-restore pair for r5
// C868: could not find valid save-restore pair for r6
// C868: could not find valid save-restore pair for r7
// C868: variables would overlap: r3.4 and r3.8
// C868: variables would overlap: r4.4 and r3.8
// C868: variables would overlap: r5.4 and r5.8
// C868: variables would overlap: r6.4 and r5.8
// 2A82C: using guessed type int dword_2A82C;

//----- (0000C8B4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_C8B4(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@1
  __int64 v9; // [sp+0h] [bp+0h]@1
  __int64 *v10; // [sp+8h] [bp+8h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  v9 = *(_QWORD *)&a4;
  v6 = a1;
  v10 = &v9;
  v11 = v5;
  v7 = *(void **)(a1 + 8);
  *(_DWORD *)v6 = &off_28870;
  if ( v7 )
  {
    dlclose(v7);
    *(_DWORD *)(v6 + 8) = 0;
  }
  return v6;
}
// C8B4: could not find valid save-restore pair for r4
// C8B4: could not find valid save-restore pair for r7
// C8B4: variables would overlap: r3.4 and r3.8
// C8B4: variables would overlap: r4.4 and r3.8
// 28870: using guessed type void *;

//----- (0000C8E0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_C8E0(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = (void *)a1;
  sub_C8B4(a1, a2, a3, a4);
  operator delete(v6);
  return v6;
}
// C8E0: could not find valid save-restore pair for r4
// C8E0: could not find valid save-restore pair for r7
// C8E0: variables would overlap: r3.4 and r3.8
// C8E0: variables would overlap: r4.4 and r3.8

//----- (0000C924) --------------------------------------------------------
int __fastcall CreateInterface(char *s2, _DWORD *a2, int a3, int a4)
{
  return sub_C868(s2, a2, a3, a4);
}

//----- (0000C934) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_C934(void *a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  void *v7; // r0@2
  char *v9; // r0@5
  int v10; // [sp+0h] [bp+0h]@1
  int *v11; // [sp+8h] [bp+8h]@1
  int v12; // [sp+Ch] [bp+Ch]@1

  v11 = &v10;
  v12 = v5;
  *(_QWORD *)&v10 = *(_QWORD *)&a4;
  v6 = a1;
  if ( a1 )
  {
    v7 = (void *)androidwrapper_dlopen(a1);
    v6 = v7;
    if ( v7 )
    {
      dlclose(v7);
    }
    else
    {
      v9 = dlerror();
      printf("DLOPEN Error:%s\n", v9);
    }
  }
  return v6;
}
// C934: could not find valid save-restore pair for r4
// C934: could not find valid save-restore pair for r7
// C934: variables would overlap: r3.4 and r3.8
// C934: variables would overlap: r4.4 and r3.8
// 361C: using guessed type int __cdecl androidwrapper_dlopen(_DWORD);

//----- (0000C980) --------------------------------------------------------
int __fastcall sub_C980(const char *a1, int a2, int a3, int a4)
{
  int v4; // lr@0
  const char *v5; // r6@1
  char v6; // r8@1
  const char *v7; // r0@1
  const char *v8; // r5@1
  int v9; // r5@3
  char *v11; // r0@6
  const char *v12; // r6@6
  int v13; // [sp+0h] [bp+0h]@3
  int v14; // [sp+414h] [bp+414h]@1

  v5 = a1;
  v14 = v4;
  v6 = a2;
  v7 = sub_135BC(".so", a2, a3, a4);
  v8 = v7 - 1;
  if ( !v7 )
    v8 = ".so";
  sub_12330((char *)&v13, v5, 0x400u);
  sub_1335C((const char *)&v13, v8, 1024);
  sub_133C8(&v13, 47);
  v9 = androidwrapper_dlopen(&v13);
  if ( !v9 && !(v6 & 1) )
  {
    v11 = dlerror();
    v12 = v11;
    if ( v11 )
    {
      if ( !strstr(v11, "No such file") && !strstr(v12, "image not found") )
        Msg(" failed to dlopen %s error=%s\n");
    }
  }
  return v9;
}
// 361C: using guessed type int __cdecl androidwrapper_dlopen(_DWORD);
// 3A48: using guessed type int __fastcall Msg(_DWORD);

//----- (0000CA38) --------------------------------------------------------
int __fastcall sub_CA38(int a1, int a2)
{
  int v2; // lr@0
  int v3; // r5@1
  const char *v4; // r4@1
  int v5; // r2@1
  int v6; // r3@1
  int result; // r0@2
  size_t v8; // r0@4
  int v9; // r3@4
  size_t v10; // r8@6
  char *v11; // r0@9
  const char *v12; // r8@10
  int v13; // r2@10
  int v14; // r3@10
  int v15; // [sp+8h] [bp+0h]@4
  int v16; // [sp+408h] [bp+400h]@10
  int v17; // [sp+81Ch] [bp+814h]@1

  v3 = a2;
  v4 = (const char *)a1;
  v17 = v2;
  if ( sub_13A80(a1)
    || ((getcwd((char *)&v15, 0x400u), v8 = strlen((const char *)&v15), v9 = *((_BYTE *)&v15 + v8 - 1), v9 == 47)
     || v9 == 92 ? (*((_BYTE *)&v15 + v8 - 1) = 0, v10 = strlen((const char *)&v15)) : (v10 = v8),
        v4 != strstr(v4, "bin/")
     && ((v11 = (char *)&v15 + v10, *((_BYTE *)&v15 + v10 - 1) != 110) || *(v11 - 2) != 105 || *(v11 - 3) != 98) ? (v12 = (const char *)&v16, sub_12440((char *)&v16, 0x400u, "%s/bin/%s", &v15, v4)) : (v12 = (const char *)&v16, sub_12440((char *)&v16, 0x400u, "%s/%s", &v15, v4)),
        (result = sub_C980(v12, v3, v13, v14)) == 0) )
  {
    result = sub_C980(v4, v3, v5, v6);
  }
  return result;
}

//----- (0000CB24) --------------------------------------------------------
void *__fastcall sub_CB24(void *result)
{
  int *v1; // [sp+0h] [bp+0h]@1

  v1 = (int *)&v1;
  if ( result )
    result = (void *)j_dlclose(result);
  return result;
}

//----- (0000CB40) --------------------------------------------------------
void *__fastcall sub_CB40(void *result)
{
  int *v1; // [sp+0h] [bp+0h]@1

  v1 = (int *)&v1;
  if ( result )
    result = j_dlsym(result, "CreateInterface");
  return result;
}

//----- (0000CB9C) --------------------------------------------------------
void *__fastcall sub_CB9C(int a1, int a2, _DWORD *a3, int *a4)
{
  int v4; // r6@1
  _DWORD *v5; // r5@1
  int *v6; // r9@1
  void *result; // r0@1
  void *v8; // r8@1
  int (__fastcall *v9)(int, _DWORD); // r4@2
  int v10; // r6@3

  v4 = a2;
  v5 = a3;
  v6 = a4;
  result = (void *)sub_CA38(a1, 0);
  v8 = result;
  if ( result )
  {
    v9 = (int (__fastcall *)(int, _DWORD))dlsym(result, "CreateInterface");
    if ( v9 )
    {
      v10 = v9(v4, 0);
      *v6 = v10;
      if ( v10 )
      {
        if ( v5 )
        {
          *v5 = v8;
          result = (void *)1;
        }
        else
        {
          result = (void *)1;
        }
      }
      else
      {
        dlclose(v8);
        result = 0;
      }
    }
    else
    {
      dlclose(v8);
      result = 0;
    }
  }
  return result;
}
// CB9C: could not find valid save-restore pair for r4
// CB9C: could not find valid save-restore pair for r5
// CB9C: could not find valid save-restore pair for r6
// CB9C: could not find valid save-restore pair for r7
// CB9C: could not find valid save-restore pair for r8

//----- (0000CCB4) --------------------------------------------------------
int __fastcall sub_CCB4(int a1, int *a2, int a3)
{
  __int64 v3; // r4@0
  int v4; // lr@0
  int *v5; // r5@1
  int v6; // r4@1
  int (*v7)(void); // r3@1
  int v9; // r0@4
  int (__fastcall *v10)(int, int); // r5@4
  int v11; // r0@4
  __int64 v12; // [sp+0h] [bp+0h]@1
  __int64 *v13; // [sp+8h] [bp+8h]@1
  int v14; // [sp+Ch] [bp+Ch]@1

  v12 = v3;
  v5 = a2;
  v6 = a1;
  v13 = &v12;
  v14 = v4;
  v7 = *(int (**)(void))(*(_DWORD *)a1 + 12);
  if ( a2 )
  {
    if ( ((int (__cdecl *)(int, int, int, int (*)(void)))v7)(a1, a3, a3, v7) )
    {
      v9 = *v5;
      v10 = *(int (__fastcall **)(int, int))(*(_DWORD *)v6 + 16);
      v11 = off_2909C(v9);
      if ( v10(v6, v11) )
        return (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v6 + 16))(v6, " {\n");
    }
    return 0;
  }
  if ( !v7() )
    return 0;
  return (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v6 + 16))(v6, "<< NULL >>\n");
}
// CCB4: could not find valid save-restore pair for r4
// CCB4: could not find valid save-restore pair for r5
// CCB4: could not find valid save-restore pair for r7
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (0000CD1C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_CD1C(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int result; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( a2 )
  {
    result = (*(int (__cdecl **)(int))(*(_DWORD *)a1 + 12))(a1);
    if ( result )
      result = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v6 + 16))(v6, "}\n");
  }
  else
  {
    result = 1;
  }
  return result;
}
// CD1C: could not find valid save-restore pair for r4
// CD1C: could not find valid save-restore pair for r7
// CD1C: variables would overlap: r3.4 and r3.8
// CD1C: variables would overlap: r4.4 and r3.8

//----- (0000CD50) --------------------------------------------------------
int __fastcall sub_CD50(int a1, int a2, int a3, int a4)
{
  int v4; // lr@0
  int v5; // r0@1
  __int64 v7; // [sp+0h] [bp+0h]@1
  __int64 *v8; // [sp+8h] [bp+8h]@1
  int v9; // [sp+Ch] [bp+Ch]@1

  v8 = &v7;
  v9 = v4;
  v5 = KeyValuesSystem(a1, a2, a3, a4);
  return (*(int (**)(void))(*(_DWORD *)v5 + 12))();
}
// CD50: could not find valid save-restore pair for r7
// 3A6C: using guessed type int __cdecl KeyValuesSystem(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000CD70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_CD70(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r0@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = KeyValuesSystem(a1, a2, a3, a4);
  return (*(int (__cdecl **)(int))(*(_DWORD *)v6 + 16))(v6);
}
// CD70: could not find valid save-restore pair for r4
// CD70: could not find valid save-restore pair for r7
// CD70: variables would overlap: r3.4 and r3.8
// CD70: variables would overlap: r4.4 and r3.8
// 3A6C: using guessed type int __cdecl KeyValuesSystem(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000CD8C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_CD8C(int *a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int *v7; // r5@1
  _BYTE *v8; // r0@1
  int v9; // r2@1
  __int64 v11; // [sp+0h] [bp+0h]@1
  __int64 *v12; // [sp+10h] [bp+10h]@1
  int v13; // [sp+14h] [bp+14h]@1

  v11 = *(_QWORD *)&a4;
  v6 = a2;
  v12 = &v11;
  v13 = v5;
  v7 = a1;
  v8 = memset(&v11, 32, 2 * a2);
  v9 = *v7;
  v8[2 * v6] = 0;
  return (*(int (__fastcall **)(int *, _BYTE *))(v9 + 16))(v7, v8);
}
// CD8C: could not find valid save-restore pair for r4
// CD8C: could not find valid save-restore pair for r7
// CD8C: variables would overlap: r3.4 and r3.8
// CD8C: variables would overlap: r4.4 and r3.8

//----- (0000CDD8) --------------------------------------------------------
int __fastcall sub_CDD8(int a1, int *a2, int a3)
{
  int v3; // r5@1
  int v4; // r6@1
  int *v5; // r8@1
  int v6; // r2@2
  int v7; // r3@2
  int result; // r0@6

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( !(dword_2A834 & 1) && _cxa_guard_acquire(&dword_2A834) )
  {
    sub_C148((int)&unk_2A838, (int)"developer", v6, v7);
    _cxa_guard_release(&dword_2A834);
  }
  if ( sub_C1A4(&unk_2A838) && *(_DWORD *)(v3 + 4) > *(_DWORD *)(dword_2A83C + 48) )
    result = 0;
  else
    result = sub_CCB4(v3, v5, v4);
  return result;
}
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 2A834: using guessed type int dword_2A834;
// 2A83C: using guessed type int dword_2A83C;

//----- (0000CE70) --------------------------------------------------------
signed int __fastcall sub_CE70(int a1, int a2, int a3, int a4)
{
  int v4; // lr@0
  int v5; // r0@1
  signed int result; // r0@2
  _DWORD *v7; // [sp+0h] [bp+0h]@1
  int v8; // [sp+4h] [bp+4h]@1

  v7 = &v7;
  v8 = v4;
  v5 = *(_DWORD *)(a1 + 4);
  if ( v5 <= 0 )
  {
    Msg("%s");
    result = 1;
  }
  else
  {
    DevMsg(v5, "%s", a2, a4);
    result = 1;
  }
  return result;
}
// CE70: could not find valid save-restore pair for r7
// 34BC: using guessed type int DevMsg(_DWORD, const char *, ...);
// 3A48: using guessed type int __fastcall Msg(_DWORD);

//----- (0000CEA0) --------------------------------------------------------
int __fastcall sub_CEA0(int result)
{
  *(_DWORD *)result = -1;
  *(_BYTE *)(result + 18) = 1;
  *(_BYTE *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_BYTE *)(result + 17) = 0;
  *(_BYTE *)(result + 19) = 0;
  return result;
}

//----- (0000CECC) --------------------------------------------------------
_DWORD *__fastcall sub_CECC(int a1, int a2)
{
  __int64 v2; // r4@0
  int v3; // lr@0
  _DWORD *v4; // r4@1
  int v5; // r5@1
  __int64 v7; // [sp+0h] [bp+0h]@1
  __int64 *v8; // [sp+8h] [bp+8h]@1
  int v9; // [sp+Ch] [bp+Ch]@1

  v8 = &v7;
  v9 = v3;
  v7 = v2;
  v4 = (_DWORD *)a1;
  v5 = a2;
  sub_CEA0(a1);
  *v4 = off_290A0(v5, 1);
  return v4;
}
// CECC: could not find valid save-restore pair for r4
// CECC: could not find valid save-restore pair for r5
// CECC: could not find valid save-restore pair for r7
// 290A0: using guessed type int (__fastcall *off_290A0)(_DWORD, _DWORD);

//----- (0000CF08) --------------------------------------------------------
int __fastcall sub_CF08(_DWORD *a1)
{
  int v1; // lr@0
  _DWORD *v3; // [sp+0h] [bp+0h]@1
  int v4; // [sp+4h] [bp+4h]@1

  v3 = &v3;
  v4 = v1;
  return off_2909C(*a1);
}
// CF08: could not find valid save-restore pair for r7
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (0000CF20) --------------------------------------------------------
char *__fastcall sub_CF20(int a1, int a2, _BYTE *a3, _BYTE *a4)
{
  int v4; // r8@1
  _BYTE *v5; // r6@1
  int v6; // r4@1
  int v7; // r1@1
  int v8; // r3@1
  char *result; // r0@5
  int v10; // r11@8
  bool v11; // zf@9
  signed int v12; // r8@12
  char *i; // r0@12
  char v14; // r2@17
  int v15; // r3@18
  bool v16; // zf@18
  int v17; // r11@29
  void *v18; // r6@29
  int v19; // r0@30
  int v20; // r3@32
  int v21; // t1@32
  int v22; // r0@34
  void *v23; // r1@41
  signed int v24; // [sp+Ch] [bp+Ch]@12
  _BYTE *v25; // [sp+10h] [bp+10h]@1
  signed int v26; // [sp+18h] [bp+18h]@12

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v25 = a4;
  v7 = (int)a4;
  *a3 = 0;
  *a4 = 0;
  v8 = *(_BYTE *)(v6 + 20);
  if ( *(_BYTE *)(v6 + 20) )
    return 0;
  do
  {
    sub_14768(v6, v7, (int)a3, v8);
    if ( *(_BYTE *)(v6 + 20) )
      return 0;
  }
  while ( sub_1515C(v6) );
  result = (char *)sub_14C40(v6, 1, 0);
  if ( result )
  {
    v10 = (unsigned __int8)*result;
    if ( v10 != 34 )
    {
      v11 = v10 == 123;
      if ( v10 != 123 )
        v11 = v10 == 125;
      if ( v11 )
      {
        byte_2A840 = *result;
        byte_2A841 = 0;
        sub_14C74(v6, 1, 1);
        return &byte_2A840;
      }
      v26 = 0;
      v12 = 0;
      v24 = 0;
      for ( i = (char *)sub_14C40(v6, 1, 0); ; i = (char *)sub_14C40(v6, 1, 0) )
      {
        if ( !i )
          goto LABEL_39;
        v14 = *i;
        if ( !*i )
          goto LABEL_39;
        v15 = v14;
        v16 = v14 == 34;
        if ( v14 != 34 )
          v16 = v14 == 123;
        if ( v16 || v14 == 125 )
        {
LABEL_39:
          result = &byte_2A840;
          *((_BYTE *)&dword_2A830 + v26 + 16) = 0;
          return result;
        }
        if ( v14 == 91 )
        {
          v24 = 1;
        }
        else
        {
          if ( v14 != 93 )
            goto LABEL_24;
          if ( v24 )
          {
            *v25 = 1;
            v14 = *i;
LABEL_24:
            v15 = v14;
            if ( v14 == -1 )
              goto LABEL_26;
            goto LABEL_25;
          }
        }
LABEL_25:
        if ( *(_BYTE *)(ctype_ + v15 + 1) & 8 )
          goto LABEL_39;
LABEL_26:
        if ( v26 <= 4094 )
        {
          *((_BYTE *)&dword_2A830 + v26++ + 16) = v14;
        }
        else if ( !v12 )
        {
          Warning("KeyValues Error: %s in file %s\n", " ReadToken overflow", dword_2B940);
          if ( dword_2B948 > 0 )
          {
            v17 = 0;
            v18 = &unk_2B83C;
            while ( 1 )
            {
              v21 = *((_DWORD *)v18 + 1);
              v18 = (char *)v18 + 4;
              v20 = v21;
              if ( v21 == -1 )
                goto LABEL_31;
              if ( dword_2B944 > v17 )
              {
                v19 = off_2909C(v20);
                Warning("%s, ", v19);
LABEL_31:
                if ( ++v17 >= dword_2B948 )
                  break;
              }
              else
              {
                ++v17;
                v22 = off_2909C(v20);
                Warning("(*%s*), ", v22);
                if ( v17 >= dword_2B948 )
                  break;
              }
            }
          }
          v12 = 1;
          Warning("\n");
        }
        sub_14C74(v6, 1, 1);
      }
    }
    *v5 = 1;
    if ( *(_BYTE *)(v4 + 17) )
      v23 = sub_14404();
    else
      v23 = sub_1441C();
    sub_15360((_DWORD *)v6, (int)v23, &byte_2A840, 4096);
    result = &byte_2A840;
  }
  return result;
}
// CF20: could not find valid save-restore pair for r4
// CF20: could not find valid save-restore pair for r5
// CF20: could not find valid save-restore pair for r6
// CF20: could not find valid save-restore pair for r7
// CF20: could not find valid save-restore pair for r8
// CF20: could not find valid save-restore pair for r9
// CF20: could not find valid save-restore pair for r10
// CF20: could not find valid save-restore pair for r11
// 365C: using guessed type int Warning(const char *, ...);
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);
// 2A830: using guessed type int dword_2A830;
// 2A840: using guessed type char byte_2A840;
// 2A841: using guessed type char byte_2A841;
// 2B940: using guessed type int dword_2B940;
// 2B944: using guessed type int dword_2B944;
// 2B948: using guessed type int dword_2B948;

//----- (0000D19C) --------------------------------------------------------
char *__fastcall sub_D19C(int a1, int a2, int a3, int a4, const void *a5, int a6)
{
  char *v6; // r5@1
  char *result; // r0@2

  v6 = (char *)a4;
  if ( a2 )
    result = (char *)(*(int (__fastcall **)(int, const void *, int, int))(*(_DWORD *)a2 + 4))(a2, a5, a6, a3);
  if ( v6 )
    result = sub_15818(v6, a5, a6, a4);
  return result;
}

//----- (0000D254) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__fastcall sub_D254(char *s, int a2, int a3, int a4, char *sa)
{
  int v5; // r4@0
  int v6; // r5@0 OVERLAPPED
  int v8; // r7@0 OVERLAPPED
  int v10; // r9@0 OVERLAPPED
  int v12; // r11@0
  int v13; // lr@0
  char *v14; // r10@1
  int v15; // r9@1
  int v16; // r8@1
  char *v17; // r6@1
  signed int v18; // r0@1
  int v19; // r1@1
  int v20; // r12@1
  bool v21; // nf@1
  char v22; // r5@8
  char v23; // r3@12
  char v24; // t1@12
  int v25; // r2@12
  int v26; // r1@13
  int v27; // r0@14
  char v29[4]; // [sp+8h] [bp+0h]@10
  int v30; // [sp+Ch] [bp+4h]@1
  int v31; // [sp+14h] [bp+Ch]@1
  __int64 v32; // [sp+18h] [bp+10h]@1
  __int64 v33; // [sp+20h] [bp+18h]@1
  __int64 v34; // [sp+28h] [bp+20h]@1
  int v35; // [sp+30h] [bp+28h]@1
  int v36; // [sp+34h] [bp+2Ch]@1

  v34 = *(_QWORD *)&v10;
  v14 = s;
  v15 = a4;
  v33 = *(_QWORD *)&v8;
  v16 = a3;
  v35 = v12;
  v36 = v13;
  v32 = *(_QWORD *)&v6;
  v31 = v5;
  v17 = sa;
  v30 = a2;
  v18 = strlen(sa);
  v20 = v18 + 1;
  v21 = v18 < 0;
  if ( v18 >= 0 )
  {
    v5 = 0;
    v19 = 0;
  }
  if ( v18 >= 0 )
    LOBYTE(v18) = 92;
  if ( !v21 )
  {
    do
    {
      while ( 1 )
      {
        v24 = *v17++;
        v23 = v24;
        v25 = v24;
        if ( v24 != 34 )
          break;
        v29[v19] = v18;
        ++v5;
        v26 = v19 + 1;
        v29[v26] = *(v17 - 1);
        v19 = v26 + 1;
        if ( v5 == v20 )
          goto LABEL_14;
      }
      v22 = v23;
      if ( v14[17] && v25 == 92 )
      {
        v29[v19] = 92;
        v22 = *(v17 - 1);
        ++v19;
      }
      ++v5;
      v29[v19++] = v22;
    }
    while ( v5 != v20 );
  }
LABEL_14:
  v27 = strlen(v29);
  return sub_D19C((int)v14, v30, v16, v15, v29, v27);
}
// D254: could not find valid save-restore pair for r4
// D254: could not find valid save-restore pair for r5
// D254: could not find valid save-restore pair for r6
// D254: could not find valid save-restore pair for r7
// D254: could not find valid save-restore pair for r8
// D254: could not find valid save-restore pair for r9
// D254: could not find valid save-restore pair for r10
// D254: could not find valid save-restore pair for r11
// D254: variables would overlap: r5.4 and r5.8
// D254: variables would overlap: r6.4 and r5.8
// D254: variables would overlap: r7.4 and r7.8
// D254: variables would overlap: r8.4 and r7.8
// D254: variables would overlap: r9.4 and r9.8
// D254: variables would overlap: r10.4 and r9.8
// D254: using guessed type char var_30[4];

//----- (0000D420) --------------------------------------------------------
int __fastcall sub_D420(int a1)
{
  int result; // r0@1
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  for ( result = *(_DWORD *)(a1 + 24); result; result = *(_DWORD *)(result + 20) )
  {
    if ( *(_BYTE *)(result + 16) )
      break;
  }
  return result;
}

//----- (0000D440) --------------------------------------------------------
int __fastcall sub_D440(int result)
{
  int *v1; // [sp+0h] [bp+0h]@1

  v1 = (int *)&v1;
  do
    result = *(_DWORD *)(result + 20);
  while ( result && !*(_BYTE *)(result + 16) );
  return result;
}

//----- (0000D514) --------------------------------------------------------
int __fastcall sub_D514(int a1)
{
  __int64 v1; // r4@0
  int v2; // lr@0
  _BYTE *v3; // r4@1
  int v4; // r5@2
  int v5; // r5@4
  int v7; // [sp+0h] [bp+0h]@1
  int *v8; // [sp+8h] [bp+8h]@1
  int v9; // [sp+Ch] [bp+Ch]@1

  v8 = &v7;
  v9 = v2;
  *(_QWORD *)&v7 = v1;
  v3 = (_BYTE *)a1;
  if ( !a1 )
    return 0;
  v4 = *(_BYTE *)a1;
  if ( v4 == 91 )
  {
    v4 = *(_BYTE *)(a1 + 1);
    v3 = (_BYTE *)(a1 + 1);
  }
  v5 = v4 - 33 + ((unsigned int)(v4 - 33) <= 0) - (v4 - 33);
  if ( sub_12140(v3, "$X360") || sub_12140(v3, "$ANDROID") )
    return v5 ^ 1;
  if ( sub_12140(v3, "$WIN32") || sub_12140(v3, "$WINDOWS") || sub_12140(v3, "$OSX") )
    return v5;
  if ( sub_12140(v3, "$LINUX") || sub_12140(v3, "$POSIX") )
    return v5 ^ 1;
  return 0;
}
// D514: could not find valid save-restore pair for r4
// D514: could not find valid save-restore pair for r5
// D514: could not find valid save-restore pair for r7
// 127E0: using guessed type char *off_127E0;

//----- (0000D5C4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_D5C4(int a1, int a2)
{
  int v2; // r4@0
  __int64 v3; // r5@0
  __int64 v4; // r7@0
  int v5; // r9@0 OVERLAPPED
  int v7; // r11@0
  int v8; // lr@0
  int v9; // r10@1
  int v10; // r3@1
  int v11; // r2@1
  char v14; // r11@6
  const char *v15; // r0@8
  int v16; // r2@8
  int v17; // r3@8
  int v18; // r3@8
  int v19; // r3@9
  char v20; // r11@9
  int v21; // r3@11
  char v22; // r11@11
  int v23; // r2@12
  char v24; // r11@13
  int v25; // r3@13
  int v26; // r2@14
  int v27; // r3@15
  char v28; // r11@15
  int v29; // r3@22
  int v30; // r2@22
  int v37; // r2@28
  int v38; // r3@28
  char *v39; // r1@31
  int v40; // r11@38
  __int64 v41; // r2@38
  int v42; // r1@43
  int v43; // r1@46
  int v44; // r3@46
  int v45; // r1@51
  int v46; // r2@51
  int v47; // r1@51
  int v48; // r1@52
  int v49; // r1@55
  int v50; // r1@57
  int v51; // r1@59
  int v52; // r1@67
  int v53; // r1@69
  int v54; // r2@70
  char v55; // r12@71
  char v56; // lr@71
  char v57; // r0@71
  char v58; // r3@71
  int v59; // r2@74
  int v60; // r3@74
  int v61; // lr@74
  int v62; // r12@75
  char v63; // r0@76
  char *v64; // r1@76
  int v65; // r1@77
  int v66; // [sp+8h] [bp+8h]@60
  int v67; // [sp+10h] [bp+10h]@0
  int v68; // [sp+18h] [bp+18h]@44
  int v69; // [sp+20h] [bp+20h]@0
  __int64 v70; // [sp+20h] [bp+20h]@49
  int v71; // [sp+24h] [bp+24h]@51
  __int64 v72; // [sp+28h] [bp+28h]@75
  int v73; // [sp+30h] [bp+30h]@76
  int v74; // [sp+34h] [bp+34h]@1
  __int64 v75; // [sp+38h] [bp+38h]@1
  __int64 v76; // [sp+40h] [bp+40h]@1
  __int64 v77; // [sp+48h] [bp+48h]@1
  int v78; // [sp+50h] [bp+50h]@1
  int v79; // [sp+54h] [bp+54h]@1

  v77 = *(_QWORD *)&v5;
  v9 = a2;
  v76 = v4;
  v78 = v7;
  v79 = v8;
  v75 = v3;
  v74 = v2;
  v10 = *(_BYTE *)(a2 + 21);
  v11 = v10 & 1;
  if ( v10 & 1 )
    return 0;
  if ( *(_BYTE *)(a2 + 20) )
    return v10 & 1;
  if ( !a1 )
    goto LABEL_68;
  _R4 = a1;
  while ( 2 )
  {
    v14 = *(_BYTE *)(_R4 + 16);
    if ( v10 & 1 )
    {
      sub_15A10((char *)v9, "%u", *(_BYTE *)(_R4 + 16), v10);
    }
    else if ( sub_15784(v9, 1, v10 << 31, v10) )
    {
      v42 = *(_DWORD *)(v9 + 16) - *(_DWORD *)(v9 + 32);
      *(_BYTE *)(*(_DWORD *)v9 + v42) = v14;
      ++*(_DWORD *)(v9 + 16);
      sub_15F8C(v9, v42);
    }
    v15 = (const char *)off_2909C(*(_DWORD *)_R4);
    sub_15870((char *)v9, v15, v16, v17);
    v18 = *(_BYTE *)(_R4 + 16);
    switch ( v18 )
    {
      case 6:
        v19 = *(_BYTE *)(v9 + 21);
        v20 = *(_BYTE *)(_R4 + 12);
        if ( v19 & 1 )
        {
          sub_15A10((char *)v9, "%u", *(_BYTE *)(_R4 + 12), v19);
        }
        else if ( sub_15784(v9, 1, v11, v19) )
        {
          v52 = *(_DWORD *)(v9 + 16) - *(_DWORD *)(v9 + 32);
          *(_BYTE *)(*(_DWORD *)v9 + v52) = v20;
          ++*(_DWORD *)(v9 + 16);
          sub_15F8C(v9, v52);
        }
        v21 = *(_BYTE *)(v9 + 21);
        v22 = *(_BYTE *)(_R4 + 13);
        if ( v21 & 1 )
        {
          sub_15A10((char *)v9, "%u", *(_BYTE *)(_R4 + 13), v21);
        }
        else if ( sub_15784(v9, 1, *(_BYTE *)(v9 + 21) << 31, *(_BYTE *)(v9 + 21)) )
        {
          v49 = *(_DWORD *)(v9 + 16) - *(_DWORD *)(v9 + 32);
          *(_BYTE *)(*(_DWORD *)v9 + v49) = v22;
          ++*(_DWORD *)(v9 + 16);
          sub_15F8C(v9, v49);
        }
        v24 = *(_BYTE *)(_R4 + 14);
        v25 = *(_BYTE *)(v9 + 21) << 31;
        if ( *(_BYTE *)(v9 + 21) & 1 )
        {
          sub_15A10((char *)v9, "%u", *(_BYTE *)(_R4 + 14), v25);
        }
        else if ( sub_15784(v9, 1, v23, v25) )
        {
          v51 = *(_DWORD *)(v9 + 16) - *(_DWORD *)(v9 + 32);
          *(_BYTE *)(*(_DWORD *)v9 + v51) = v24;
          ++*(_DWORD *)(v9 + 16);
          sub_15F8C(v9, v51);
        }
        v27 = *(_BYTE *)(v9 + 21);
        v28 = *(_BYTE *)(_R4 + 15);
        if ( v27 & 1 )
        {
          sub_15A10((char *)v9, "%u", *(_BYTE *)(_R4 + 15), v27);
        }
        else if ( sub_15784(v9, 1, v26, v27) )
        {
          v50 = *(_DWORD *)(v9 + 16) - *(_DWORD *)(v9 + 32);
          *(_BYTE *)(*(_DWORD *)v9 + v50) = v28;
          ++*(_DWORD *)(v9 + 16);
          sub_15F8C(v9, v50);
        }
        goto def_D64C;
      default:
        goto def_D64C;
      case 4:
        v29 = *(_BYTE *)(v9 + 21);
        v30 = *(_DWORD *)(_R4 + 12);
        if ( v29 & 1 )
        {
          sub_15A10((char *)v9, "%u", v30, v29);
          _R4 = *(_DWORD *)(_R4 + 20);
          v10 = *(_BYTE *)(v9 + 21);
          if ( !_R4 )
            goto LABEL_18;
          continue;
        }
        v68 = *(_DWORD *)(_R4 + 12);
        if ( !sub_15784(v9, 4, v30, v29) )
          goto def_D64C;
        if ( !(*(_BYTE *)(v9 + 52) & 1) )
        {
          v43 = *(_DWORD *)(v9 + 16);
          *(_DWORD *)(*(_DWORD *)v9 + v43 - *(_DWORD *)(v9 + 32)) = v68;
          v44 = *(_DWORD *)(v9 + 16);
          goto LABEL_47;
        }
        v44 = *(_DWORD *)(v9 + 16);
        v43 = *(_DWORD *)v9;
        v54 = v44 - *(_DWORD *)(v9 + 32);
        if ( *(_DWORD *)v9 + v54 )
        {
          v55 = BYTE3(v68);
          v56 = BYTE2(v68);
          v57 = BYTE1(v68);
          v58 = v68;
          goto LABEL_80;
        }
        goto LABEL_47;
      case 3:
        __asm { VLDR            S15, [R4,#0xC] }
        _R3 = *(_BYTE *)(v9 + 21) << 31;
        if ( *(_BYTE *)(v9 + 21) & 1 )
        {
          __asm
          {
            VCVT.F64.F32    D16, S15
            VMOV            R2, R3, D16
          }
          sub_15A10((char *)v9, "%f", _R2, _R3);
          _R4 = *(_DWORD *)(_R4 + 20);
          v10 = *(_BYTE *)(v9 + 21);
          if ( !_R4 )
            goto LABEL_18;
          continue;
        }
        __asm { VSTR            S15, [R7,#0x58+var_48] }
        if ( !sub_15784(v9, 4, v11, _R3) )
          goto def_D64C;
        if ( !(*(_BYTE *)(v9 + 52) & 1) )
        {
          v43 = *(_DWORD *)(v9 + 16);
          *(_DWORD *)(*(_DWORD *)v9 + v43 - *(_DWORD *)(v9 + 32)) = v67;
          v44 = *(_DWORD *)(v9 + 16);
          goto LABEL_47;
        }
        v44 = *(_DWORD *)(v9 + 16);
        v43 = *(_DWORD *)v9;
        v54 = v44 - *(_DWORD *)(v9 + 32);
        if ( *(_DWORD *)v9 + v54 )
        {
          v55 = BYTE3(v67);
          v56 = BYTE2(v67);
          v57 = BYTE1(v67);
          v58 = v67;
          goto LABEL_80;
        }
        goto LABEL_47;
      case 2:
        v37 = *(_DWORD *)(_R4 + 12);
        v38 = *(_BYTE *)(v9 + 21) << 31;
        if ( *(_BYTE *)(v9 + 21) & 1 )
        {
          sub_15A10((char *)v9, "%d", v37, v38);
          _R4 = *(_DWORD *)(_R4 + 20);
          v10 = *(_BYTE *)(v9 + 21);
          if ( !_R4 )
            goto LABEL_18;
        }
        else
        {
          v66 = *(_DWORD *)(_R4 + 12);
          if ( !sub_15784(v9, 4, v37, v38) )
            goto def_D64C;
          if ( *(_BYTE *)(v9 + 52) & 1 )
          {
            v44 = *(_DWORD *)(v9 + 16);
            v43 = *(_DWORD *)v9;
            v54 = v44 - *(_DWORD *)(v9 + 32);
            if ( *(_DWORD *)v9 + v54 )
            {
              v55 = BYTE3(v66);
              v56 = BYTE2(v66);
              v57 = BYTE1(v66);
              v58 = v66;
LABEL_80:
              LOBYTE(v72) = v55;
              BYTE1(v72) = v56;
              BYTE2(v72) = v57;
              BYTE3(v72) = v58;
              *(_DWORD *)(v43 + v54) = v72;
              v44 = *(_DWORD *)(v9 + 16);
            }
          }
          else
          {
            v43 = *(_DWORD *)(v9 + 16);
            *(_DWORD *)(*(_DWORD *)v9 + v43 - *(_DWORD *)(v9 + 32)) = v66;
            v44 = *(_DWORD *)(v9 + 16);
          }
LABEL_47:
          *(_DWORD *)(v9 + 16) = v44 + 4;
          sub_15F8C(v9, v43);
          _R4 = *(_DWORD *)(_R4 + 20);
          v10 = *(_BYTE *)(v9 + 21);
          if ( !_R4 )
            goto LABEL_18;
        }
        continue;
      case 1:
        v39 = *(char **)(_R4 + 4);
        if ( !v39 || (v18 = *v39) == 0 )
          v39 = "";
        sub_15870((char *)v9, v39, v11, v18);
        _R4 = *(_DWORD *)(_R4 + 20);
        v10 = *(_BYTE *)(v9 + 21);
        if ( _R4 )
          continue;
        goto LABEL_18;
      case 0:
        sub_D5C4(*(_DWORD *)(_R4 + 24), v9);
        _R4 = *(_DWORD *)(_R4 + 20);
        v10 = *(_BYTE *)(v9 + 21);
        if ( _R4 )
          continue;
        goto LABEL_18;
      case 7:
        v40 = *(_BYTE *)(v9 + 21) & 1;
        v41 = *(_QWORD *)*(_DWORD *)(_R4 + 4);
        if ( *(_BYTE *)(v9 + 21) & 1 )
        {
          sub_15A10((char *)v9, "%f", v41, SHIDWORD(v41));
          _R4 = *(_DWORD *)(_R4 + 20);
          v10 = *(_BYTE *)(v9 + 21);
          if ( !_R4 )
            goto LABEL_18;
          continue;
        }
        v70 = *(_QWORD *)*(_DWORD *)(_R4 + 4);
        if ( !sub_15784(v9, 8, v41, SHIDWORD(v41)) )
        {
def_D64C:
          _R4 = *(_DWORD *)(_R4 + 20);
          v10 = *(_BYTE *)(v9 + 21);
          if ( !_R4 )
            goto LABEL_18;
          continue;
        }
        if ( *(_BYTE *)(v9 + 52) & 1 )
        {
          v47 = *(_DWORD *)(v9 + 16);
          v59 = *(_DWORD *)v9;
          v60 = v47 - *(_DWORD *)(v9 + 32);
          v61 = *(_DWORD *)v9 + v60;
          if ( v61 )
          {
            v62 = v40;
            v72 = *(_QWORD *)v61;
            do
            {
              ++v62;
              v63 = *((_BYTE *)&v73 + -v40 - 9);
              v64 = (char *)&v73 + v40;
              v40 = v62;
              *(v64 - 8) = v63;
            }
            while ( v62 != 8 );
            v65 = HIDWORD(v72);
            *(_DWORD *)(v59 + v60) = v72;
            *(_DWORD *)(v61 + 4) = v65;
            v47 = *(_DWORD *)(v9 + 16);
          }
        }
        else
        {
          v45 = v71;
          v46 = *(_DWORD *)v9 + *(_DWORD *)(v9 + 16) - *(_DWORD *)(v9 + 32);
          *(_DWORD *)v46 = v69;
          *(_DWORD *)(v46 + 4) = v45;
          v47 = *(_DWORD *)(v9 + 16);
        }
        v48 = v47 + 8;
        *(_DWORD *)(v9 + 16) = v48;
        sub_15F8C(v9, v48);
        _R4 = *(_DWORD *)(_R4 + 20);
        v10 = *(_BYTE *)(v9 + 21);
        if ( _R4 )
          continue;
LABEL_18:
        v10 <<= 31;
        if ( v10 < 0 )
        {
          sub_15A10((char *)v9, "%u", 8, v10);
          return *(_BYTE *)(v9 + 20) == 0;
        }
LABEL_68:
        if ( sub_15784(v9, 1, v11, v10) )
        {
          v53 = *(_DWORD *)(v9 + 16);
          *(_BYTE *)(*(_DWORD *)v9 + v53 - *(_DWORD *)(v9 + 32)) = 8;
          ++*(_DWORD *)(v9 + 16);
          sub_15F8C(v9, v53);
        }
        return *(_BYTE *)(v9 + 20) == 0;
    }
  }
}
// D5C4: could not find valid save-restore pair for r4
// D5C4: could not find valid save-restore pair for r5
// D5C4: could not find valid save-restore pair for r6
// D5C4: could not find valid save-restore pair for r7
// D5C4: could not find valid save-restore pair for r8
// D5C4: could not find valid save-restore pair for r9
// D5C4: could not find valid save-restore pair for r10
// D5C4: could not find valid save-restore pair for r11
// D5C4: variables would overlap: r9.4 and r9.8
// D5C4: variables would overlap: r10.4 and r9.8
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (0000DB08) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_DB08(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r0@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = KeyValuesSystem(a1, a2, a3, a4);
  return (*(int (__cdecl **)(int))(*(_DWORD *)v6 + 4))(v6);
}
// DB08: could not find valid save-restore pair for r4
// DB08: could not find valid save-restore pair for r7
// DB08: variables would overlap: r3.4 and r3.8
// DB08: variables would overlap: r4.4 and r3.8
// 3A6C: using guessed type int __cdecl KeyValuesSystem(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000DB40) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_DB40(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r0@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = KeyValuesSystem(a1, a2, a3, a4);
  return (*(int (__cdecl **)(int))(*(_DWORD *)v6 + 8))(v6);
}
// DB40: could not find valid save-restore pair for r4
// DB40: could not find valid save-restore pair for r7
// DB40: variables would overlap: r3.4 and r3.8
// DB40: variables would overlap: r4.4 and r3.8
// 3A6C: using guessed type int __cdecl KeyValuesSystem(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000DB5C) --------------------------------------------------------
void __fastcall sub_DB5C(int a1)
{
  int v1; // r6@1
  int v2; // r4@1
  int v3; // r5@4
  int v4; // r1@4
  int v5; // r2@4
  int v6; // r3@4
  int v7; // r4@5
  bool v8; // zf@5
  int v9; // r5@10
  int v10; // r1@10
  int v11; // r2@10
  int v12; // r3@10
  bool v13; // zf@10
  void *v14; // r0@14
  void *v15; // r0@16

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = 0;
      sub_DB5C(v2);
      sub_DB40(v2, v4, v5, v6);
      if ( !v3 )
        break;
      v2 = v3;
    }
  }
  v7 = *(_DWORD *)(v1 + 20);
  v8 = v1 == v7;
  if ( v1 != v7 )
    v8 = v7 == 0;
  if ( !v8 )
  {
    do
    {
      v9 = *(_DWORD *)(v7 + 20);
      *(_DWORD *)(v7 + 20) = 0;
      sub_DB5C(v7);
      sub_DB40(v7, v10, v11, v12);
      v13 = v1 == v9;
      if ( v1 != v9 )
        v13 = v9 == 0;
      v7 = v9;
    }
    while ( !v13 );
  }
  v14 = *(void **)(v1 + 4);
  if ( v14 )
    operator delete(v14);
  v15 = *(void **)(v1 + 8);
  *(_DWORD *)(v1 + 4) = 0;
  if ( v15 )
    operator delete(v15);
  *(_DWORD *)(v1 + 8) = 0;
}
// DB5C: could not find valid save-restore pair for r4
// DB5C: could not find valid save-restore pair for r5
// DB5C: could not find valid save-restore pair for r6
// DB5C: could not find valid save-restore pair for r7

//----- (0000DBF0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_DBF0(int result, const char *a2, int a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  int v8; // r9@0 OVERLAPPED
  int v10; // r11@0
  int v11; // lr@0
  const char *v12; // r11@1
  int v13; // r9@1
  int v14; // r6@1
  char *v15; // r0@3
  char *v16; // r8@3
  const char *v17; // r10@3
  int v18; // r0@5
  int v19; // r1@5
  int v20; // r2@5
  int v21; // r3@5
  int v22; // r5@6
  int v23; // r4@8
  int v24; // r0@15
  char v25; // r3@18
  char v26; // r3@20
  int v27; // [sp+0h] [bp+0h]@4
  int v28; // [sp+104h] [bp+104h]@1
  __int64 v29; // [sp+108h] [bp+108h]@1
  __int64 v30; // [sp+110h] [bp+110h]@1
  __int64 v31; // [sp+118h] [bp+118h]@1
  int v32; // [sp+120h] [bp+120h]@1
  int v33; // [sp+124h] [bp+124h]@1

  v32 = v10;
  v33 = v11;
  v12 = a2;
  v31 = *(_QWORD *)&v8;
  v13 = a3;
  v30 = *(_QWORD *)&v6;
  v29 = *(_QWORD *)&v4;
  v14 = result;
  v28 = v3;
  if ( a2 && *a2 )
  {
    v15 = strchr(a2, 47);
    v16 = v15;
    v17 = v12;
    if ( v15 )
    {
      v17 = (const char *)&v27;
      *((_BYTE *)memcpy(&v27, v12, v15 - v12) + v15 - v12) = 0;
    }
    v18 = off_290A0(v17, v13);
    v21 = v18 + 1;
    if ( v18 != -1 )
    {
      v22 = *(_DWORD *)(v14 + 24);
      if ( v22 )
      {
        v21 = *(_DWORD *)v22;
        if ( v18 == *(_DWORD *)v22 )
        {
          v23 = *(_DWORD *)(v14 + 24);
LABEL_9:
          result = v23;
          if ( v16 )
            result = sub_DBF0(v23);
          return result;
        }
        while ( 1 )
        {
          v23 = *(_DWORD *)(v22 + 20);
          if ( !v23 )
            break;
          v21 = *(_DWORD *)v23;
          if ( v18 == *(_DWORD *)v23 )
            goto LABEL_9;
          v22 = *(_DWORD *)(v22 + 20);
        }
      }
      v24 = *(_DWORD *)(v14 + 28);
      if ( v24 )
      {
        v23 = sub_DBF0(v24);
        if ( v23 )
          goto LABEL_9;
      }
      if ( v13 )
      {
        v23 = sub_DB08(32, v19, v20, v21);
        sub_CECC(v23, (int)v17);
        v25 = *(_BYTE *)(v14 + 17);
        if ( *(_BYTE *)(v14 + 17) )
          v25 = 1;
        *(_BYTE *)(v23 + 17) = v25;
        v26 = *(_BYTE *)(v14 + 18);
        if ( *(_BYTE *)(v14 + 18) )
          v26 = 1;
        *(_BYTE *)(v23 + 18) = v26;
        if ( v22 )
          *(_DWORD *)(v22 + 20) = v23;
        else
          *(_DWORD *)(v14 + 24) = v23;
        *(_DWORD *)(v23 + 20) = 0;
        *(_BYTE *)(v14 + 16) = 0;
        goto LABEL_9;
      }
    }
    result = 0;
  }
  return result;
}
// DBF0: could not find valid save-restore pair for r4
// DBF0: could not find valid save-restore pair for r5
// DBF0: could not find valid save-restore pair for r6
// DBF0: could not find valid save-restore pair for r7
// DBF0: could not find valid save-restore pair for r8
// DBF0: could not find valid save-restore pair for r9
// DBF0: could not find valid save-restore pair for r10
// DBF0: could not find valid save-restore pair for r11
// DBF0: variables would overlap: r5.4 and r5.8
// DBF0: variables would overlap: r6.4 and r5.8
// DBF0: variables would overlap: r7.4 and r7.8
// DBF0: variables would overlap: r8.4 and r7.8
// DBF0: variables would overlap: r9.4 and r9.8
// DBF0: variables would overlap: r10.4 and r9.8
// 290A0: using guessed type int (__fastcall *off_290A0)(_DWORD, _DWORD);

//----- (0000DCF8) --------------------------------------------------------
int __fastcall sub_DCF8(int a1, const char *a2, int a3)
{
  int v3; // r4@1
  int result; // r0@3
  unsigned int *v8; // r2@6
  unsigned int v9; // r3@7
  unsigned int *v10; // r1@7
  unsigned int v11; // r0@7
  signed int v14; // r0@12
  unsigned int v15; // r4@13
  unsigned int v16; // r3@17
  unsigned int *v17; // r4@18
  int v18; // r2@18
  int v19; // r5@19
  unsigned int v20; // r1@20
  unsigned int v21; // t1@20
  unsigned int v22; // r5@20

  v3 = a3;
  _R0 = sub_DBF0(a1, a2, 0);
  if ( _R0 )
  {
    switch ( *(_BYTE *)(_R0 + 16) )
    {
      case 7:
        result = 0;
        break;
      case 1:
        result = atoi(*(const char **)(_R0 + 4));
        break;
      case 3:
        __asm
        {
          VLDR            S15, [R0,#0xC]; jumptable 0000DD1A case 3
          VCVTR.S32.F32   S15, S15
          VMOV            R0, S15
        }
        break;
      case 5:
        v8 = *(unsigned int **)(_R0 + 8);
        do
        {
          v9 = *v8;
          v10 = v8;
          ++v8;
          v11 = v9 - 9;
          _CF = v9 >= 0x20;
          _ZF = v9 == 32;
          if ( v9 != 32 )
          {
            _CF = v11 >= 1;
            _ZF = v11 == 1;
          }
        }
        while ( _ZF || !_CF || v9 == 13 );
        v14 = (signed int)v10;
        if ( v9 == 45 )
        {
          v15 = v10[1];
        }
        else
        {
          v15 = v9;
          v14 = 1;
        }
        if ( v9 == 45 )
        {
          v10 = v8;
          v14 = -1;
        }
        v16 = v15 - 48;
        if ( v15 - 48 > 9 )
        {
          v16 = v15 - 97;
          if ( v15 - 97 > 0x19 )
          {
            v16 = v15 - 65;
            if ( v15 - 65 > 0x19 )
              v16 = -1;
          }
        }
        v17 = v10;
        v18 = 0;
LABEL_19:
        while ( 1 )
        {
          v19 = 5 * v18;
          if ( v16 > 9 )
            break;
          while ( 1 )
          {
            v21 = v17[1];
            ++v17;
            v20 = v21;
            v18 = v16 + 2 * v19;
            v16 = v21 - 48;
            v22 = v21 - 97;
            if ( v21 - 48 <= 9 )
              break;
            v16 = v20 - 65;
            if ( v22 <= 0x19 )
            {
              v16 = v22;
              goto LABEL_19;
            }
            if ( v16 > 0x19 )
              v16 = -1;
            v19 = 5 * v18;
            if ( v16 > 9 )
              goto LABEL_26;
          }
        }
LABEL_26:
        result = v14 * v18;
        break;
      default:
        result = *(_DWORD *)(_R0 + 12);
        break;
    }
  }
  else
  {
    result = v3;
  }
  return result;
}

//----- (0000DDE0) --------------------------------------------------------
int __fastcall sub_DDE0(int a1, const char *a2, int a3)
{
  int v3; // r5@1
  int v6; // r0@4
  unsigned int *v10; // r0@6
  unsigned int v11; // r3@7
  unsigned int *v12; // r2@7
  unsigned int v13; // r1@7
  bool v16; // zf@12
  signed int v17; // r12@15
  unsigned int v18; // r1@19
  unsigned int *v19; // r9@20
  signed __int64 v20; // r4@20
  signed __int64 v21; // r2@21
  unsigned int v22; // r0@22
  unsigned int v23; // t1@22
  unsigned int v24; // r11@22
  signed int v25; // r8@35
  signed int v26; // r6@36
  _BYTE *v27; // r0@40
  signed int v28; // r9@40
  bool v29; // cf@40
  __int64 v30; // r4@43
  signed int v31; // kr00_4@44
  signed int v32; // t1@44
  unsigned __int64 v33; // r2@44
  unsigned int v34; // r10@44
  bool v35; // cf@44
  signed __int64 v36; // r4@51
  _BYTE *v37; // r0@51
  signed int v38; // t1@52
  __int64 v39; // r2@52
  unsigned int v40; // r8@52
  bool v41; // cf@52
  signed __int64 v42; // r4@55
  bool v43; // cf@58
  signed __int64 v44; // r4@61
  bool v45; // cf@62
  signed __int64 v46; // r4@65

  v3 = a3;
  _R0 = sub_DBF0(a1, a2, 0);
  if ( !_R0 )
  {
    LODWORD(_R0) = v3;
    return _R0;
  }
  switch ( *(_BYTE *)(_R0 + 16) )
  {
    case 7:
      return *(_QWORD *)*(_DWORD *)(_R0 + 4);
    case 1:
      v6 = *(_DWORD *)(_R0 + 4);
      v25 = *(_BYTE *)v6;
      if ( v25 == 45 )
      {
        v25 = *(_BYTE *)(v6 + 1);
        v26 = -1;
        ++v6;
      }
      else
      {
        v26 = 1;
      }
      if ( v25 != 48 )
      {
        if ( v25 == 39 )
        {
          LODWORD(_R0) = *(_BYTE *)(_R0 + 1) * v26;
          return _R0;
        }
        v27 = (_BYTE *)(v6 + 1);
        v28 = v25 >> 31;
        v29 = 1;
        if ( ((unsigned int)v25 >= 0x30) + (v25 >> 31) == 1 )
          v29 = (unsigned int)(v25 - 48) >= 0xA;
        if ( v29 )
        {
          LODWORD(_R0) = 0;
          return _R0;
        }
        goto LABEL_43;
      }
      if ( (*(_BYTE *)(v6 + 1) & 0xFFFFFFDF) != 88 )
      {
        v27 = (_BYTE *)(v6 + 1);
        v25 = 48;
        v28 = 0;
LABEL_43:
        v30 = 0LL;
        do
        {
          v31 = v25;
          v32 = *v27++;
          v25 = v32;
          v33 = 10 * v30 + __PAIR__(v28, v31);
          v28 = v32 >> 31;
          v34 = v32 - 48;
          LODWORD(v30) = v33 - 48;
          HIDWORD(v30) = ((unsigned int)v33 >= 0x30) + HIDWORD(v33) - 1;
          v35 = 1;
          if ( ((unsigned int)v32 >= 0x30) + (v32 >> 31) == 1 )
            v35 = v34 >= 0xA;
        }
        while ( !v35 );
        LODWORD(_R0) = v26 * v30;
        return _R0;
      }
      v36 = 0LL;
      v37 = (_BYTE *)(v6 + 2);
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v38 = *v37++;
            v39 = v38;
            v40 = v38 - 48;
            v41 = 1;
            if ( ((unsigned int)v38 >= 0x30) + (v38 >> 31) == 1 )
              v41 = v40 >= 0xA;
            if ( v41 )
              break;
            HIDWORD(v36) = v36 >> 28;
            LODWORD(v36) = 16 * v36;
            v42 = v36 + v39;
            _CF = (unsigned int)v42 >= 0x30;
            LODWORD(v36) = v42 - 48;
            HIDWORD(v36) = _CF + HIDWORD(v36) - 1;
          }
          v43 = 1;
          if ( ((unsigned int)v39 >= 0x61) + HIDWORD(v39) == 1 )
            v43 = (unsigned int)(v39 - 97) >= 6;
          if ( v43 )
            break;
          HIDWORD(v36) = v36 >> 28;
          LODWORD(v36) = 16 * v36;
          v44 = v36 + v39;
          _CF = (unsigned int)v44 >= 0x57;
          LODWORD(v36) = v44 - 87;
          HIDWORD(v36) = _CF + HIDWORD(v36) - 1;
        }
        v45 = 1;
        if ( ((unsigned int)v39 >= 0x41) + HIDWORD(v39) == 1 )
          v45 = (unsigned int)(v39 - 65) >= 6;
        if ( v45 )
          break;
        HIDWORD(v36) = v36 >> 28;
        LODWORD(v36) = 16 * v36;
        v46 = v36 + v39;
        _CF = (unsigned int)v46 >= 0x37;
        LODWORD(v36) = v46 - 55;
        HIDWORD(v36) = _CF + HIDWORD(v36) - 1;
      }
      LODWORD(_R0) = v36 * v26;
      return _R0;
    case 3:
      __asm
      {
        VLDR            S15, [R0,#0xC]; jumptable 0000DE12 case 3
        VCVTR.S32.F32   S15, S15
        VMOV            R2, S15
        VMOV            R0, S15
      }
      return _R0;
    case 5:
      v10 = *(unsigned int **)(_R0 + 8);
      do
      {
        v11 = *v10;
        v12 = v10;
        ++v10;
        v13 = v11 - 9;
        _CF = v11 >= 0x20;
        _ZF = v11 == 32;
        if ( v11 != 32 )
        {
          _CF = v13 >= 1;
          _ZF = v13 == 1;
        }
      }
      while ( _ZF || !_CF || v11 == 13 );
      v16 = v11 == 45;
      if ( v11 == 45 )
        v11 = v12[1];
      if ( v16 )
        v17 = -1;
      else
        v17 = 1;
      if ( v16 )
        v12 = v10;
      v18 = v11 - 48;
      if ( v11 - 48 > 9 )
      {
        v18 = v11 - 97;
        if ( v11 - 97 > 0x19 )
        {
          v18 = v11 - 65;
          if ( v11 - 65 > 0x19 )
            v18 = -1;
        }
      }
      v19 = v12;
      v20 = 0LL;
LABEL_21:
      while ( 1 )
      {
        v21 = 10LL * (unsigned int)v20;
        if ( v18 > 9 )
          break;
        while ( 1 )
        {
          v23 = v19[1];
          ++v19;
          v22 = v23;
          HIDWORD(v21) += 10 * HIDWORD(v20);
          v20 = v21 + (signed int)v18;
          v24 = v23 - 97;
          v18 = v23 - 48;
          if ( v23 - 48 <= 9 )
            break;
          v18 = v22 - 65;
          if ( v24 <= 0x19 )
          {
            v18 = v24;
            goto LABEL_21;
          }
          if ( v18 > 0x19 )
            v18 = -1;
          v21 = 10LL * (unsigned int)v20;
          if ( v18 > 9 )
            goto LABEL_28;
        }
      }
LABEL_28:
      LODWORD(_R0) = v20 * v17;
      return _R0;
    default:
      LODWORD(_R0) = *(_DWORD *)(_R0 + 12);
      return _R0;
  }
}
// DDE0: could not find valid save-restore pair for r4
// DDE0: could not find valid save-restore pair for r5
// DDE0: could not find valid save-restore pair for r6
// DDE0: could not find valid save-restore pair for r7
// DDE0: could not find valid save-restore pair for r8
// DDE0: could not find valid save-restore pair for r9
// DDE0: could not find valid save-restore pair for r10

//----- (0000DF20) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_DF20(int a1, const char *a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r0@1
  int result; // r0@3
  int v9; // [sp+0h] [bp+0h]@1
  int *v10; // [sp+8h] [bp+8h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  v10 = &v9;
  v11 = v5;
  *(_QWORD *)&v9 = *(_QWORD *)&a4;
  v6 = a3;
  v7 = sub_DBF0(a1, a2, 0);
  if ( v7 )
  {
    if ( *(_BYTE *)(v7 + 16) == 4 )
      result = *(_DWORD *)(v7 + 12);
    else
      result = 0;
  }
  else
  {
    result = v6;
  }
  return result;
}
// DF20: could not find valid save-restore pair for r4
// DF20: could not find valid save-restore pair for r7
// DF20: variables would overlap: r3.4 and r3.8
// DF20: variables would overlap: r4.4 and r3.8

//----- (0000DF4C) --------------------------------------------------------
int __fastcall sub_DF4C(int a1, const char *a2)
{
  int v2; // lr@0
  int result; // r0@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v2;
  __asm { VMOV.F32        S16, S0 }
  result = sub_DBF0(a1, a2, 0);
  if ( result )
  {
    switch ( *(_BYTE *)(result + 16) )
    {
      default:
        __asm { VLDR            S0, =0.0; jumptable 0000DF70 default case }
        break;
      case 1:
        result = COERCE_UNSIGNED_INT64(strtod((const char *)*(_DWORD *)(result + 4), 0));
        __asm
        {
          VMOV            D16, R0, R1
          VCVT.F32.F64    S0, D16
        }
        break;
      case 2:
        __asm
        {
          VLDR            S0, [R0,#0xC]; jumptable 0000DF70 case 2
          VCVT.F32.S32    S0, S0
        }
        break;
      case 3:
        __asm { VLDR            S0, [R0,#0xC]; jumptable 0000DF70 case 3 }
        break;
      case 7:
        result = _aeabi_ul2f(*(_QWORD *)*(_DWORD *)(result + 4), *(_QWORD *)*(_DWORD *)(result + 4) >> 32);
        __asm { VMOV            S0, R0 }
        break;
    }
  }
  else
  {
    __asm { VMOV.F32        S0, S16 }
  }
  return result;
}
// DF4C: could not find valid save-restore pair for r7
// 3C14: using guessed type int __fastcall _aeabi_ul2f(_DWORD, _DWORD);

//----- (0000E018) --------------------------------------------------------
void __fastcall sub_E018(int a1, const char *a2)
{
  int v2; // lr@0
  int v5; // r3@2
  char v6; // r4@8
  char v7; // r4@9
  char v8; // r1@9
  char v9; // r2@9
  int v10; // r3@9
  const char *v12; // r0@6
  int v21; // [sp+8h] [bp+0h]@1
  int v22; // [sp+10h] [bp+8h]@6
  int v23; // [sp+14h] [bp+Ch]@7
  int v24; // [sp+18h] [bp+10h]@6
  int v25; // [sp+20h] [bp+18h]@6
  int v26; // [sp+34h] [bp+2Ch]@1

  v26 = v2;
  _R7 = &v21;
  _R0 = sub_DBF0(a1, a2, 0);
  if ( _R0 )
  {
    v5 = *(_BYTE *)(_R0 + 16);
    switch ( v5 )
    {
      case 6:
        v7 = *(_BYTE *)(_R0 + 12);
        v8 = *(_BYTE *)(_R0 + 13);
        v9 = *(_BYTE *)(_R0 + 14);
        v10 = *(_BYTE *)(_R0 + 15);
        break;
      case 3:
        __asm
        {
          VLDR            S15, [R0,#0xC]
          VCVTR.U32.F32   S15, S15
          VMOV            R4, S15
        }
        break;
      case 2:
        v6 = *(_BYTE *)(_R0 + 12);
        break;
      case 1:
        v25 = 0;
        v12 = *(const char **)(_R0 + 4);
        v21 = 0;
        v22 = 0;
        v24 = 0;
        sscanf(v12, "%f %f %f %f", &v21, &v22, &v24, &v25, 0);
        __asm
        {
          VLDR            S12, [R7,#0x30+var_30]
          VLDR            S13, [R7,#0x30+var_28]
          VLDR            S14, [R7,#0x30+var_20]
          VLDR            S15, [R7,#0x30+var_18]
          VCVTR.U32.F32   S12, S12
          VCVTR.U32.F32   S13, S13
          VCVTR.U32.F32   S14, S14
          VCVTR.U32.F32   S15, S15
          VMOV            R4, S12
          VMOV            R1, S13
          VMOV            R2, S14
          VMOV            R3, S15
        }
        break;
    }
  }
  JUMPOUT(__CS__, v23);
}

//----- (0000E13C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__fastcall sub_E13C(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  const char *v8; // r5@1
  char *result; // r0@1
  char *v10; // r4@1
  int v11; // r3@2
  void *v12; // r0@5
  unsigned int v13; // r6@8
  void *v14; // r0@9
  int v15; // [sp+0h] [bp+0h]@1
  __int64 v16; // [sp+8h] [bp+8h]@1
  int *v17; // [sp+10h] [bp+10h]@1
  int v18; // [sp+14h] [bp+14h]@1

  v17 = &v15;
  v18 = v7;
  v16 = *(_QWORD *)&v5;
  v8 = a3;
  *(_QWORD *)&v15 = *(_QWORD *)&a4;
  result = (char *)sub_DBF0(a1, a2, 1);
  v10 = result;
  if ( result )
  {
    v11 = result[16];
    result = (char *)*((_DWORD *)result + 1);
    if ( v11 != 1 || result != v8 )
    {
      if ( result )
        operator delete(result);
      v12 = (void *)*((_DWORD *)v10 + 2);
      if ( v12 )
        operator delete(v12);
      *((_DWORD *)v10 + 2) = 0;
      if ( v8 )
      {
        v13 = strlen(v8) + 1;
      }
      else
      {
        v13 = 1;
        v8 = "";
      }
      v14 = (void *)sub_1E9D4(v13);
      *((_DWORD *)v10 + 1) = v14;
      result = (char *)memcpy(v14, v8, v13);
      v10[16] = 1;
    }
  }
  return result;
}
// E13C: could not find valid save-restore pair for r4
// E13C: could not find valid save-restore pair for r5
// E13C: could not find valid save-restore pair for r6
// E13C: could not find valid save-restore pair for r7
// E13C: variables would overlap: r3.4 and r3.8
// E13C: variables would overlap: r4.4 and r3.8
// E13C: variables would overlap: r5.4 and r5.8
// E13C: variables would overlap: r6.4 and r5.8

//----- (0000E238) --------------------------------------------------------
int __fastcall sub_E238(int a1, const char *a2, int a3)
{
  int v3; // lr@0
  int v4; // r9@1
  const char *v5; // r8@1
  int v6; // r4@1
  int v8; // r6@1
  int v9; // r3@2
  int v14; // r3@3
  int result; // r0@4
  int v16; // r3@6
  __int64 v17; // ST00_8@8
  int v18; // r3@8
  int v19; // r3@9
  int v20; // [sp+8h] [bp+0h]@3
  int v21; // [sp+224h] [bp+21Ch]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v21 = v3;
  _R0 = sub_DBF0(a1, a2, 0);
  v8 = _R0;
  if ( _R0 )
  {
    v9 = *(_BYTE *)(_R0 + 16);
    switch ( v9 )
    {
      case 3:
        __asm
        {
          VLDR            S15, [R0,#0xC]; jumptable 0000E26C case 3
          VCVT.F64.F32    D16, S15
          VSTR            D16, [SP,#0x228+var_228]
        }
        sub_12440((char *)&v20, 0x40u, "%f");
        sub_E13C(v4, v5, (const char *)&v20, v14);
        break;
      case 1:
        break;
      case 5:
        if ( !sub_12C04(*(_DWORD *)(_R0 + 8), &v20, 512, v9) )
          goto def_E26C;
        sub_E13C(v4, v5, (const char *)&v20, v16);
        break;
      default:
        goto def_E26C;
      case 7:
        v17 = *(_QWORD *)*(_DWORD *)(_R0 + 4);
        sub_12440((char *)&v20, 0x40u, "%lld");
        sub_E13C(v4, v5, (const char *)&v20, v18);
        break;
      case 2:
      case 4:
        sub_12440((char *)&v20, 0x40u, "%d", *(_DWORD *)(_R0 + 12));
        sub_E13C(v4, v5, (const char *)&v20, v19);
        break;
    }
    result = *(_DWORD *)(v8 + 4);
  }
  else
  {
def_E26C:
    result = v6;
  }
  return result;
}

//----- (0000E31C) --------------------------------------------------------
_DWORD *__fastcall sub_E31C(int a1, const char *a2, char *a3)
{
  char *v3; // r8@1
  _DWORD *result; // r0@1
  _DWORD *v5; // r6@1
  void *v6; // r0@2
  void *v7; // r0@4
  int v8; // r3@9
  char *v9; // r4@10
  unsigned int v10; // r4@11
  size_t v11; // r5@11
  unsigned int v12; // r0@12
  void *v13; // r0@14

  v3 = a3;
  result = (_DWORD *)sub_DBF0(a1, a2, 1);
  v5 = result;
  if ( result )
  {
    v6 = (void *)result[2];
    if ( v6 )
      operator delete(v6);
    v7 = (void *)v5[1];
    if ( v7 )
      operator delete(v7);
    v5[1] = 0;
    if ( !v3 )
      v3 = (char *)&unk_1FC94;
    if ( *(_DWORD *)v3 )
    {
      v8 = (int)(v3 + 4);
      do
      {
        v9 = (char *)v8;
        v8 += 4;
      }
      while ( *(_DWORD *)v9 );
      v10 = ((v9 - v3) >> 2) + 1;
      v11 = 4 * v10;
      if ( v10 > 0x1FC00000 )
      {
        v12 = -1;
LABEL_14:
        v13 = (void *)sub_1E9D4(v12);
        v5[2] = v13;
        result = memcpy(v13, v3, v11);
        *((_BYTE *)v5 + 16) = 5;
        return result;
      }
    }
    else
    {
      v11 = 4;
    }
    v12 = v11;
    goto LABEL_14;
  }
  return result;
}
// E31C: could not find valid save-restore pair for r4
// E31C: could not find valid save-restore pair for r5
// E31C: could not find valid save-restore pair for r6
// E31C: could not find valid save-restore pair for r7

//----- (0000E3E8) --------------------------------------------------------
int __fastcall sub_E3E8(int a1, const char *a2, int a3)
{
  signed int v3; // r10@0
  int v4; // lr@0
  int v5; // r9@1
  const char *v6; // r8@1
  int v7; // r4@1
  int v9; // r6@1
  int v10; // r3@2
  size_t v11; // r0@3
  unsigned int v14; // r0@4
  _DWORD *v15; // r5@8
  int v16; // r3@8
  int result; // r0@11
  __int64 *v18; // r3@15
  __int64 v19; // ST00_8@15
  int v22; // [sp+8h] [bp+0h]@15
  int v23; // [sp+124h] [bp+11Ch]@1

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v23 = v4;
  _R0 = sub_DBF0(a1, a2, 0);
  v9 = _R0;
  if ( _R0 )
  {
    v10 = *(_BYTE *)(_R0 + 16);
    switch ( v10 )
    {
      case 1:
        v11 = strlen(*(const char **)(_R0 + 4)) + 1;
        _CF = v11 >= 0x1FC00000;
        _ZF = v11 == 532676608;
        if ( v11 > 0x1FC00000 )
        {
          v3 = 4 * v11;
          v14 = -1;
        }
        else
        {
          v14 = 4 * v11;
        }
        if ( _ZF || !_CF )
          v3 = v14;
        v15 = (_DWORD *)sub_1E9D4(v14);
        if ( (signed int)sub_12B7C(*(char **)(v9 + 4), v15, v3, v16) < 0 )
        {
          if ( !v15 )
            goto def_E41A;
          operator delete(v15);
          result = v7;
        }
        else
        {
          sub_E31C(v5, v6, (char *)v15);
          if ( v15 )
            operator delete(v15);
LABEL_11:
          result = *(_DWORD *)(v9 + 8);
        }
        break;
      case 5:
        goto LABEL_11;
      default:
        goto def_E41A;
      case 7:
        v18 = *(__int64 **)(_R0 + 4);
        v19 = *v18;
        sub_112C4((int)&v22, 64, (int)"%", (int)v18);
        sub_E31C(v5, v6, (char *)&v22);
        goto LABEL_11;
      case 2:
      case 4:
        sub_112C4((int)&v22, 64, (int)"%", *(_DWORD *)(_R0 + 12));
        sub_E31C(v5, v6, (char *)&v22);
        goto LABEL_11;
      case 3:
        __asm
        {
          VLDR            S15, [R0,#0xC]; jumptable 0000E41A case 3
          VCVT.F64.F32    D16, S15
          VSTR            D16, [SP,#0x128+var_128]
        }
        sub_112C4((int)&v22, 64, (int)"%", v10);
        sub_E31C(v5, v6, (char *)&v22);
        goto LABEL_11;
    }
  }
  else
  {
def_E41A:
    result = v7;
  }
  return result;
}

//----- (0000E694) --------------------------------------------------------
int __fastcall sub_E694(int a1, int a2, int a3, int a4)
{
  int v4; // r6@1
  int v5; // r5@1
  int v6; // r8@1
  int v7; // r4@1
  char v8; // r3@1
  char v9; // r3@3
  int result; // r0@6

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = sub_DB08(32, a2, a3, a4);
  sub_CECC(v7, v6);
  v8 = *(_BYTE *)(v5 + 17);
  if ( *(_BYTE *)(v5 + 17) )
    v8 = 1;
  *(_BYTE *)(v7 + 17) = v8;
  v9 = *(_BYTE *)(v5 + 18);
  if ( *(_BYTE *)(v5 + 18) )
    v9 = 1;
  *(_BYTE *)(v7 + 18) = v9;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 20) = v7;
    result = v7;
  }
  else
  {
    *(_DWORD *)(v5 + 24) = v7;
    result = v7;
  }
  return result;
}
// E694: could not find valid save-restore pair for r4
// E694: could not find valid save-restore pair for r5
// E694: could not find valid save-restore pair for r6
// E694: could not find valid save-restore pair for r7

//----- (0000E778) --------------------------------------------------------
char *__fastcall sub_E778(char *result, int a2, int a3)
{
  int v3; // lr@0
  char *v5; // r5@1
  int v6; // r3@1
  int v7; // r6@2
  int v8; // r3@3
  int v9; // r6@4
  size_t v10; // r0@8
  size_t v11; // r6@8
  char *v12; // r0@8
  size_t v17; // r0@14
  size_t v18; // r8@14
  char *v19; // r0@14
  int v20; // r3@16
  int v21; // r3@16
  int v22; // [sp+8h] [bp+0h]@13
  int v23; // [sp+11Ch] [bp+114h]@1

  _R4 = a2;
  v5 = result;
  v23 = v3;
  *(_DWORD *)result = *(_DWORD *)a2;
  v6 = *(_DWORD *)(a2 + 24);
  if ( v6 )
    goto LABEL_19;
  result[16] = *(_BYTE *)(a2 + 16);
  switch ( *(_BYTE *)(a2 + 16) )
  {
    case 1:
      result = *(char **)(a2 + 4);
      if ( result )
      {
        v10 = strlen(result);
        v11 = v10 + 1;
        v12 = (char *)sub_1E9D4(v10 + 1);
        *((_DWORD *)v5 + 1) = v12;
        result = sub_12330(v12, *(const char **)(_R4 + 4), v11);
      }
      break;
    default:
      break;
    case 6:
      result[12] = *(_BYTE *)(a2 + 12);
      result[13] = *(_BYTE *)(a2 + 13);
      result[14] = *(_BYTE *)(a2 + 14);
      result[15] = *(_BYTE *)(a2 + 15);
      break;
    case 4:
      *((_DWORD *)result + 3) = *(_DWORD *)(a2 + 12);
      break;
    case 3:
      __asm
      {
        VLDR            S15, [R4,#0xC]; jumptable 0000E7EC case 3
        VCVT.F64.F32    D16, S15
        VSTR            S15, [R5,#0xC]
        VSTR            D16, [SP,#0x120+var_120]
      }
      sub_12440((char *)&v22, 0x100u, "%f");
      goto LABEL_14;
    case 2:
      *((_DWORD *)result + 3) = *(_DWORD *)(a2 + 12);
      sub_12440((char *)&v22, 0x100u, "%d");
LABEL_14:
      v17 = strlen((const char *)&v22);
      v18 = v17 + 1;
      v19 = (char *)sub_1E9D4(v17 + 1);
      *((_DWORD *)v5 + 1) = v19;
      result = sub_12330(v19, (const char *)&v22, v18);
      break;
    case 7:
      result = (char *)sub_1E9D4(8u);
      *((_DWORD *)v5 + 1) = result;
      v20 = *(_DWORD *)(_R4 + 4);
      a3 = *(_DWORD *)v20;
      v21 = *(_DWORD *)(v20 + 4);
      *(_DWORD *)result = a3;
      *((_DWORD *)result + 1) = v21;
      break;
  }
  v6 = *(_DWORD *)(_R4 + 24);
  if ( v6 )
  {
LABEL_19:
    v7 = sub_DB08(32, a2, a3, v6);
    sub_CECC(v7, 0);
    *((_DWORD *)v5 + 6) = v7;
    result = (char *)sub_E778(v7, *(_DWORD *)(_R4 + 24));
  }
  v8 = *(_DWORD *)(_R4 + 20);
  if ( v8 )
  {
    v9 = sub_DB08(32, a2, a3, v8);
    sub_CECC(v9, 0);
    *((_DWORD *)v5 + 5) = v9;
    result = (char *)sub_E778(v9, *(_DWORD *)(_R4 + 20));
  }
  return result;
}

//----- (0000E8D8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_E8D8(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  _DWORD *v8; // r4@1
  int v9; // r6@1
  int v10; // r1@1
  int v11; // r2@1
  int v12; // r3@1
  int v13; // r5@1
  int v14; // r2@1
  char v15; // r3@1
  char v16; // r3@3
  int v17; // r3@5
  _DWORD *v18; // r0@6
  int v19; // r3@8
  _DWORD *v20; // r2@9
  unsigned int v21; // r0@10
  size_t v22; // r6@10
  unsigned int v23; // r0@11
  void *v24; // r0@12
  const char *v26; // r0@17
  size_t v27; // r0@18
  size_t v28; // r6@18
  void *v29; // r0@18
  int v30; // r0@19
  int v31; // r3@19
  __int64 v32; // [sp+0h] [bp+0h]@1
  __int64 v33; // [sp+8h] [bp+8h]@1
  __int64 *v34; // [sp+10h] [bp+10h]@1
  int v35; // [sp+14h] [bp+14h]@1

  v32 = *(_QWORD *)&a4;
  v8 = a1;
  v34 = &v32;
  v35 = v7;
  v33 = *(_QWORD *)&v5;
  v9 = off_2909C(*a1);
  v13 = sub_DB08(32, v10, v11, v12);
  sub_CECC(v13, v9);
  v15 = *((_BYTE *)v8 + 17);
  if ( *((_BYTE *)v8 + 17) )
    v15 = 1;
  *(_BYTE *)(v13 + 17) = v15;
  v16 = *((_BYTE *)v8 + 18);
  if ( *((_BYTE *)v8 + 18) )
    v16 = 1;
  *(_BYTE *)(v13 + 18) = v16;
  *(_BYTE *)(v13 + 16) = *((_BYTE *)v8 + 16);
  v17 = *((_BYTE *)v8 + 16);
  switch ( v17 )
  {
    case 5:
      v18 = (_DWORD *)v8[2];
      if ( !v18 )
        goto def_E92A;
      if ( !*v18 )
      {
        v22 = 4;
LABEL_11:
        v23 = v22;
        goto LABEL_12;
      }
      v19 = (int)(v18 + 1);
      do
      {
        v20 = (_DWORD *)v19;
        v19 += 4;
      }
      while ( *v20 );
      v21 = v20 - v18 + 1;
      v22 = 4 * v21;
      if ( v21 <= 0x1FC00000 )
        goto LABEL_11;
      v23 = -1;
LABEL_12:
      v24 = (void *)sub_1E9D4(v23);
      *(_DWORD *)(v13 + 8) = v24;
      memcpy(v24, (const void *)v8[2], v22);
def_E92A:
      sub_E9E0((int)v8, v13, v14, v17);
      return v13;
    case 2:
    case 4:
      v17 = v8[3];
      *(_DWORD *)(v13 + 12) = v17;
      goto def_E92A;
    case 3:
      v17 = v8[3];
      *(_DWORD *)(v13 + 12) = v17;
      goto def_E92A;
    case 6:
      *(_BYTE *)(v13 + 12) = *((_BYTE *)v8 + 12);
      *(_BYTE *)(v13 + 13) = *((_BYTE *)v8 + 13);
      *(_BYTE *)(v13 + 14) = *((_BYTE *)v8 + 14);
      v17 = *((_BYTE *)v8 + 15);
      *(_BYTE *)(v13 + 15) = v17;
      goto def_E92A;
    case 1:
      v26 = (const char *)v8[1];
      if ( v26 )
      {
        v27 = strlen(v26);
        v28 = v27 + 1;
        v29 = (void *)sub_1E9D4(v27 + 1);
        *(_DWORD *)(v13 + 4) = v29;
        memcpy(v29, (const void *)v8[1], v28);
      }
      goto def_E92A;
    case 7:
      v30 = sub_1E9D4(8u);
      *(_DWORD *)(v13 + 4) = v30;
      v31 = v8[1];
      v14 = *(_DWORD *)v31;
      v17 = *(_DWORD *)(v31 + 4);
      *(_DWORD *)v30 = v14;
      *(_DWORD *)(v30 + 4) = v17;
      goto def_E92A;
    default:
      goto def_E92A;
  }
}
// E8D8: could not find valid save-restore pair for r4
// E8D8: could not find valid save-restore pair for r5
// E8D8: could not find valid save-restore pair for r6
// E8D8: could not find valid save-restore pair for r7
// E8D8: variables would overlap: r3.4 and r3.8
// E8D8: variables would overlap: r4.4 and r3.8
// E8D8: variables would overlap: r5.4 and r5.8
// E8D8: variables would overlap: r6.4 and r5.8
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (0000E9E0) --------------------------------------------------------
int __fastcall sub_E9E0(int result, int a2, int a3, int a4)
{
  int v4; // r8@1
  int v5; // r4@1
  int v6; // r5@2

  v4 = a2;
  v5 = *(_DWORD *)(result + 24);
  if ( v5 )
  {
    v6 = 0;
    do
    {
      while ( 1 )
      {
        result = sub_E8D8((_DWORD *)v5, a2, a3, a4);
        if ( !v6 )
          break;
        *(_DWORD *)(v6 + 20) = result;
        v6 = result;
        *(_DWORD *)(result + 20) = 0;
        v5 = *(_DWORD *)(v5 + 20);
        if ( !v5 )
          return result;
      }
      *(_DWORD *)(v4 + 24) = result;
      v6 = result;
      *(_DWORD *)(result + 20) = 0;
      v5 = *(_DWORD *)(v5 + 20);
    }
    while ( v5 );
  }
  return result;
}
// E9E0: could not find valid save-restore pair for r4
// E9E0: could not find valid save-restore pair for r5
// E9E0: could not find valid save-restore pair for r6
// E9E0: could not find valid save-restore pair for r7

//----- (0000EA24) --------------------------------------------------------
int __fastcall sub_EA24(int result, int a2, int a3, int a4)
{
  int v4; // r9@1
  _DWORD *i; // r8@1
  int v6; // r4@2
  const char *v7; // r6@5
  const char *v8; // r0@5

  v4 = result;
  for ( i = *(_DWORD **)(a2 + 24); i; i = (_DWORD *)i[5] )
  {
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = (const char *)off_2909C(*i);
        v8 = (const char *)off_2909C(*(_DWORD *)v6);
        if ( !strcmp(v7, v8) )
          break;
        v6 = *(_DWORD *)(v6 + 20);
        if ( !v6 )
          goto LABEL_9;
      }
      result = sub_EA24(v6, i);
    }
    else
    {
LABEL_9:
      result = sub_E8D8(i, a2, a3, a4);
      a3 = *(_DWORD *)(v4 + 24);
      if ( a3 )
      {
        while ( 1 )
        {
          a4 = *(_DWORD *)(a3 + 20);
          if ( !a4 )
            break;
          a3 = *(_DWORD *)(a3 + 20);
        }
        *(_DWORD *)(a3 + 20) = result;
      }
      else
      {
        *(_DWORD *)(v4 + 24) = result;
      }
    }
  }
  return result;
}
// EA24: could not find valid save-restore pair for r4
// EA24: could not find valid save-restore pair for r5
// EA24: could not find valid save-restore pair for r6
// EA24: could not find valid save-restore pair for r7
// EA24: could not find valid save-restore pair for r8
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (0000EAB0) --------------------------------------------------------
int __fastcall sub_EAB0(int result, int a2, int a3)
{
  int *v3; // r6@1
  int v4; // r8@1
  int v5; // r5@1
  int v6; // r4@2
  int v7; // r1@3

  v3 = (int *)a2;
  v4 = result;
  v5 = *(_DWORD *)(a2 + 12);
  if ( v5 > 0 )
  {
    v6 = 0;
    do
    {
      v7 = *(_DWORD *)(*v3 + 4 * v6++);
      result = sub_EA24(v4, v7, a3, *v3);
    }
    while ( v6 != v5 );
  }
  return result;
}
// EAB0: could not find valid save-restore pair for r4
// EAB0: could not find valid save-restore pair for r5
// EAB0: could not find valid save-restore pair for r6
// EAB0: could not find valid save-restore pair for r7

//----- (0000EAE4) --------------------------------------------------------
int __fastcall sub_EAE4(int result)
{
  __int64 v1; // r4@0
  int v2; // lr@0
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r1@2
  int v6; // r2@2
  int v7; // r3@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v2;
  *(_QWORD *)&v8 = v1;
  v3 = *(_DWORD *)(result + 24);
  v4 = result;
  if ( v3 )
  {
    sub_DB5C(*(_DWORD *)(result + 24));
    result = sub_DB40(v3, v5, v6, v7);
  }
  *(_DWORD *)(v4 + 24) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  return result;
}
// EAE4: could not find valid save-restore pair for r4
// EAE4: could not find valid save-restore pair for r5
// EAE4: could not find valid save-restore pair for r7

//----- (0000EB0C) --------------------------------------------------------
int __fastcall sub_EB0C(int result, int a2, int a3, int a4)
{
  int v4; // r4@1
  int v5; // r1@2
  int v6; // r2@2
  int v7; // [sp+0h] [bp+0h]@1

  v7 = a4;
  v4 = result;
  if ( result )
  {
    sub_DB5C(result);
    result = sub_DB40(v4, v5, v6, v7);
  }
  return result;
}
// EB0C: could not find valid save-restore pair for r4

//----- (0000EB34) --------------------------------------------------------
void __fastcall sub_EB34(int *a1, int a2, int a3)
{
  int v3; // lr@0
  int v4; // r8@1
  int v5; // r6@1
  char *v6; // r4@1
  int v7; // r3@1
  int v8; // r2@1
  char *v9; // r1@1
  int v10; // r0@3
  int v11; // r2@5
  int v12; // r3@9
  int v13; // r9@13
  int v14; // r2@17
  char *v15; // r0@18
  int v16; // r3@19
  _DWORD *v17; // r0@22
  int v18; // r5@22
  char *v19; // r0@22
  char *v20; // r4@22
  int v21; // r3@28
  int v22; // r10@30
  void *v23; // r0@31
  signed int v24; // r10@33
  unsigned int v31; // r3@37
  unsigned int v32; // r10@47
  void *v33; // r0@47
  int v34; // r4@48
  char *v35; // r0@48
  void *v36; // r5@54
  int v37; // r4@54
  int v38; // r0@55
  int v39; // r0@57
  int v40; // t1@57
  int v41; // r0@59
  int v42; // r1@61
  int v43; // r1@61
  int v44; // r2@61
  int v45; // r3@61
  signed int v46; // r2@71
  char v47; // lr@72
  signed int v48; // r3@72
  double *v49; // r0@77
  double v50; // r2@77
  int v51; // r4@81
  void *v52; // r5@82
  int v53; // r4@82
  int v54; // r0@83
  int v55; // r0@85
  int v56; // t1@85
  int v57; // r0@87
  void *v58; // r5@89
  int v59; // r4@89
  int v60; // r0@90
  int v61; // r0@92
  int v62; // t1@92
  int v63; // r0@94
  void *v64; // r5@97
  int v65; // r4@97
  int v66; // r0@98
  int v67; // r0@100
  int v68; // t1@100
  int v69; // r0@102
  void *v70; // r5@105
  int v71; // r4@105
  int v72; // r0@106
  int v73; // r0@108
  int v74; // t1@108
  int v75; // r0@110
  char *v76; // [sp+4h] [bp+4h]@17
  int v77; // [sp+8h] [bp+8h]@1
  char *v78; // [sp+Ch] [bp+Ch]@17
  double v79; // [sp+10h] [bp+10h]@33
  int v80; // [sp+18h] [bp+18h]@25
  const char *v81; // [sp+1Ch] [bp+1Ch]@17
  unsigned __int8 v82; // [sp+20h] [bp+20h]@18
  int v83; // [sp+28h] [bp+28h]@17
  unsigned int v84; // [sp+30h] [bp+30h]@33
  unsigned int v85; // [sp+38h] [bp+38h]@33
  int v86; // [sp+6Ch] [bp+6Ch]@1

  v4 = a3;
  v5 = (int)a1;
  v86 = v3;
  v6 = (char *)&unk_2B928;
  v7 = dword_2B944;
  v77 = a2;
  v8 = *a1;
  v9 = (char *)&unk_2B928;
  if ( dword_2B944 <= 63 )
    v6 = (char *)&unk_2B928 + 4 * dword_2B944;
  v10 = dword_2B948;
  if ( dword_2B944 <= 63 )
    *((_DWORD *)v6 - 58) = v8;
  v11 = v7 + 1;
  if ( v7 + 1 > v10 )
    v10 = v7;
  if ( v11 <= 63 )
  {
    v9 = (char *)&unk_2B928 + 4 * v11;
    v6 = (char *)-1;
  }
  v12 = v7 + 2;
  if ( v11 <= 63 )
    *((_DWORD *)v9 - 58) = v6;
  if ( v10 < v12 )
    v10 = v11;
  dword_2B944 = v12;
  dword_2B948 = v10;
  v13 = *(_DWORD *)(v5 + 24);
  if ( v13 )
  {
    while ( *(_DWORD *)(v13 + 20) )
      v13 = *(_DWORD *)(v13 + 20);
  }
  v14 = 4 * v11;
  v81 = (const char *)&v83;
  v78 = (char *)&unk_2B928 + v14;
  v76 = (char *)&unk_2B928 + v14;
  while ( 1 )
  {
    v15 = sub_CF20(v5, v4, &v82, &v83);
    if ( !v15 )
    {
      Warning("KeyValues Error: %s in file %s\n", "RecursiveLoadFromBuffer:  got EOF instead of keyname", dword_2B940);
      if ( dword_2B948 <= 0 )
      {
LABEL_95:
        Warning("\n");
        goto LABEL_80;
      }
      v58 = &unk_2B83C;
      v59 = 0;
      v81 = "(*%s*), ";
      while ( 1 )
      {
LABEL_92:
        v62 = *((_DWORD *)v58 + 1);
        v58 = (char *)v58 + 4;
        v61 = v62;
        if ( v62 == -1 )
          goto LABEL_91;
        if ( dword_2B944 > v59 )
          break;
        v63 = off_2909C(v61);
        Warning(v81, v63);
        if ( ++v59 >= dword_2B948 )
          goto LABEL_95;
      }
      v60 = off_2909C(v61);
      Warning("%s, ", v60);
LABEL_91:
      if ( ++v59 >= dword_2B948 )
        goto LABEL_95;
      goto LABEL_92;
    }
    v16 = (unsigned __int8)*v15;
    if ( !*v15 )
    {
      Warning("KeyValues Error: %s in file %s\n", "RecursiveLoadFromBuffer:  got empty keyname", dword_2B940);
      if ( dword_2B948 <= 0 )
      {
LABEL_103:
        Warning("\n");
        goto LABEL_80;
      }
      v64 = &unk_2B83C;
      v65 = 0;
      v81 = "(*%s*), ";
      while ( 1 )
      {
LABEL_100:
        v68 = *((_DWORD *)v64 + 1);
        v64 = (char *)v64 + 4;
        v67 = v68;
        if ( v68 == -1 )
          goto LABEL_99;
        if ( dword_2B944 > v65 )
          break;
        v69 = off_2909C(v67);
        Warning(v81, v69);
        if ( ++v65 >= dword_2B948 )
          goto LABEL_103;
      }
      v66 = off_2909C(v67);
      Warning("%s, ", v66);
LABEL_99:
      if ( ++v65 >= dword_2B948 )
        goto LABEL_103;
      goto LABEL_100;
    }
    if ( v16 == 125 )
    {
      v16 = v82;
      if ( !v82 )
        goto LABEL_80;
    }
    v17 = (_DWORD *)sub_E694(v5, (int)v15, v13, v16);
    v18 = (int)v17;
    *((_DWORD *)v78 - 58) = *v17;
    v19 = sub_CF20(v5, v4, &v82, &v83);
    v20 = v19;
    if ( (_BYTE)v83 )
    {
      if ( !v19 )
        goto LABEL_78;
      if ( *(_BYTE *)(v5 + 18) )
        v80 = sub_D514((int)v19);
      else
        v80 = 1;
      v20 = sub_CF20(v5, v4, &v82, &v83);
    }
    else
    {
      v80 = 1;
    }
    if ( !v20 )
    {
LABEL_78:
      Warning("KeyValues Error: %s in file %s\n", "RecursiveLoadFromBuffer:  got NULL key", dword_2B940);
      if ( dword_2B948 > 0 )
      {
        v52 = &unk_2B83C;
        v53 = 0;
        v81 = "(*%s*), ";
        do
        {
          v56 = *((_DWORD *)v52 + 1);
          v52 = (char *)v52 + 4;
          v55 = v56;
          if ( v56 != -1 )
          {
            if ( dword_2B944 > v53 )
            {
              v54 = off_2909C(v55);
              Warning("%s, ", v54);
            }
            else
            {
              v57 = off_2909C(v55);
              Warning(v81, v57);
            }
          }
          ++v53;
        }
        while ( v53 < dword_2B948 );
      }
      Warning("\n");
LABEL_80:
      dword_2B944 -= 2;
      JUMPOUT(__CS__, v83);
    }
    v21 = *v20;
    if ( v21 == 125 )
    {
      if ( !v82 )
      {
        Warning("KeyValues Error: %s in file %s\n", "RecursiveLoadFromBuffer:  got } in key", dword_2B940);
        if ( dword_2B948 > 0 )
        {
          v36 = &unk_2B83C;
          v37 = 0;
          v81 = "(*%s*), ";
          do
          {
            v40 = *((_DWORD *)v36 + 1);
            v36 = (char *)v36 + 4;
            v39 = v40;
            if ( v40 != -1 )
            {
              if ( dword_2B944 > v37 )
              {
                v38 = off_2909C(v39);
                Warning("%s, ", v38);
              }
              else
              {
                v41 = off_2909C(v39);
                Warning(v81, v41);
              }
            }
            ++v37;
          }
          while ( v37 < dword_2B948 );
        }
        Warning("\n");
        goto LABEL_80;
      }
    }
    else if ( v21 == 123 && !v82 )
    {
      v42 = v77;
      *((_DWORD *)v76 - 58) = -1;
      sub_EB34(v18, v42, v4);
      goto LABEL_62;
    }
    v22 = (unsigned __int8)v83;
    if ( (_BYTE)v83 )
    {
      Warning(
        "KeyValues Error: %s in file %s\n",
        "RecursiveLoadFromBuffer:  got conditional between key and value",
        dword_2B940);
      if ( dword_2B948 <= 0 )
      {
LABEL_111:
        Warning("\n");
        goto LABEL_80;
      }
      v70 = &unk_2B83C;
      v71 = 0;
      v81 = "(*%s*), ";
      while ( 1 )
      {
LABEL_108:
        v74 = *((_DWORD *)v70 + 1);
        v70 = (char *)v70 + 4;
        v73 = v74;
        if ( v74 == -1 )
          goto LABEL_107;
        if ( dword_2B944 > v71 )
          break;
        v75 = off_2909C(v73);
        Warning(v81, v75);
        if ( ++v71 >= dword_2B948 )
          goto LABEL_111;
      }
      v72 = off_2909C(v73);
      Warning("%s, ", v72);
LABEL_107:
      if ( ++v71 >= dword_2B948 )
        goto LABEL_111;
      goto LABEL_108;
    }
    v23 = *(void **)(v18 + 4);
    if ( v23 )
    {
      operator delete(v23);
      *(_DWORD *)(v18 + 4) = v22;
    }
    v24 = strlen(v20);
    LODWORD(v79) = strtol(v20, (char **)&v84, 10);
    _R0 = COERCE_UNSIGNED_INT64(strtod(v20, (char **)&v85));
    __asm
    {
      VMOV            D16, R0, R1
      VCVT.F32.F64    S16, D16
    }
    if ( !_ZF & _CF )
      HIDWORD(_R0) = (unsigned int)(*(_DWORD *)_errno() - 34) <= 0;
    else
      HIDWORD(_R0) = 0;
    if ( v24 > 1 )
    {
      v31 = v20[1];
      if ( v31 <= 0xFF )
        v31 = *(_WORD *)(tolower_tab_ + 2 * (v31 + 1));
      if ( v31 == 120 )
      {
        __asm { VLDREQ          S16, =0.0 }
        v85 = (unsigned int)v20;
      }
    }
    if ( !*v20 )
      break;
    if ( v24 != 18 || *v20 != 48 || v20[1] != 120 )
    {
      LODWORD(_R0) = &v20[v24];
      if ( v85 > v84 && LODWORD(_R0) == v85 )
      {
        __asm { VSTREQ          S16, [R5,#0xC] }
        *(_BYTE *)(v18 + 16) = 3;
        goto LABEL_48;
      }
      if ( *(_QWORD *)&_R0 != v84 )
        break;
      v51 = LODWORD(v79);
      *(_BYTE *)(v18 + 16) = 2;
      *(_DWORD *)(v18 + 12) = v51;
    }
    else
    {
      __asm { VMOV.I32        D16, #0 }
      v46 = 2;
      __asm
      {
        VMOV            R0, R1, D16
        VSTR            D16, [R7,#0x70+var_60]
      }
      do
      {
        v47 = v20[v46];
        v48 = (unsigned __int8)v20[v46];
        if ( v48 <= 96 )
        {
          if ( v48 > 64 )
            v48 = (char)(v47 - 7);
        }
        else
        {
          v48 = (char)(v47 - 39);
        }
        ++v46;
        HIDWORD(_R0) = *(_QWORD *)&_R0 >> 28;
        LODWORD(_R0) *= 16;
        *(_QWORD *)&_R0 += v48 - 48;
      }
      while ( v46 != 18 );
      v79 = _R0;
      v49 = (double *)sub_1E9D4(8u);
      v50 = v79;
      *(_DWORD *)(v18 + 4) = v49;
      *v49 = v50;
      *(_BYTE *)(v18 + 16) = 7;
    }
LABEL_48:
    v34 = *(_DWORD *)(v4 + 12);
    v35 = sub_CF20(v5, v4, &v82, &v83);
    if ( (_BYTE)v83 )
    {
      if ( !*(_BYTE *)(v5 + 18) )
        goto LABEL_50;
      v80 = sub_D514((int)v35);
    }
    else
    {
      sub_14C74(v4, 0, v34);
    }
LABEL_62:
    if ( v80 )
    {
LABEL_50:
      v13 = v18;
    }
    else
    {
      if ( v13 )
        *(_DWORD *)(v13 + 20) = v80;
      else
        *(_DWORD *)(v5 + 24) = 0;
      sub_EB0C(v18, v43, v44, v45);
    }
  }
  v32 = v24 + 1;
  *(_BYTE *)(v18 + 16) = 1;
  v33 = (void *)sub_1E9D4(v32);
  *(_DWORD *)(v18 + 4) = v33;
  memcpy(v33, v20, v32);
  goto LABEL_48;
}
// 33CC: using guessed type int _errno(void);
// 365C: using guessed type int Warning(const char *, ...);
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);
// 2B940: using guessed type int dword_2B940;
// 2B944: using guessed type int dword_2B944;
// 2B948: using guessed type int dword_2B948;

//----- (0000F228) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_F228(int a1, int a2, signed int a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  int v8; // r9@0 OVERLAPPED
  int v10; // r11@0
  int v11; // lr@0
  signed int v12; // r11@1
  int v13; // r6@1
  int v14; // r4@1
  int v16; // r2@5
  int v17; // r3@6
  int v18; // r8@7
  int *v19; // r5@9
  int (__fastcall *v20)(int *, signed int); // r3@10
  int v21; // r1@10
  int v22; // r2@10
  int v23; // r3@10
  int v24; // r3@11
  char v25; // r8@11
  int v26; // r2@12
  int v27; // r3@13
  char v28; // r8@13
  int v29; // r2@14
  int v30; // r3@15
  char v31; // r8@15
  int v32; // r2@16
  int v33; // r3@17
  char v34; // r8@17
  int v35; // r3@20
  int v36; // r1@22
  int v37; // r2@22
  int v38; // r3@22
  int v39; // r9@24
  int v40; // r3@25
  int v41; // r0@26
  int v42; // r3@29
  size_t v43; // r0@33
  size_t v44; // r8@33
  void *v45; // r0@33
  int v46; // r8@34
  int v47; // r0@35
  int v48; // r2@35
  int v49; // r3@35
  int v50; // r8@35
  int v55; // r1@36
  int v56; // r3@36
  int v57; // r3@40
  int v58; // r0@40
  int v59; // r3@43
  int v60; // r0@45
  int v61; // r2@47
  int v62; // r0@49
  int v63; // r2@50
  int v64; // r1@50
  int v65; // r3@50
  char v66; // r0@51
  int v67; // r1@51
  char v68; // r3@53
  char v69; // r12@53
  char v70; // r0@53
  char v71; // r1@53
  int v72; // r3@56
  int v73; // r3@58
  int v74; // r3@60
  int v75; // r3@62
  int v76; // r2@63
  int *v77; // r1@64
  int v78; // r12@71
  int v80; // r1@74
  int v81; // r3@74
  int v82; // r3@77
  unsigned __int8 v83; // [sp+10h] [bp+10h]@7
  int v84; // [sp+20h] [bp+20h]@64
  int v85; // [sp+28h] [bp+28h]@9
  int v86; // [sp+102Ch] [bp+102Ch]@1
  __int64 v87; // [sp+1030h] [bp+1030h]@1
  __int64 v88; // [sp+1038h] [bp+1038h]@1
  __int64 v89; // [sp+1040h] [bp+1040h]@1
  int v90; // [sp+1048h] [bp+1048h]@1
  int v91; // [sp+104Ch] [bp+104Ch]@1

  v90 = v10;
  v91 = v11;
  v12 = a3;
  v88 = *(_QWORD *)&v6;
  v87 = *(_QWORD *)&v4;
  v13 = a1;
  v86 = v3;
  v14 = a2;
  v89 = *(_QWORD *)&v8;
  if ( *(_BYTE *)(a2 + 21) & 1 )
    return 0;
  if ( *(_BYTE *)(a2 + 20) )
    return 0;
  sub_DB5C(a1);
  sub_CEA0(v13);
  if ( v12 > 100 )
    return 0;
  v17 = *(_BYTE *)(v14 + 21);
  if ( !(v17 & 1) )
  {
    if ( sub_146D0(v14, 1, v16, v17) )
    {
      v82 = *(_DWORD *)(v14 + 12);
      v18 = *(_BYTE *)(*(_DWORD *)v14 + v82 - *(_DWORD *)(v14 + 32));
      *(_DWORD *)(v14 + 12) = v82 + 1;
      goto LABEL_8;
    }
    v19 = &v85;
    v18 = 0;
    v83 = 0;
    while ( 1 )
    {
LABEL_10:
      *(_BYTE *)(v13 + 16) = v18;
      sub_14E58((_DWORD *)v14, v19, 4095);
      v20 = (int (__fastcall *)(int *, signed int))off_290A0;
      *((_BYTE *)v19 + 4095) = 0;
      *(_DWORD *)v13 = v20(v19, 1);
      switch ( v18 )
      {
        case 6:
          v24 = *(_BYTE *)(v14 + 21);
          v25 = v24 & 1;
          if ( v24 & 1 )
          {
            *(_BYTE *)v19 = 0;
            sub_15130(v14, (int)"%u", (int)v19, 0);
            v25 = *(_BYTE *)v19;
          }
          else if ( sub_146D0(v14, 1, v22, v24) )
          {
            v75 = *(_DWORD *)(v14 + 12);
            v26 = *(_DWORD *)v14;
            v25 = *(_BYTE *)(*(_DWORD *)v14 + v75 - *(_DWORD *)(v14 + 32));
            *(_DWORD *)(v14 + 12) = v75 + 1;
          }
          *(_BYTE *)(v13 + 12) = v25;
          v27 = *(_BYTE *)(v14 + 21);
          v28 = v27 & 1;
          if ( v27 & 1 )
          {
            *(_BYTE *)v19 = 0;
            sub_15130(v14, (int)"%u", (int)v19, 0);
            v28 = *(_BYTE *)v19;
          }
          else if ( sub_146D0(v14, 1, v26, v27) )
          {
            v74 = *(_DWORD *)(v14 + 12);
            v29 = *(_DWORD *)v14;
            v28 = *(_BYTE *)(*(_DWORD *)v14 + v74 - *(_DWORD *)(v14 + 32));
            *(_DWORD *)(v14 + 12) = v74 + 1;
          }
          *(_BYTE *)(v13 + 13) = v28;
          v30 = *(_BYTE *)(v14 + 21);
          v31 = v30 & 1;
          if ( v30 & 1 )
          {
            *(_BYTE *)v19 = 0;
            sub_15130(v14, (int)"%u", (int)v19, 0);
            v31 = *(_BYTE *)v19;
          }
          else if ( sub_146D0(v14, 1, v29, v30) )
          {
            v73 = *(_DWORD *)(v14 + 12);
            v32 = *(_DWORD *)v14;
            v31 = *(_BYTE *)(*(_DWORD *)v14 + v73 - *(_DWORD *)(v14 + 32));
            *(_DWORD *)(v14 + 12) = v73 + 1;
          }
          *(_BYTE *)(v13 + 14) = v31;
          v33 = *(_BYTE *)(v14 + 21);
          v34 = v33 & 1;
          if ( v33 & 1 )
          {
            *(_BYTE *)v19 = 0;
            sub_15130(v14, (int)"%u", (int)v19, 0);
            v34 = *(_BYTE *)v19;
          }
          else if ( sub_146D0(v14, 1, v32, v33) )
          {
            v72 = *(_DWORD *)(v14 + 12);
            v34 = *(_BYTE *)(*(_DWORD *)v14 + v72 - *(_DWORD *)(v14 + 32));
            *(_DWORD *)(v14 + 12) = v72 + 1;
          }
          *(_BYTE *)(v13 + 15) = v34;
          break;
        default:
          break;
        case 4:
          v40 = *(_BYTE *)(v14 + 21);
          if ( !(v40 & 1) )
            goto LABEL_41;
          *(v19 - 2) = 0;
          sub_15130(v14, (int)"%u", (int)(v19 - 2), 0);
          v41 = *(v19 - 2);
          goto LABEL_27;
        case 3:
          if ( *(_BYTE *)(v14 + 21) & 1 )
          {
            *(v19 - 2) = 0;
            sub_15130(v14, (int)"%f", (int)(v19 - 2), 0);
            v42 = *(v19 - 2);
          }
          else
          {
            v62 = sub_146D0(v14, 4, v22, *(_BYTE *)(v14 + 21) << 31);
            v42 = 0;
            if ( v62 )
            {
              v63 = *(_DWORD *)(v14 + 12);
              v64 = v63 - *(_DWORD *)(v14 + 32);
              v65 = *(_DWORD *)v14 + v64;
              if ( v65 & 3 )
              {
                v66 = *(_BYTE *)(*(_DWORD *)v14 + v64);
                v67 = (int)(v19 - 2);
                *((_BYTE *)v19 - 8) = v66;
                *(_BYTE *)(v67 + 1) = *(_BYTE *)(v65 + 1);
                *(_BYTE *)(v67 + 2) = *(_BYTE *)(v65 + 2);
                *(_BYTE *)(v67 + 3) = *(_BYTE *)(v65 + 3);
                v42 = *(v19 - 2);
              }
              else
              {
                v42 = *(_DWORD *)v65;
                v67 = (int)(v19 - 2);
                *(v19 - 2) = v42;
              }
              if ( *(_BYTE *)(v14 + 52) & 1 )
              {
                v68 = *(_BYTE *)(v67 + 1);
                v69 = *(_BYTE *)(v67 + 3);
                v70 = *(_BYTE *)(v67 + 2);
                v71 = *(_BYTE *)v67;
                *((_BYTE *)v19 + 2) = v68;
                *(_BYTE *)v19 = v69;
                *((_BYTE *)v19 + 1) = v70;
                *((_BYTE *)v19 + 3) = v71;
                v42 = *v19;
              }
              *(_DWORD *)(v14 + 12) = v63 + 4;
            }
          }
          *(_DWORD *)(v13 + 12) = v42;
          break;
        case 2:
          v40 = *(_BYTE *)(v14 + 21);
          if ( v40 & 1 )
          {
            *(v19 - 2) = 0;
            sub_15130(v14, (int)"%d", (int)(v19 - 2), 0);
            v41 = *(v19 - 2);
          }
          else
          {
LABEL_41:
            v41 = sub_146D0(v14, 4, v22, v40);
            if ( v41 )
            {
              if ( *(_BYTE *)(v14 + 52) & 1 )
              {
                v59 = *(_DWORD *)(v14 + 12);
                v76 = *(_DWORD *)v14 + v59 - *(_DWORD *)(v14 + 32);
                if ( v76 )
                {
                  v77 = &v84;
                }
                else
                {
                  v77 = v19 - 2;
                  v76 = (int)(v19 - 2);
                }
                *v19 = *v77;
                *(_BYTE *)v19 = *(_BYTE *)(v76 + 3);
                *((_BYTE *)v19 + 1) = *(_BYTE *)(v76 + 2);
                *((_BYTE *)v19 + 2) = *(_BYTE *)(v76 + 1);
                *((_BYTE *)v19 + 3) = *(_BYTE *)v76;
                v41 = *v19;
              }
              else
              {
                v59 = *(_DWORD *)(v14 + 12);
                v41 = *(_DWORD *)(*(_DWORD *)v14 + v59 - *(_DWORD *)(v14 + 32));
              }
              *(_DWORD *)(v14 + 12) = v59 + 4;
            }
          }
LABEL_27:
          *(_DWORD *)(v13 + 12) = v41;
          break;
        case 1:
          sub_14E58((_DWORD *)v14, v19, 4095);
          *((_BYTE *)v19 + 4095) = 0;
          v43 = strlen((const char *)v19);
          v44 = v43 + 1;
          v45 = (void *)sub_1E9D4(v43 + 1);
          *(_DWORD *)(v13 + 4) = v45;
          memcpy(v45, v19, v44);
          break;
        case 0:
          v46 = sub_DB08(32, v21, v22, v23);
          sub_CECC(v46, (int)"");
          *(_DWORD *)(v13 + 24) = v46;
          sub_F228(v46, v14, v12 + 1);
          break;
        case 7:
          v47 = sub_1E9D4(8u);
          *(_DWORD *)(v13 + 4) = v47;
          v49 = *(_BYTE *)(v14 + 21);
          v50 = v47;
          if ( v49 & 1 )
          {
            __asm
            {
              VMOV.I32        D16, #0
              VSTR            D16, [R5,#-8]
            }
            sub_15130(v14, (int)"%lld", (int)(v19 - 2), v49);
            v56 = *((_QWORD *)v19 - 1) >> 32;
            v55 = *((_QWORD *)v19 - 1);
          }
          else
          {
            v60 = sub_146D0(v14, 8, v48, v49);
            v55 = 0;
            v56 = 0;
            if ( v60 )
            {
              if ( *(_BYTE *)(v14 + 52) & 1 )
              {
                v61 = *(_DWORD *)(v14 + 12);
                v78 = *(_DWORD *)v14 + v61 - *(_DWORD *)(v14 + 32);
                if ( v78 )
                {
                  _R1 = &v84;
                }
                else
                {
                  _R1 = v19 - 2;
                  v78 = (int)(v19 - 2);
                }
                __asm { VLDR            D16, [R1] }
                v80 = 0;
                v81 = 0;
                __asm { VSTR            D16, [R5] }
                do
                {
                  ++v81;
                  *((_BYTE *)v19 + v80) = *(_BYTE *)(v78 + 7 - v80);
                  v80 = v81;
                }
                while ( v81 != 8 );
                v56 = *(_QWORD *)v19 >> 32;
                v55 = *(_QWORD *)v19;
              }
              else
              {
                v61 = *(_DWORD *)(v14 + 12);
                v56 = *(_QWORD *)(*(_DWORD *)v14 + v61 - *(_DWORD *)(v14 + 32)) >> 32;
                v55 = *(_QWORD *)(*(_DWORD *)v14 + v61 - *(_DWORD *)(v14 + 32));
              }
              *(_DWORD *)(v14 + 12) = v61 + 8;
            }
          }
          *(_DWORD *)v50 = v55;
          *(_DWORD *)(v50 + 4) = v56;
          break;
      }
      v35 = *(_BYTE *)(v14 + 20);
      if ( *(_BYTE *)(v14 + 20) )
        return 0;
      if ( *(_BYTE *)(v14 + 21) & 1 )
      {
        *((_BYTE *)v19 - 16) = v35;
        sub_15130(v14, (int)"%u", (int)(v19 - 4), v35);
        v18 = *((_BYTE *)v19 - 16);
      }
      else
      {
        if ( !sub_146D0(v14, 1, *(_BYTE *)(v14 + 21) << 31, *(_BYTE *)(v14 + 20)) )
        {
          *((_BYTE *)v19 - 16) = 0;
          v18 = 0;
          goto LABEL_24;
        }
        v57 = *(_DWORD *)(v14 + 12);
        v36 = *(_DWORD *)(v14 + 32);
        v37 = *(_DWORD *)v14;
        v58 = v57 + 1;
        v38 = v57 - v36;
        v18 = *(_BYTE *)(*(_DWORD *)v14 + v38);
        *(_DWORD *)(v14 + 12) = v58;
      }
      if ( v18 == 8 )
        return *(_BYTE *)(v14 + 20) == 0;
LABEL_24:
      v39 = sub_DB08(32, v36, v37, v38);
      sub_CECC(v39, (int)"");
      *(_DWORD *)(v13 + 20) = v39;
      v13 = v39;
    }
  }
  v83 = 0;
  sub_15130(v14, (int)"%u", (int)&v83, v17);
  v18 = v83;
LABEL_8:
  if ( v18 != 8 )
  {
    v19 = &v85;
    goto LABEL_10;
  }
  return *(_BYTE *)(v14 + 20) == 0;
}
// F228: could not find valid save-restore pair for r4
// F228: could not find valid save-restore pair for r5
// F228: could not find valid save-restore pair for r6
// F228: could not find valid save-restore pair for r7
// F228: could not find valid save-restore pair for r8
// F228: could not find valid save-restore pair for r9
// F228: could not find valid save-restore pair for r10
// F228: could not find valid save-restore pair for r11
// F228: variables would overlap: r5.4 and r5.8
// F228: variables would overlap: r6.4 and r5.8
// F228: variables would overlap: r7.4 and r7.8
// F228: variables would overlap: r8.4 and r7.8
// F228: variables would overlap: r9.4 and r9.8
// F228: variables would overlap: r10.4 and r9.8
// 290A0: using guessed type int (__fastcall *off_290A0)(_DWORD, _DWORD);

//----- (0000F70C) --------------------------------------------------------
int __fastcall sub_F70C(int a1, int a2)
{
  int v2; // lr@0
  int v3; // r6@1
  int v4; // r4@1
  int (*v5)(void); // r3@1
  int result; // r0@3
  int (__fastcall *v7)(int, int); // r5@5
  int v8; // r0@5
  int v9; // r3@7
  _DWORD *v10; // r0@12
  int v11; // r2@13
  _DWORD *v12; // r1@14
  char *v13; // r4@15
  int v14; // r0@16
  int v19; // r0@20
  int (__fastcall *v20)(int, int); // r4@20
  int v21; // r0@20
  int v22; // r0@22
  char v23; // [sp+10h] [bp-88h]@10
  int v24; // [sp+88h] [bp-10h]@15
  char v25; // [sp+98h] [bp+0h]@15
  int v26; // [sp+ACh] [bp+14h]@1

  v3 = a1;
  v4 = a2;
  v26 = v2;
  v5 = *(int (**)(void))(*(_DWORD *)a1 + 12);
  if ( !a2 )
  {
    if ( v5() )
      return (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v3 + 16))(v3, "<< NULL >>\n");
    return 0;
  }
  if ( !v5() )
    return 0;
  v7 = *(int (__fastcall **)(int, int))(*(_DWORD *)v3 + 16);
  v8 = off_2909C(*(_DWORD *)v4);
  if ( !v7(v3, v8) || !(*(int (__fastcall **)(int, char *))(*(_DWORD *)v3 + 16))(v3, " ") )
    return 0;
  v9 = *(_BYTE *)(v4 + 16);
  switch ( v9 )
  {
    case 7:
      sub_DDE0(v4, 0, 0);
      sub_12440(&v23, 0x80u, "u64( %lld = 0x%llX )");
      if ( !(*(int (__fastcall **)(_DWORD, char *))(*(_DWORD *)v3 + 16))(v3, &v23) )
        return 0;
      goto def_F774;
    default:
      goto def_F774;
    case 5:
      v10 = (_DWORD *)sub_E3E8(v4, 0, (int)&unk_1FC94);
      if ( *v10 )
      {
        v11 = (int)(v10 + 1);
        do
        {
          v12 = (_DWORD *)v11;
          v11 += 4;
        }
        while ( *v12 );
      }
      else
      {
        v12 = v10;
      }
      v13 = &v25;
      v24 = v12 - v10;
      sub_12440(&v25, 2 * (v24 + 32), "%ls [wstring, len = %d]");
      goto LABEL_17;
    case 4:
      v14 = sub_DF20(v4, 0, 0, v9);
      v13 = &v23;
      sub_12440(&v23, 0x80u, "ptr( 0x%p )", v14);
      goto LABEL_17;
    case 3:
      __asm { VLDR            S0, =0.0 }
      sub_DF4C(v4, 0);
      __asm { VCVT.F64.F32    D0, S0 }
      v13 = &v23;
      __asm { VSTR            D0, [SP,#0xB0+var_B0] }
      sub_12440(&v23, 0x80u, "float( %f )");
      goto LABEL_17;
    case 1:
      v19 = v4;
      v20 = *(int (__fastcall **)(int, int))(*(_DWORD *)v3 + 16);
      v21 = sub_E238(v19, 0, (int)"");
      if ( !v20(v3, v21) )
        return 0;
      goto def_F774;
    case 2:
      v22 = sub_DCF8(v4, 0, 0);
      v13 = &v23;
      sub_12440(&v23, 0x80u, "int( %d = 0x%X )", v22, v22);
LABEL_17:
      if ( !(*(int (__fastcall **)(_DWORD, char *))(*(_DWORD *)v3 + 16))(v3, v13) )
        return 0;
def_F774:
      result = (*(int (__fastcall **)(_DWORD, char *))(*(_DWORD *)v3 + 16))(v3, "\n");
      break;
  }
  return result;
}
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (0000FB40) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_FB40(int a1, char *a2)
{
  int v2; // r4@0
  int v3; // r5@0 OVERLAPPED
  __int64 v5; // r7@0
  int v6; // r9@0 OVERLAPPED
  int v8; // r11@0
  int v9; // lr@0
  int v10; // r10@1
  char *v11; // r5@1
  int v12; // r4@2
  _BYTE *v13; // r0@3
  const char *v14; // r0@4
  const char *v15; // r0@4
  char *v16; // r9@4
  int v17; // r0@6
  int v18; // r2@7
  int v19; // r3@11
  signed int result; // r0@15
  int v21; // [sp+0h] [bp+0h]@4
  int v22; // [sp+84h] [bp+84h]@1
  __int64 v23; // [sp+88h] [bp+88h]@1
  __int64 v24; // [sp+90h] [bp+90h]@1
  __int64 v25; // [sp+98h] [bp+98h]@1
  int v26; // [sp+A0h] [bp+A0h]@1
  int v27; // [sp+A4h] [bp+A4h]@1

  v25 = *(_QWORD *)&v6;
  v10 = a1;
  v24 = v5;
  v23 = *(_QWORD *)&v3;
  v11 = a2;
  v26 = v8;
  v27 = v9;
  v22 = v2;
  if ( a2 )
  {
    v12 = *(_DWORD *)(a1 + 24);
    if ( v12 )
    {
      do
      {
        sub_FB40(v12, v11);
        v13 = (_BYTE *)off_2909C(*(_DWORD *)v12);
        if ( sub_12140(v13, v11) )
        {
          v14 = (const char *)off_2909C(*(_DWORD *)v12);
          sub_12330((char *)&v21, v14, 0x80u);
          v15 = sub_121F8(&v21, v11);
          v16 = (char *)v15;
          if ( v15 )
          {
            if ( !sub_11A70(v15, v11) )
            {
              *v16 = 0;
              v17 = sub_DBF0(v10, (const char *)&v21, 0);
              if ( v17 )
              {
                v18 = *(_DWORD *)(v10 + 24);
                if ( v17 == v18 )
                {
                  *(_DWORD *)(v10 + 24) = *(_DWORD *)(v17 + 20);
                }
                else
                {
                  while ( 1 )
                  {
                    v19 = *(_DWORD *)(v18 + 20);
                    if ( !v19 )
                      break;
                    if ( v17 == v19 )
                    {
                      *(_DWORD *)(v18 + 20) = *(_DWORD *)(v17 + 20);
                      break;
                    }
                    v18 = *(_DWORD *)(v18 + 20);
                  }
                }
                *(_DWORD *)(v17 + 20) = 0;
              }
              *(_DWORD *)v12 = off_290A0(&v21, 1);
            }
          }
        }
        v12 = *(_DWORD *)(v12 + 20);
      }
      while ( v12 );
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// FB40: could not find valid save-restore pair for r4
// FB40: could not find valid save-restore pair for r5
// FB40: could not find valid save-restore pair for r6
// FB40: could not find valid save-restore pair for r7
// FB40: could not find valid save-restore pair for r8
// FB40: could not find valid save-restore pair for r9
// FB40: could not find valid save-restore pair for r10
// FB40: could not find valid save-restore pair for r11
// FB40: variables would overlap: r5.4 and r5.8
// FB40: variables would overlap: r6.4 and r5.8
// FB40: variables would overlap: r9.4 and r9.8
// FB40: variables would overlap: r10.4 and r9.8
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);
// 290A0: using guessed type int (__fastcall *off_290A0)(_DWORD, _DWORD);

//----- (0000FC28) --------------------------------------------------------
int __fastcall sub_FC28(int a1, int (__fastcall ***a2)(_DWORD, _DWORD), int a3)
{
  int (__fastcall ***v3)(_DWORD, _DWORD); // r8@1
  int v4; // r5@1
  int v5; // r6@1
  int v6; // r2@3
  int v7; // r4@3
  int v8; // r4@9

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( !(**a2)(a2, a1) )
    return 0;
  if ( !v4 )
    return ((int (__fastcall *)(int (__fastcall ***)(_DWORD, _DWORD), int, int))(*v3)[2])(v3, v4, v5);
  v6 = *(_DWORD *)(v4 + 24);
  v7 = v6;
  if ( !v6 )
    return ((int (__fastcall *)(int (__fastcall ***)(_DWORD, _DWORD), int, int))(*v3)[2])(v3, v4, v5);
  if ( !*(_BYTE *)(v6 + 16) )
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(v7 + 20);
      if ( !v7 )
        break;
      if ( *(_BYTE *)(v7 + 16) )
        goto LABEL_5;
    }
    v8 = *(_DWORD *)(v4 + 24);
LABEL_15:
    while ( *(_BYTE *)(v8 + 16) )
    {
      v8 = *(_DWORD *)(v8 + 20);
      if ( !v8 )
        return ((int (__fastcall *)(_DWORD, _DWORD, _DWORD))(*v3)[2])(v3, v4, v5);
    }
LABEL_16:
    if ( !sub_FC28(v8, v3, v5 + 1) )
      return 0;
    while ( 1 )
    {
      v8 = *(_DWORD *)(v8 + 20);
      if ( !v8 )
        return ((int (__fastcall *)(_DWORD, _DWORD, _DWORD))(*v3)[2])(v3, v4, v5);
      if ( !*(_BYTE *)(v8 + 16) )
        goto LABEL_16;
    }
  }
LABEL_5:
  if ( ((int (__fastcall *)(int (__fastcall ***)(_DWORD, _DWORD), int, int))(*v3)[1])(v3, v7, v5 + 1) )
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(v7 + 20);
      if ( !v7 )
        break;
      if ( *(_BYTE *)(v7 + 16) )
        goto LABEL_5;
    }
    v8 = *(_DWORD *)(v4 + 24);
    if ( v8 )
      goto LABEL_15;
    return ((int (__fastcall *)(_DWORD, _DWORD, _DWORD))(*v3)[2])(v3, v4, v5);
  }
  return 0;
}
// FC28: could not find valid save-restore pair for r4
// FC28: could not find valid save-restore pair for r5
// FC28: could not find valid save-restore pair for r6
// FC28: could not find valid save-restore pair for r7
// FC28: could not find valid save-restore pair for r8

//----- (0000FCE0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_FCE0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4@0
  int v6; // r5@0 OVERLAPPED
  __int64 v8; // r7@0
  __int64 v9; // r9@0
  int v10; // r11@0
  int v11; // lr@0
  char *v12; // r0@2
  int *v13; // r1@2
  int v14; // r2@2
  const char *v15; // r4@2
  char *v16; // r0@6
  void *v17; // r5@9
  int v18; // r4@9
  int v19; // r0@10
  int v20; // r0@12
  int v21; // t1@12
  int v22; // r0@14
  int v23; // r4@17
  int v24; // r3@18
  int v25; // r5@18
  int i; // r0@19
  int v27; // t1@19
  int v28; // r1@23
  int v29; // r2@23
  int v30; // r3@23
  char *v31; // r0@26
  char *v32; // r3@26
  int v33; // r4@33
  void *v34; // r5@33
  int v35; // r0@34
  int v36; // r0@36
  int v37; // t1@36
  int v38; // r0@38
  char *v39; // r0@46
  void *v40; // r5@49
  int v41; // r4@49
  int v42; // r0@50
  int v43; // r0@52
  int v44; // t1@52
  int v45; // r0@54
  char v46; // r3@60
  char v47; // r3@62
  int v48; // r4@66
  int v49; // r5@67
  int v50; // r1@70
  int v51; // r2@70
  int v52; // r4@70
  int v53; // r5@71
  int v54; // r1@73
  int v55; // r2@73
  int v56; // r1@73
  int v57; // r2@73
  int v58; // r3@73
  int v59; // r1@73
  int v60; // r2@73
  int v62; // [sp+Ch] [bp+4h]@1
  const char *v63; // [sp+14h] [bp+Ch]@1
  int v64; // [sp+28h] [bp+20h]@1
  int v65; // [sp+34h] [bp+2Ch]@28
  int v66; // [sp+38h] [bp+30h]@1
  int v67; // [sp+44h] [bp+3Ch]@1
  int v68; // [sp+48h] [bp+40h]@1
  char v69; // [sp+50h] [bp+48h]@2
  char v70; // [sp+58h] [bp+50h]@2
  int *v71; // [sp+60h] [bp+58h]@1
  int v72; // [sp+64h] [bp+5Ch]@1
  int v73; // [sp+68h] [bp+60h]@1
  int v74; // [sp+6Ch] [bp+64h]@1
  int *v75; // [sp+70h] [bp+68h]@1
  int v76; // [sp+78h] [bp+70h]@1
  int v77; // [sp+7Ch] [bp+74h]@1
  int v78; // [sp+80h] [bp+78h]@1
  int v79; // [sp+84h] [bp+7Ch]@1
  int v80; // [sp+88h] [bp+80h]@1
  int v81; // [sp+94h] [bp+8Ch]@1
  __int64 v82; // [sp+98h] [bp+90h]@1
  __int64 v83; // [sp+A0h] [bp+98h]@1
  __int64 v84; // [sp+A8h] [bp+A0h]@1
  int v85; // [sp+B0h] [bp+A8h]@1
  int v86; // [sp+B4h] [bp+ACh]@1

  v82 = *(_QWORD *)&v6;
  v83 = v8;
  v81 = v5;
  v85 = v10;
  v86 = v11;
  v84 = v9;
  v67 = a1;
  v63 = (const char *)a2;
  v68 = a3;
  v62 = a4;
  v66 = a1;
  v64 = 0;
  dword_2B940 = a2;
  dword_2B948 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  do
  {
    v12 = sub_CF20(v67, v68, &v69, &v70);
    v15 = v12;
    if ( *(_BYTE *)(v68 + 20) || !v12 || !*v12 )
      break;
    if ( sub_11A70(v12, "#include") )
    {
      if ( sub_11A70(v15, "#base") )
      {
        if ( v66 )
        {
          *(_DWORD *)v66 = off_290A0(v15, 1);
        }
        else
        {
          v66 = sub_DB08(32, v28, v29, v30);
          sub_CECC(v66, (int)v15);
          v46 = *(_BYTE *)(v67 + 17);
          if ( *(_BYTE *)(v67 + 17) )
            v46 = 1;
          *(_BYTE *)(v66 + 17) = v46;
          v47 = *(_BYTE *)(v67 + 18);
          if ( *(_BYTE *)(v67 + 18) )
            v47 = 1;
          *(_BYTE *)(v66 + 18) = v47;
          if ( v64 )
            *(_DWORD *)(v64 + 20) = v66;
        }
        v31 = sub_CF20(v67, v68, &v69, &v70);
        v32 = v31;
        if ( v70 )
        {
          if ( *(_BYTE *)(v67 + 18) )
            v65 = sub_D514((int)v31);
          else
            v65 = 1;
          v32 = sub_CF20(v67, v68, &v69, &v70);
        }
        else
        {
          v65 = 1;
        }
        if ( v32 && *v32 == 123 && !v69 )
        {
          sub_EB34((int *)v66, (int)v63, v68);
LABEL_40:
          if ( v65 )
          {
            v64 = v66;
            v66 = 0;
          }
          else
          {
            if ( v64 )
              *(_DWORD *)(v64 + 20) = 0;
            sub_EAE4(v66);
          }
          continue;
        }
        Warning("KeyValues Error: %s in file %s\n", "LoadFromBuffer: missing {", dword_2B940);
        if ( dword_2B948 <= 0 )
        {
LABEL_39:
          Warning("\n");
          goto LABEL_40;
        }
        v33 = 0;
        v34 = &unk_2B83C;
        while ( 1 )
        {
LABEL_36:
          v37 = *((_DWORD *)v34 + 1);
          v34 = (char *)v34 + 4;
          v36 = v37;
          if ( v37 == -1 )
            goto LABEL_35;
          if ( dword_2B944 > v33 )
            break;
          v38 = off_2909C(v36);
          Warning("(*%s*), ", v38);
          if ( ++v33 >= dword_2B948 )
            goto LABEL_39;
        }
        v35 = off_2909C(v36);
        Warning("%s, ", v35);
LABEL_35:
        if ( ++v33 >= dword_2B948 )
          goto LABEL_39;
        goto LABEL_36;
      }
      v39 = sub_CF20(v67, v68, &v69, &v70);
      if ( v39 && *v39 )
      {
        sub_103D0((_DWORD *)v67, v63, v39, v62, a5, (int)&v76);
        continue;
      }
      Warning("KeyValues Error: %s in file %s\n", "#base is NULL ", dword_2B940);
      if ( dword_2B948 <= 0 )
      {
LABEL_55:
        Warning("\n");
        continue;
      }
      v40 = &unk_2B83C;
      v41 = 0;
      while ( 1 )
      {
LABEL_52:
        v44 = *((_DWORD *)v40 + 1);
        v40 = (char *)v40 + 4;
        v43 = v44;
        if ( v44 == -1 )
          goto LABEL_51;
        if ( dword_2B944 > v41 )
          break;
        v45 = off_2909C(v43);
        Warning("(*%s*), ", v45);
        if ( ++v41 >= dword_2B948 )
          goto LABEL_55;
      }
      v42 = off_2909C(v43);
      Warning("%s, ", v42);
LABEL_51:
      if ( ++v41 >= dword_2B948 )
        goto LABEL_55;
      goto LABEL_52;
    }
    v16 = sub_CF20(v67, v68, &v69, &v70);
    if ( v16 && *v16 )
    {
      sub_103D0((_DWORD *)v67, v63, v16, v62, a5, (int)&v71);
    }
    else
    {
      Warning("KeyValues Error: %s in file %s\n", "#include is NULL ", dword_2B940);
      if ( dword_2B948 > 0 )
      {
        v17 = &unk_2B83C;
        v18 = 0;
        while ( 1 )
        {
          v21 = *((_DWORD *)v17 + 1);
          v17 = (char *)v17 + 4;
          v20 = v21;
          if ( v21 == -1 )
            goto LABEL_11;
          if ( dword_2B944 > v18 )
          {
            v19 = off_2909C(v20);
            Warning("%s, ", v19);
LABEL_11:
            if ( ++v18 >= dword_2B948 )
              break;
          }
          else
          {
            v22 = off_2909C(v20);
            Warning("(*%s*), ", v22);
            if ( ++v18 >= dword_2B948 )
              break;
          }
        }
      }
      Warning("\n");
    }
  }
  while ( !*(_BYTE *)(v68 + 20) );
  v23 = v74;
  if ( v74 > 0 )
  {
    v14 = v67;
    v13 = v71;
    v24 = *(_DWORD *)(v67 + 20);
    v25 = (int)&v71[v74];
    while ( 1 )
    {
      v27 = *v13;
      ++v13;
      for ( i = v27; v24; v24 = *(_DWORD *)(v24 + 20) )
        v14 = v24;
      *(_DWORD *)(v14 + 20) = i;
      if ( v13 == (int *)v25 )
        break;
      v24 = i;
    }
  }
  v48 = v23 - 1;
  if ( v48 > 0 )
  {
    v49 = v48;
    do
    {
      sub_EB0C(v71[v49], (int)v13, v14, (int)v71);
      --v48;
      --v49;
    }
    while ( v48 );
  }
  sub_EAB0(v67, (int)&v76, v14);
  v52 = v79 - 1;
  if ( v79 - 1 >= 0 )
  {
    v53 = 4 * v52;
    do
    {
      sub_EB0C(*(_DWORD *)(v76 + v53), v50, v51, v76);
      --v52;
      v53 -= 4;
    }
    while ( v52 != -1 );
  }
  v79 = 0;
  dword_2B948 = 0;
  dword_2B940 = (int)"";
  sub_113B8((int)&v76, v50, (int)"", (int)&unk_2B928);
  v80 = v76;
  sub_113B8((int)&v76, v54, v55, v76);
  v74 = 0;
  sub_113B8((int)&v71, v56, v57, v58);
  v75 = v71;
  sub_113B8((int)&v71, v59, v60, (int)v71);
  return 1;
}
// FCE0: could not find valid save-restore pair for r4
// FCE0: could not find valid save-restore pair for r5
// FCE0: could not find valid save-restore pair for r6
// FCE0: could not find valid save-restore pair for r7
// FCE0: could not find valid save-restore pair for r8
// FCE0: could not find valid save-restore pair for r9
// FCE0: could not find valid save-restore pair for r10
// FCE0: could not find valid save-restore pair for r11
// FCE0: variables would overlap: r5.4 and r5.8
// FCE0: variables would overlap: r6.4 and r5.8
// 365C: using guessed type int Warning(const char *, ...);
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);
// 290A0: using guessed type int (__fastcall *off_290A0)(_DWORD, _DWORD);
// 2B940: using guessed type int dword_2B940;
// 2B944: using guessed type int dword_2B944;
// 2B948: using guessed type int dword_2B948;

//----- (00010210) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_10210(int a1, int a2, char *s, int a4, int a5)
{
  int v5; // r4@0
  int v6; // r5@0 OVERLAPPED
  int v8; // r7@0 OVERLAPPED
  int v10; // r9@0 OVERLAPPED
  int v12; // r11@0
  int v13; // lr@0
  int v14; // r9@1
  int v15; // r10@1
  int v16; // r8@1
  char *v17; // r4@1
  int v18; // r6@2
  signed int v19; // r4@4
  int v20; // r1@4
  int v21; // r2@4
  int v22; // r3@4
  int v24; // r4@8
  int v25; // r11@8
  _BYTE *v26; // r6@8
  char v27; // r3@8
  int v28; // [sp+8h] [bp+0h]@2
  int v29; // [sp+44h] [bp+3Ch]@1
  __int64 v30; // [sp+48h] [bp+40h]@1
  __int64 v31; // [sp+50h] [bp+48h]@1
  __int64 v32; // [sp+58h] [bp+50h]@1
  int v33; // [sp+60h] [bp+58h]@1
  int v34; // [sp+64h] [bp+5Ch]@1

  v32 = *(_QWORD *)&v10;
  v14 = a2;
  v15 = a4;
  v31 = *(_QWORD *)&v8;
  v16 = a1;
  v29 = v5;
  v17 = s;
  v33 = v12;
  v34 = v13;
  v30 = *(_QWORD *)&v6;
  if ( s )
  {
    v18 = strlen(s);
    sub_160E4((int)&v28, (int)v17, v18, 9);
    if ( v18 > 2 && *v17 == -1 && v17[1] == -2 )
    {
      v24 = (int)(v17 + 2);
      v25 = sub_12C04(v24, 0, 0, 0);
      v26 = (_BYTE *)sub_1E9D4(v25);
      sub_12C04(v24, v26, v25, v27);
      sub_161B8((int)&v28, (int)v26, v25, v25, 9);
    }
    v19 = sub_FCE0(v16, v14, (int)&v28, v15, a5);
    sub_7FBC((int)&v28, v20, v21, v22);
  }
  else
  {
    v19 = 1;
  }
  return v19;
}
// 10210: could not find valid save-restore pair for r4
// 10210: could not find valid save-restore pair for r5
// 10210: could not find valid save-restore pair for r6
// 10210: could not find valid save-restore pair for r7
// 10210: could not find valid save-restore pair for r8
// 10210: could not find valid save-restore pair for r9
// 10210: could not find valid save-restore pair for r10
// 10210: could not find valid save-restore pair for r11
// 10210: variables would overlap: r5.4 and r5.8
// 10210: variables would overlap: r6.4 and r5.8
// 10210: variables would overlap: r7.4 and r7.8
// 10210: variables would overlap: r8.4 and r7.8
// 10210: variables would overlap: r9.4 and r9.8
// 10210: variables would overlap: r10.4 and r9.8

//----- (000102CC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_102CC(int a1, int a2, char *a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  __int64 v6; // r7@0
  int v7; // r9@0 OVERLAPPED
  int v9; // r11@0
  int v10; // lr@0
  char *v11; // r9@1
  int v12; // r4@1
  int result; // r0@1
  int v14; // r5@1
  int (__fastcall *v15)(int, int); // r3@2
  int v16; // r11@2
  int v17; // r10@2
  char *v18; // r6@4
  int v19; // r10@4
  int v20; // r1@4
  int v21; // r5@4
  int v22; // [sp+Ch] [bp+4h]@1
  int v23; // [sp+10h] [bp+8h]@2
  int v24; // [sp+1Ch] [bp+14h]@1
  __int64 v25; // [sp+20h] [bp+18h]@1
  __int64 v26; // [sp+28h] [bp+20h]@1
  __int64 v27; // [sp+30h] [bp+28h]@1
  int v28; // [sp+38h] [bp+30h]@1
  int v29; // [sp+3Ch] [bp+34h]@1

  v27 = *(_QWORD *)&v7;
  v11 = a3;
  v26 = v6;
  v24 = v3;
  v12 = a2;
  v28 = v9;
  v29 = v10;
  v25 = *(_QWORD *)&v4;
  v22 = a1;
  result = (*(int (__fastcall **)(int, char *, const char *))(*(_DWORD *)a2 + 8))(a2, a3, "rb");
  v14 = result;
  if ( result )
  {
    v15 = *(int (__fastcall **)(int, int))(*(_DWORD *)v12 + 24);
    off_29098 = v11;
    v16 = v15(v12, result);
    v17 = v16 + 2;
    if ( (*(int (__fastcall **)(int, int, int *, _DWORD))(*(_DWORD *)(v12 - 4) + 336))(v12 - 4, v14, &v23, 0) )
      v17 = (v23 - 1 + v17) & -v23;
    v18 = (char *)(*(int (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)(v12 - 4) + 340))(v12 - 4, v14, v17, 0);
    v19 = (*(int (__fastcall **)(int, char *, int, int))(*(_DWORD *)(v12 - 4) + 280))(v12 - 4, v18, v17, v16);
    v20 = v14;
    v21 = v19;
    (*(void (__fastcall **)(int, int))(*(_DWORD *)v12 + 12))(v12, v20);
    if ( v19 )
    {
      v18[v16] = 0;
      v18[v16 + 1] = 0;
      v21 = sub_10210(v22, (int)v11, v18, v12, 0);
    }
    (*(void (__fastcall **)(int, char *))(*(_DWORD *)(v12 - 4) + 344))(v12 - 4, v18);
    result = v21;
  }
  return result;
}
// 102CC: could not find valid save-restore pair for r4
// 102CC: could not find valid save-restore pair for r5
// 102CC: could not find valid save-restore pair for r6
// 102CC: could not find valid save-restore pair for r7
// 102CC: could not find valid save-restore pair for r8
// 102CC: could not find valid save-restore pair for r9
// 102CC: could not find valid save-restore pair for r10
// 102CC: could not find valid save-restore pair for r11
// 102CC: variables would overlap: r5.4 and r5.8
// 102CC: variables would overlap: r6.4 and r5.8
// 102CC: variables would overlap: r9.4 and r9.8
// 102CC: variables would overlap: r10.4 and r9.8
// 29098: using guessed type char *off_29098;

//----- (000103D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_DWORD *__fastcall sub_103D0(_DWORD *result, const char *a2, const char *a3, int a4, int a5, int a6)
{
  int v6; // r4@0
  int v7; // r5@0 OVERLAPPED
  int v9; // r7@0 OVERLAPPED
  int v11; // r9@0 OVERLAPPED
  int v13; // r11@0
  int v14; // lr@0
  _DWORD *v15; // r10@1
  int v16; // r8@1
  const char *v17; // r11@1
  signed int v18; // r0@2
  char *v19; // r4@3
  int v20; // lr@3
  bool v21; // zf@3
  char v22; // lr@6
  int v23; // r5@11
  bool v24; // zf@11
  int v25; // r1@15
  int v26; // r2@15
  int v27; // r3@15
  int v28; // r4@15
  char v29; // r5@15
  char v30; // r5@17
  int v31; // r2@19
  int v32; // r3@19
  int v33; // r5@20
  int v34; // r1@23
  int v35; // r2@23
  int v36; // r3@23
  int v37; // [sp+0h] [bp+0h]@2
  int v38; // [sp+204h] [bp+204h]@1
  __int64 v39; // [sp+208h] [bp+208h]@1
  __int64 v40; // [sp+210h] [bp+210h]@1
  __int64 v41; // [sp+218h] [bp+218h]@1
  int v42; // [sp+220h] [bp+220h]@1
  int v43; // [sp+224h] [bp+224h]@1

  v41 = *(_QWORD *)&v11;
  v15 = result;
  v40 = *(_QWORD *)&v9;
  v16 = a4;
  v42 = v13;
  v43 = v14;
  v17 = a3;
  v39 = *(_QWORD *)&v7;
  v38 = v6;
  if ( a4 )
  {
    sub_12330((char *)&v37, a2, 0x200u);
    v18 = strlen((const char *)&v37);
    if ( v18 > 0 )
    {
      v19 = (char *)&v37 + v18;
      v20 = *((_BYTE *)&v37 + v18 - 1);
      v21 = v20 == 47;
      if ( v20 != 47 )
        v21 = v20 == 92;
      v22 = v21 != 0;
      if ( !v21 )
      {
        do
        {
          *(v19-- - 1) = v22;
          if ( (int *)v19 == &v37 )
            break;
          v23 = *(v19 - 1);
          v24 = v23 == 92;
          if ( v23 != 92 )
            v24 = v23 == 47;
        }
        while ( !v24 );
      }
    }
    sub_1250C((const char *)&v37, v17, 0x200u, -1);
    v28 = sub_DB08(32, v25, v26, v27);
    sub_CECC(v28, (int)&v37);
    v29 = *((_BYTE *)v15 + 17);
    if ( *((_BYTE *)v15 + 17) )
      v29 = 1;
    *(_BYTE *)(v28 + 17) = v29;
    v30 = *((_BYTE *)v15 + 18);
    if ( *((_BYTE *)v15 + 18) )
      v30 = 1;
    *(_BYTE *)(v28 + 18) = v30;
    if ( sub_102CC(v28, v16, (char *)&v37) )
    {
      v33 = *(_DWORD *)(a6 + 12);
      sub_112F4((void *)a6, 1, v31, v32);
      result = sub_1137C((_DWORD *)a6, v33, 1);
      if ( *(_DWORD *)a6 + 4 * v33 )
        *(_DWORD *)(*(_DWORD *)a6 + 4 * v33) = v28;
    }
    else
    {
      DevMsg("KeyValues::ParseIncludedKeys: Couldn't load included keyvalue file %s\n", &v37);
      result = (_DWORD *)sub_EB0C(v28, v34, v35, v36);
    }
  }
  return result;
}
// 103D0: could not find valid save-restore pair for r4
// 103D0: could not find valid save-restore pair for r5
// 103D0: could not find valid save-restore pair for r6
// 103D0: could not find valid save-restore pair for r7
// 103D0: could not find valid save-restore pair for r8
// 103D0: could not find valid save-restore pair for r9
// 103D0: could not find valid save-restore pair for r10
// 103D0: could not find valid save-restore pair for r11
// 103D0: variables would overlap: r5.4 and r5.8
// 103D0: variables would overlap: r6.4 and r5.8
// 103D0: variables would overlap: r7.4 and r7.8
// 103D0: variables would overlap: r8.4 and r7.8
// 103D0: variables would overlap: r9.4 and r9.8
// 103D0: variables would overlap: r10.4 and r9.8

//----- (000104E8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__fastcall sub_104E8(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7)
{
  int v7; // r4@0
  int v8; // r5@0 OVERLAPPED
  int v10; // r7@0 OVERLAPPED
  int v12; // r9@0 OVERLAPPED
  int v14; // r11@0
  int v15; // lr@0
  int v16; // r8@1
  int v17; // r6@1
  char *v18; // r4@1
  int v19; // r10@2
  int v20; // r5@2
  char *v21; // r0@4
  int v22; // r5@4
  int v23; // r10@4
  int v24; // r1@7
  int v25; // r11@9
  int v26; // r9@9
  int v27; // r5@9
  char v28; // r10@9
  int v29; // r11@13
  int v30; // r5@13
  int v32; // r11@17
  char *v33; // r2@17
  char *v34; // r9@18
  void **v35; // r10@18
  int v36; // r4@18
  int v37; // r5@18
  int v38; // r11@18
  signed int v39; // r3@24
  signed int v40; // r9@26
  int v41; // r1@29
  int v42; // r2@29
  char *v43; // r0@32
  int v44; // [sp+14h] [bp+4h]@1
  int v45; // [sp+18h] [bp+8h]@1
  const char *v46; // [sp+1Ch] [bp+Ch]@1
  int v47; // [sp+20h] [bp+10h]@31
  int v48; // [sp+28h] [bp+18h]@31
  int *v49; // [sp+2Ch] [bp+1Ch]@31
  void *base; // [sp+30h] [bp+20h]@17
  int v51; // [sp+34h] [bp+24h]@17
  int v52; // [sp+38h] [bp+28h]@17
  size_t nmemb; // [sp+3Ch] [bp+2Ch]@17
  void *v54; // [sp+40h] [bp+30h]@17
  int v55; // [sp+44h] [bp+34h]@17
  unsigned __int8 v56; // [sp+48h] [bp+38h]@17
  int v57; // [sp+54h] [bp+44h]@1
  __int64 v58; // [sp+58h] [bp+48h]@1
  __int64 v59; // [sp+60h] [bp+50h]@1
  __int64 v60; // [sp+68h] [bp+58h]@1
  int v61; // [sp+70h] [bp+60h]@1
  int v62; // [sp+74h] [bp+64h]@1

  v59 = *(_QWORD *)&v10;
  v16 = a2;
  v58 = *(_QWORD *)&v8;
  v17 = a3;
  v57 = v7;
  v18 = (char *)a1;
  v61 = v14;
  v62 = v15;
  v60 = *(_QWORD *)&v12;
  v44 = a4;
  v45 = a6;
  v46 = (const char *)a7;
  if ( a5 <= 0 )
  {
    sub_D19C(a1, a2, a3, a4, "\"", 1);
    v43 = (char *)off_2909C(*(_DWORD *)v18);
    sub_D254(v18, v16, v17, v44, v43);
    sub_D19C((int)v18, v16, v17, v44, "\"\n", 2);
  }
  else
  {
    v19 = 0;
    v20 = a4;
    do
    {
      ++v19;
      sub_D19C((int)v18, v16, v17, v20, "\t", 1);
    }
    while ( v19 != a5 );
    v44 = v20;
    sub_D19C((int)v18, v16, v17, v20, "\"", 1);
    v21 = (char *)off_2909C(*(_DWORD *)v18);
    sub_D254(v18, v16, v17, v44, v21);
    sub_D19C((int)v18, v16, v17, v44, "\"\n", 2);
    v22 = v44;
    v23 = 0;
    do
    {
      sub_D19C((int)v18, v16, v17, v22, "\t", 1);
      ++v23;
    }
    while ( v23 != a5 );
    v44 = v22;
  }
  sub_D19C((int)v18, v16, v17, v44, "{\n", 2);
  if ( v45 )
  {
    v32 = *((_DWORD *)v18 + 6);
    v33 = 0;
    base = 0;
    v51 = 0;
    v52 = 0;
    nmemb = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    if ( !v32 )
    {
      v35 = &base;
LABEL_29:
      nmemb = 0;
      sub_113B8((int)v35, v24, (int)v33, 0);
      v54 = base;
      sub_113B8((int)v35, v41, v42, (int)base);
      goto LABEL_12;
    }
    v34 = v18;
    v35 = &base;
    v36 = v32;
    v37 = 0;
    v38 = v44;
    while ( 1 )
    {
      v56 = 1;
      sub_112F4(&base, 1, (int)v33, 1);
      sub_1137C(&base, v37, 1);
      v33 = (char *)base + 4 * v37;
      if ( v33 )
        *((_DWORD *)base + v37) = v36;
      v36 = *(_DWORD *)(v36 + 20);
      if ( !v36 )
        break;
      v37 = nmemb;
    }
    v33 = (char *)v56;
    v44 = v38;
    v18 = v34;
    if ( v56 )
    {
      v24 = nmemb;
      v56 = 0;
      if ( (signed int)nmemb <= 1 )
      {
        v39 = nmemb;
LABEL_25:
        if ( v39 > 0 )
        {
          v40 = 0;
          do
            sub_108F4(v18, *((_DWORD *)base + v40++), v16, v17, v44, a5, 1, (char)v46);
          while ( (signed int)nmemb > v40 );
        }
        goto LABEL_29;
      }
      v49 = &v47;
      v48 = v55;
      unk_2CB9C = &v48;
      qsort(base, nmemb, 4u, (__compar_fn_t)sub_11258);
    }
    v39 = nmemb;
    goto LABEL_25;
  }
  if ( *((_DWORD *)v18 + 6) )
  {
    v25 = *((_DWORD *)v18 + 6);
    v26 = v45;
    v27 = v44;
    v28 = (char)v46;
    do
    {
      sub_108F4(v18, v25, v16, v17, v27, a5, v26, v28);
      v25 = *(_DWORD *)(v25 + 20);
    }
    while ( v25 );
    v44 = v27;
  }
LABEL_12:
  if ( a5 > 0 )
  {
    v29 = 0;
    v30 = v44;
    v46 = "\t";
    do
    {
      ++v29;
      sub_D19C((int)v18, v16, v17, v30, v46, 1);
    }
    while ( v29 != a5 );
    v44 = v30;
  }
  return sub_D19C((int)v18, v16, v17, v44, "}\n", 2);
}
// 104E8: could not find valid save-restore pair for r4
// 104E8: could not find valid save-restore pair for r5
// 104E8: could not find valid save-restore pair for r6
// 104E8: could not find valid save-restore pair for r7
// 104E8: could not find valid save-restore pair for r8
// 104E8: could not find valid save-restore pair for r9
// 104E8: could not find valid save-restore pair for r10
// 104E8: could not find valid save-restore pair for r11
// 104E8: variables would overlap: r5.4 and r5.8
// 104E8: variables would overlap: r6.4 and r5.8
// 104E8: variables would overlap: r7.4 and r7.8
// 104E8: variables would overlap: r8.4 and r7.8
// 104E8: variables would overlap: r9.4 and r9.8
// 104E8: variables would overlap: r10.4 and r9.8
// 11258: using guessed type int sub_11258();
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (000108F4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__fastcall sub_108F4(char *result, int a2, int a3, int a4, int a5, int a6, int a7, char a8)
{
  int v8; // r4@0
  int v9; // r5@0 OVERLAPPED
  int v11; // r7@0 OVERLAPPED
  int v13; // r9@0 OVERLAPPED
  int v15; // r11@0
  int v16; // lr@0
  char *v18; // r8@1
  int v19; // r5@1
  int v20; // r4@1
  int v21; // r10@6
  const void *v22; // r11@9
  const char *v23; // r0@9
  int v24; // r0@9
  __int64 v25; // ST00_8@9
  int v26; // r0@9
  const char *v27; // lr@9
  int v28; // r10@14
  const void *v29; // r11@17
  const char *v30; // r0@17
  int v31; // r0@17
  int v32; // r10@19
  const void *v33; // r11@22
  const char *v34; // r0@22
  int v35; // r0@22
  int v40; // r0@22
  int v41; // r10@24
  const void *v42; // r11@27
  const char *v43; // r0@27
  int v44; // r0@27
  int v45; // r0@27
  _BYTE *v46; // r2@29
  int v47; // r10@32
  char *v48; // r0@35
  int v49; // [sp+14h] [bp+4h]@6
  int v50; // [sp+18h] [bp+8h]@9
  int v51; // [sp+4Ch] [bp+3Ch]@1
  __int64 v52; // [sp+50h] [bp+40h]@1
  __int64 v53; // [sp+58h] [bp+48h]@1
  __int64 v54; // [sp+60h] [bp+50h]@1
  int v55; // [sp+68h] [bp+58h]@1
  int v56; // [sp+6Ch] [bp+5Ch]@1

  v54 = *(_QWORD *)&v13;
  _R10 = a2;
  v53 = *(_QWORD *)&v11;
  v18 = result;
  v52 = *(_QWORD *)&v9;
  v19 = a4;
  v51 = v8;
  v20 = a3;
  v55 = v15;
  v56 = v16;
  if ( *(_DWORD *)(a2 + 24) )
  {
    result = sub_104E8(a2, a3, a4, a5, a6 + 1, a7, a8);
  }
  else
  {
    switch ( *(_BYTE *)(a2 + 16) )
    {
      case 1:
        v46 = *(_BYTE **)(a2 + 4);
        if ( v46 && (a8 || *v46) )
        {
          if ( a6 >= 0 )
          {
            v49 = a2;
            v47 = 0;
            do
            {
              ++v47;
              sub_D19C((int)v18, v20, v19, a5, "\t", 1);
            }
            while ( a6 >= v47 );
            _R10 = v49;
          }
          sub_D19C((int)v18, v20, v19, a5, "\"", 1);
          v48 = (char *)off_2909C(*(_DWORD *)_R10);
          sub_D254(v18, v20, v19, a5, v48);
          sub_D19C((int)v18, v20, v19, a5, "\"\t\t\"", 4);
          sub_D254(v18, v20, v19, a5, *(char **)(_R10 + 4));
          v27 = "\"\n";
          goto LABEL_28;
        }
        return result;
      case 2:
        if ( a6 >= 0 )
        {
          v49 = a2;
          v41 = 0;
          do
          {
            ++v41;
            sub_D19C((int)v18, v20, v19, a5, "\t", 1);
          }
          while ( a6 >= v41 );
          _R10 = v49;
        }
        sub_D19C((int)v18, v20, v19, a5, "\"", 1);
        v42 = (const void *)off_2909C(*(_DWORD *)_R10);
        v43 = (const char *)off_2909C(*(_DWORD *)_R10);
        v44 = strlen(v43);
        sub_D19C((int)v18, v20, v19, a5, v42, v44);
        sub_D19C((int)v18, v20, v19, a5, "\"\t\t\"", 4);
        sub_12440((char *)&v50, 0x20u, "%d", *(_DWORD *)(_R10 + 12));
        v45 = strlen((const char *)&v50);
        sub_D19C((int)v18, v20, v19, a5, &v50, v45);
        v27 = "\"\n";
        goto LABEL_28;
      case 3:
        if ( a6 >= 0 )
        {
          v49 = a2;
          v32 = 0;
          do
          {
            ++v32;
            sub_D19C((int)v18, v20, v19, a5, "\t", 1);
          }
          while ( a6 >= v32 );
          _R10 = v49;
        }
        sub_D19C((int)v18, v20, v19, a5, "\"", 1);
        v33 = (const void *)off_2909C(*(_DWORD *)_R10);
        v34 = (const char *)off_2909C(*(_DWORD *)_R10);
        v35 = strlen(v34);
        sub_D19C((int)v18, v20, v19, a5, v33, v35);
        sub_D19C((int)v18, v20, v19, a5, "\"\t\t\"", 4);
        __asm
        {
          VLDR            S15, [R10,#0xC]
          VCVT.F64.F32    D16, S15
          VSTR            D16, [SP,#0x70+var_70]
        }
        sub_12440((char *)&v50, 0x30u, "%f");
        v40 = strlen((const char *)&v50);
        sub_D19C((int)v18, v20, v19, a5, &v50, v40);
        v27 = "\"\n";
        goto LABEL_28;
      default:
        return result;
      case 5:
        result = *(char **)(a2 + 8);
        if ( !result )
          return result;
        result = (char *)sub_12C04((int)result, byte_2B950, 4096, a8);
        if ( !result )
          return result;
        if ( a6 >= 0 )
        {
          v49 = _R10;
          v28 = 0;
          do
          {
            ++v28;
            sub_D19C((int)v18, v20, v19, a5, "\t", 1);
          }
          while ( a6 >= v28 );
          _R10 = v49;
        }
        sub_D19C((int)v18, v20, v19, a5, "\"", 1);
        v29 = (const void *)off_2909C(*(_DWORD *)_R10);
        v30 = (const char *)off_2909C(*(_DWORD *)_R10);
        v31 = strlen(v30);
        sub_D19C((int)v18, v20, v19, a5, v29, v31);
        sub_D19C((int)v18, v20, v19, a5, "\"\t\t\"", 4);
        sub_D254(v18, v20, v19, a5, byte_2B950);
        v27 = "\"\n";
        goto LABEL_28;
      case 6:
        result = (char *)DevMsg(
                           1,
                           "KeyValues::RecursiveSaveToFile: TODO, missing code for TYPE_COLOR.\n",
                           *(_BYTE *)(a2 + 16) - 1,
                           (unsigned __int8)a8);
        break;
      case 7:
        if ( a6 >= 0 )
        {
          v49 = a2;
          v21 = 0;
          do
          {
            ++v21;
            sub_D19C((int)v18, v20, v19, a5, "\t", 1);
          }
          while ( a6 >= v21 );
          _R10 = v49;
        }
        sub_D19C((int)v18, v20, v19, a5, "\"", 1);
        v22 = (const void *)off_2909C(*(_DWORD *)_R10);
        v23 = (const char *)off_2909C(*(_DWORD *)_R10);
        v24 = strlen(v23);
        sub_D19C((int)v18, v20, v19, a5, v22, v24);
        sub_D19C((int)v18, v20, v19, a5, "\"\t\t\"", 4);
        v25 = *(_QWORD *)*(_DWORD *)(_R10 + 4);
        sub_12440((char *)&v50, 0x20u, "0x%016llX");
        v26 = strlen((const char *)&v50);
        sub_D19C((int)v18, v20, v19, a5, &v50, v26);
        v27 = "\"\n";
LABEL_28:
        result = sub_D19C((int)v18, v20, v19, a5, v27, 2);
        break;
    }
  }
  return result;
}
// 108F4: could not find valid save-restore pair for r4
// 108F4: could not find valid save-restore pair for r5
// 108F4: could not find valid save-restore pair for r6
// 108F4: could not find valid save-restore pair for r7
// 108F4: could not find valid save-restore pair for r8
// 108F4: could not find valid save-restore pair for r9
// 108F4: could not find valid save-restore pair for r10
// 108F4: could not find valid save-restore pair for r11
// 108F4: variables would overlap: r5.4 and r5.8
// 108F4: variables would overlap: r6.4 and r5.8
// 108F4: variables would overlap: r7.4 and r7.8
// 108F4: variables would overlap: r8.4 and r7.8
// 108F4: variables would overlap: r9.4 and r9.8
// 108F4: variables would overlap: r10.4 and r9.8
// 34BC: using guessed type int DevMsg(_DWORD, const char *, ...);
// 2909C: using guessed type int (__fastcall *off_2909C)(_DWORD);

//----- (000112C4) --------------------------------------------------------
int __fastcall sub_112C4(int a1, int a2, int a3, int a4)
{
  int varg_r2; // ST18_4@1
  int varg_r3; // [sp+1Ch] [bp+1Ch]@1

  varg_r2 = a3;
  varg_r3 = a4;
  return androidwrapper_vswprintf();
}
// 112C4: could not find valid save-restore pair for r4
// 112C4: could not find valid save-restore pair for r7
// 3724: using guessed type int androidwrapper_vswprintf(void);

//----- (000112F4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_112F4(void *result, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r6@1
  _DWORD *v9; // r4@1
  int i; // r1@1
  int v11; // r5@1
  void *v12; // r3@2
  signed int v13; // r2@4
  void *v14; // r0@8
  int v15; // r5@9
  int v16; // [sp+0h] [bp+0h]@1
  __int64 v17; // [sp+8h] [bp+8h]@1
  int *v18; // [sp+10h] [bp+10h]@1
  int v19; // [sp+14h] [bp+14h]@1

  v18 = &v16;
  v19 = v7;
  v17 = *(_QWORD *)&v5;
  v8 = a2;
  *(_QWORD *)&v16 = *(_QWORD *)&a4;
  v9 = result;
  i = *((_DWORD *)result + 1);
  v11 = *((_DWORD *)result + 3) + v8;
  if ( v11 <= i || (v13 = *((_DWORD *)result + 2), v13 < 0) )
  {
    v12 = *(void **)result;
LABEL_3:
    v9[3] = v11;
    v9[4] = v12;
    return result;
  }
  if ( v13 )
  {
    for ( i = v13 + (v11 - 1) / v13 * v13; v11 > i; i = (v11 + i) / 2 )
      ;
  }
  else if ( i || (i = 8, v11 > 8) )
  {
    do
    {
      i *= 2;
      if ( v11 <= i )
        break;
      i *= 2;
    }
    while ( v11 > i );
  }
  v14 = *(void **)result;
  v9[1] = i;
  if ( !v14 )
  {
    result = malloc(4 * i);
    v12 = result;
    *v9 = result;
    goto LABEL_3;
  }
  result = realloc(v14, 4 * i);
  v15 = v9[3];
  *v9 = result;
  v9[4] = result;
  v9[3] = v15 + v8;
  return result;
}
// 112F4: could not find valid save-restore pair for r4
// 112F4: could not find valid save-restore pair for r5
// 112F4: could not find valid save-restore pair for r6
// 112F4: could not find valid save-restore pair for r7
// 112F4: variables would overlap: r3.4 and r3.8
// 112F4: variables would overlap: r4.4 and r3.8
// 112F4: variables would overlap: r5.4 and r5.8
// 112F4: variables would overlap: r6.4 and r5.8

//----- (0001137C) --------------------------------------------------------
_DWORD *__fastcall sub_1137C(_DWORD *result, int a2, int a3)
{
  int v3; // r3@1
  bool v4; // zf@1
  bool v5; // nf@1

  v3 = result[3] - a2 - a3;
  v4 = result[3] - a2 == a3;
  v5 = v3 < 0;
  if ( v3 > 0 )
  {
    v4 = a3 == 0;
    v5 = a3 < 0;
  }
  if ( !v5 && !v4 )
    result = j_memmove((void *)(*result + 4 * (a2 + a3)), (const void *)(*result + 4 * a2), 4 * v3);
  return result;
}
// 1137C: could not find valid save-restore pair for r4
// 1137C: could not find valid save-restore pair for r7

//----- (000113B8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_113B8(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 113B8: could not find valid save-restore pair for r4
// 113B8: could not find valid save-restore pair for r7
// 113B8: variables would overlap: r3.4 and r3.8
// 113B8: variables would overlap: r4.4 and r3.8

//----- (000113E0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_113E0(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r3@1
  int v8; // r1@1
  int v9; // r2@1
  __int64 v11; // [sp+0h] [bp+0h]@1
  __int64 *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v11 = *(_QWORD *)&a4;
  v6 = a1;
  v12 = &v11;
  v13 = v5;
  *(_DWORD *)(a1 + 12) = 0;
  sub_113B8(a1, a2, a3, 0);
  v7 = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 16) = *(_DWORD *)v6;
  sub_113B8(v6, v8, v9, v7);
  return v6;
}
// 113E0: could not find valid save-restore pair for r4
// 113E0: could not find valid save-restore pair for r7
// 113E0: variables would overlap: r3.4 and r3.8
// 113E0: variables would overlap: r4.4 and r3.8

//----- (00011404) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_11404(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 11404: could not find valid save-restore pair for r4
// 11404: could not find valid save-restore pair for r7
// 11404: variables would overlap: r3.4 and r3.8
// 11404: variables would overlap: r4.4 and r3.8

//----- (0001142C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_1142C(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 1142C: could not find valid save-restore pair for r4
// 1142C: could not find valid save-restore pair for r7
// 1142C: variables would overlap: r3.4 and r3.8
// 1142C: variables would overlap: r4.4 and r3.8

//----- (00011454) --------------------------------------------------------
void __fastcall sub_11454(int a1, int a2, int a3, int a4)
{
  int v4; // r9@1
  int v5; // r6@1
  int v6; // r5@2
  int v7; // r8@4
  int v8; // r4@4
  int v9; // r3@4
  int v10; // r1@4
  int v11; // r2@4

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 12) - 1;
  if ( v5 >= 0 )
  {
    v6 = 20 * v5;
    do
    {
      v7 = *(_DWORD *)v4;
      --v5;
      v8 = *(_DWORD *)v4 + v6;
      *(_DWORD *)(v8 + 12) = 0;
      sub_1142C(v8, a2, a3, a4);
      v9 = *(_DWORD *)(v7 + v6);
      v6 -= 20;
      *(_DWORD *)(v8 + 16) = v9;
      sub_1142C(v8, v10, v11, v9);
      a4 = v5 + 1;
    }
    while ( v5 != -1 );
  }
  *(_DWORD *)(v4 + 12) = 0;
}
// 11454: could not find valid save-restore pair for r4
// 11454: could not find valid save-restore pair for r5
// 11454: could not find valid save-restore pair for r6
// 11454: could not find valid save-restore pair for r7
// 11454: could not find valid save-restore pair for r8
// 11454: could not find valid save-restore pair for r9

//----- (000114AC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_114AC(void *result, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r6@1
  _DWORD *v9; // r4@1
  int i; // r1@1
  int v11; // r5@1
  void *v12; // r3@2
  signed int v13; // r2@4
  void *v14; // r0@8
  int v15; // r5@9
  int v16; // [sp+0h] [bp+0h]@1
  __int64 v17; // [sp+8h] [bp+8h]@1
  int *v18; // [sp+10h] [bp+10h]@1
  int v19; // [sp+14h] [bp+14h]@1

  v18 = &v16;
  v19 = v7;
  v17 = *(_QWORD *)&v5;
  v8 = a2;
  *(_QWORD *)&v16 = *(_QWORD *)&a4;
  v9 = result;
  i = *((_DWORD *)result + 1);
  v11 = *((_DWORD *)result + 3) + v8;
  if ( v11 <= i || (v13 = *((_DWORD *)result + 2), v13 < 0) )
  {
    v12 = *(void **)result;
LABEL_3:
    v9[3] = v11;
    v9[4] = v12;
    return result;
  }
  if ( v13 )
  {
    for ( i = v13 + (v11 - 1) / v13 * v13; v11 > i; i = (v11 + i) / 2 )
      ;
  }
  else if ( i || (i = 8, v11 > 8) )
  {
    do
    {
      i *= 2;
      if ( v11 <= i )
        break;
      i *= 2;
    }
    while ( v11 > i );
  }
  v14 = *(void **)result;
  v9[1] = i;
  if ( !v14 )
  {
    result = malloc(4 * i);
    v12 = result;
    *v9 = result;
    goto LABEL_3;
  }
  result = realloc(v14, 4 * i);
  v15 = v9[3];
  *v9 = result;
  v9[4] = result;
  v9[3] = v15 + v8;
  return result;
}
// 114AC: could not find valid save-restore pair for r4
// 114AC: could not find valid save-restore pair for r5
// 114AC: could not find valid save-restore pair for r6
// 114AC: could not find valid save-restore pair for r7
// 114AC: variables would overlap: r3.4 and r3.8
// 114AC: variables would overlap: r4.4 and r3.8
// 114AC: variables would overlap: r5.4 and r5.8
// 114AC: variables would overlap: r6.4 and r5.8

//----- (00011534) --------------------------------------------------------
_DWORD *__fastcall sub_11534(_DWORD *result, int a2, int a3)
{
  int v3; // r3@1
  bool v4; // zf@1
  bool v5; // nf@1

  v3 = result[3] - a2 - a3;
  v4 = result[3] - a2 == a3;
  v5 = v3 < 0;
  if ( v3 > 0 )
  {
    v4 = a3 == 0;
    v5 = a3 < 0;
  }
  if ( !v5 && !v4 )
    result = j_memmove((void *)(*result + 4 * (a2 + a3)), (const void *)(*result + 4 * a2), 4 * v3);
  return result;
}
// 11534: could not find valid save-restore pair for r4
// 11534: could not find valid save-restore pair for r7

//----- (00011570) --------------------------------------------------------
void __fastcall sub_11570(int a1, int a2, int a3, int a4)
{
  int v4; // r8@1
  int v5; // r9@1
  int v6; // r4@1
  int i; // r2@3
  int v8; // r5@3
  char *v9; // r1@4
  int v10; // r3@4
  int v11; // r2@5
  bool v12; // zf@9
  bool v13; // nf@9
  int v14; // r3@15
  int v15; // r6@15
  int v16; // r3@15
  int v17; // r2@16
  signed int v18; // r3@22
  char *v19; // r0@26
  char *v20; // r0@27
  int v21; // r3@27
  int v22; // r6@12

  v4 = a1;
  v5 = a2;
  sub_11454(a1, a2, a3, a4);
  v6 = *(_DWORD *)(v4 + 12);
  if ( v5 )
  {
    i = *(_DWORD *)(v4 + 4);
    v8 = v5 + v6;
    if ( v5 + v6 <= i || (v18 = *(_DWORD *)(v4 + 8), v18 < 0) )
    {
      v9 = *(char **)v4;
      v10 = v5 + v6;
    }
    else
    {
      if ( v18 )
      {
        for ( i = v18 + (v8 - 1) / v18 * v18; v8 > i; i = (i + v8) / 2 )
          ;
      }
      else if ( i || (i = 2, v8 > 2) )
      {
        do
          i *= 2;
        while ( v8 > i );
      }
      v19 = *(char **)v4;
      *(_DWORD *)(v4 + 4) = i;
      if ( v19 )
      {
        v20 = (char *)realloc(v19, 20 * i);
        v21 = *(_DWORD *)(v4 + 12);
        v9 = v20;
        *(_DWORD *)v4 = v20;
        v10 = v21 + v5;
      }
      else
      {
        v9 = (char *)malloc(20 * i);
        v10 = v5 + v6;
        *(_DWORD *)v4 = v9;
      }
    }
    *(_DWORD *)(v4 + 12) = v10;
    v11 = v10 - v6 - v5;
    if ( v5 <= 0 )
      v10 = 0;
    *(_DWORD *)(v4 + 16) = v9;
    if ( v5 > 0 )
      v10 = 1;
    v12 = v11 == 0;
    v13 = v11 < 0;
    if ( v11 > 0 )
    {
      v12 = v5 == 0;
      v13 = v5 < 0;
    }
    if ( v13 || v12 )
    {
      if ( !v10 )
        return;
      v22 = 4 * v6;
    }
    else
    {
      v22 = 4 * v6;
      memmove(&v9[20 * v8], &v9[20 * v6], 20 * v11);
    }
    v14 = v22 + v6;
    v15 = 0;
    v16 = 4 * v14;
    do
    {
      ++v15;
      v17 = *(_DWORD *)v4 + v16;
      if ( v17 )
        *(_DWORD *)(*(_DWORD *)v4 + v16) = 0;
      v16 += 20;
      if ( v17 )
      {
        *(_DWORD *)(v17 + 4) = 0;
        *(_DWORD *)(v17 + 8) = 0;
        *(_DWORD *)(v17 + 12) = 0;
        *(_DWORD *)(v17 + 16) = 0;
      }
    }
    while ( v5 > v15 );
  }
}
// 11570: could not find valid save-restore pair for r4
// 11570: could not find valid save-restore pair for r5
// 11570: could not find valid save-restore pair for r6
// 11570: could not find valid save-restore pair for r7
// 11570: could not find valid save-restore pair for r8

//----- (00011688) --------------------------------------------------------
int __fastcall sub_11688(int a1)
{
  signed int v1; // r3@3
  int result; // r0@5
  int *v3; // [sp+0h] [bp+0h]@1

  a1 = (unsigned __int8)a1;
  v3 = (int *)&v3;
  if ( (signed int)(unsigned __int8)a1 <= 127 )
  {
    result = a1 + ((((64 - a1) & (a1 - 91)) >> 26) & 0x20);
  }
  else
  {
    if ( *(_BYTE *)(ctype_ + a1 + 1) & 1 )
      v1 = 32;
    else
      v1 = 0;
    result = a1 + v1;
  }
  return result;
}

//----- (000116D4) --------------------------------------------------------
signed int __fastcall sub_116D4(int a1, int a2, char *a3, int a4)
{
  int v4; // r4@0
  int v5; // r5@0
  char v6; // r5@1
  int v7; // r1@3
  int v8; // r4@4
  int v9; // t1@8
  signed int v10; // r3@9
  int v12; // [sp+0h] [bp+0h]@1
  int v13; // [sp+4h] [bp+4h]@1
  int *v14; // [sp+8h] [bp+8h]@1

  v13 = v5;
  v14 = &v12;
  v12 = v4;
  v6 = *a3;
  if ( !*a3 )
  {
    v8 = (unsigned __int8)*a3;
LABEL_9:
    v10 = 1;
    *(_BYTE *)(a1 + v8) = 0;
    return v10;
  }
  if ( a4 <= 0 )
  {
    v8 = 0;
    goto LABEL_9;
  }
  v7 = a2 - 1;
  if ( v7 )
  {
    v8 = 0;
    while ( 1 )
    {
      *(_BYTE *)(a1 + v8) = v6;
      v9 = (unsigned __int8)(a3++)[1];
      v6 = v9;
      ++v8;
      if ( !v9 || v8 == a4 )
        goto LABEL_9;
      if ( v8 == v7 )
        goto LABEL_11;
    }
  }
  v8 = 0;
LABEL_11:
  v10 = 0;
  *(_BYTE *)(a1 + v8) = 0;
  return v10;
}
// 116D4: could not find valid save-restore pair for r4
// 116D4: could not find valid save-restore pair for r5
// 116D4: could not find valid save-restore pair for r7

//----- (0001172C) --------------------------------------------------------
signed int __fastcall sub_1172C(const char *a1, int a2, signed int a3, void *a4, signed int a5)
{
  void *v5; // r6@1
  int v6; // r4@1
  signed int v7; // r5@1
  const char *v8; // r8@1
  signed int result; // r0@1
  signed int v10; // r5@7
  const char *v11; // r1@7

  v5 = a4;
  v6 = a2;
  v7 = a3;
  v8 = a1;
  result = strlen(a1);
  if ( v6 >= 0 )
  {
    if ( result <= v6 )
    {
LABEL_9:
      *(_BYTE *)v5 = 0;
      return result;
    }
    if ( v7 >= 0 )
      goto LABEL_4;
LABEL_11:
    v7 = result - (-v7 - result * (-v7 / result));
    goto LABEL_6;
  }
  v6 = result - (-v6 - result * (-v6 / result));
  if ( v7 < 0 )
    goto LABEL_11;
LABEL_4:
  if ( result < v7 )
    v7 -= result * (v7 / result);
LABEL_6:
  if ( v7 <= v6 )
    goto LABEL_9;
  v10 = v7 - v6;
  v11 = &v8[v6];
  if ( v10 < a5 )
  {
    result = (signed int)memcpy(v5, v11, v10);
    *((_BYTE *)v5 + v10) = 0;
  }
  else
  {
    result = (signed int)memcpy(v5, v11, a5 - 1);
    *((char *)v5 + a5 - 1) = 0;
  }
  return result;
}
// 1172C: could not find valid save-restore pair for r4
// 1172C: could not find valid save-restore pair for r5
// 1172C: could not find valid save-restore pair for r6
// 1172C: could not find valid save-restore pair for r7

//----- (000119B8) --------------------------------------------------------
_BYTE *__fastcall sub_119B8(_BYTE *result)
{
  int v1; // r3@1
  _BYTE *v2; // r2@2
  int v3; // t1@3
  int v4; // t1@7

  v1 = *result;
  if ( *result )
  {
    v2 = result + 1;
    while ( 1 )
    {
      if ( (unsigned int)(v1 - 65) > 0x19 )
      {
        if ( !(v1 & 0x80) )
          goto LABEL_3;
        *(v2 - 1) = *(_WORD *)(tolower_tab_ + 2 * (v1 + 1));
        v4 = *v2++;
        v1 = v4;
        if ( !v4 )
          return result;
      }
      else
      {
        *(v2 - 1) = v1 + 32;
LABEL_3:
        v3 = *v2++;
        v1 = v3;
        if ( !v3 )
          return result;
      }
    }
  }
  return result;
}
// 119B8: could not find valid save-restore pair for r4
// 119B8: could not find valid save-restore pair for r7

//----- (00011A70) --------------------------------------------------------
int __fastcall sub_11A70(const char *a1, const char *a2)
{
  unsigned int v2; // r3@2
  const char *v3; // r4@3
  unsigned int v4; // r2@4
  const char *v5; // r5@4
  int v6; // r6@4
  int v7; // r12@4
  unsigned int v8; // t1@7
  int result; // r0@8

  if ( a1 == a2 )
  {
    result = 0;
  }
  else
  {
    v2 = *a1;
    if ( *a1 )
    {
      v3 = a2;
      while ( 1 )
      {
        v4 = *v3;
        v5 = v3;
        v6 = (unsigned __int8)v2 | 0x20;
        a2 = ++v3;
        v7 = v4 | 0x20;
        if ( v2 != v4 )
        {
          if ( v6 != v7 )
            goto LABEL_12;
          if ( (unsigned int)(v6 - 97) > 0x19 )
            break;
        }
        v8 = (a1++)[1];
        v2 = v8;
        if ( !v8 )
          goto LABEL_8;
      }
      v7 = (unsigned __int8)v2 | 0x20;
LABEL_12:
      if ( (v7 | v6) & 0x80 )
      {
        result = j_strcasecmp(a1, v5);
      }
      else
      {
        if ( (unsigned int)(v6 - 97) <= 0x19 )
          v2 = (unsigned __int8)v2 | 0x20;
        if ( (unsigned int)(v7 - 97) <= 0x19 )
          v4 = v7;
        if ( v2 > v4 )
          result = 1;
        else
          result = -1;
      }
    }
    else
    {
LABEL_8:
      result = *a2;
      if ( *a2 )
        result = -1;
    }
  }
  return result;
}
// 11A70: could not find valid save-restore pair for r4
// 11A70: could not find valid save-restore pair for r5
// 11A70: could not find valid save-restore pair for r6
// 11A70: could not find valid save-restore pair for r7
// 11A70: could not find valid save-restore pair for r8

//----- (00011BC8) --------------------------------------------------------
signed int __fastcall sub_11BC8(_BYTE *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // r3@2
  unsigned int v4; // r4@2
  int v5; // r2@4
  unsigned int v6; // t1@5
  unsigned int v7; // t1@5
  signed int result; // r0@8

  if ( a3 <= 0 )
    return 0;
  v3 = *a1;
  v4 = *a2;
  if ( v4 == v3 )
  {
    if ( *a1 )
    {
      v5 = (int)&a1[a3 - 1];
      while ( a1 != (_BYTE *)v5 )
      {
        v6 = (a1++)[1];
        v3 = v6;
        v7 = (a2++)[1];
        v4 = v7;
        if ( v7 != v3 )
          goto LABEL_9;
        if ( !v3 )
          goto LABEL_13;
      }
      return 0;
    }
LABEL_13:
    result = v3;
  }
  else
  {
LABEL_9:
    if ( v3 < v4 )
      result = -1;
    else
      result = 1;
  }
  return result;
}
// 11BC8: could not find valid save-restore pair for r4
// 11BC8: could not find valid save-restore pair for r7

//----- (00012140) --------------------------------------------------------
_BYTE *__fastcall sub_12140(_BYTE *a1, _BYTE *a2)
{
  bool v2; // zf@1
  _BYTE *v3; // r6@3
  _BYTE *v4; // r5@4
  int v5; // r8@5
  int v6; // r10@9
  int v7; // r11@11
  int v8; // r4@11
  _BYTE *result; // r0@11
  _BYTE *v10; // t1@12
  int v11; // r9@13
  int v12; // t1@14
  int v13; // [sp+4h] [bp+4h]@5
  _BYTE *v14; // [sp+8h] [bp+8h]@3
  int v15; // [sp+Ch] [bp+Ch]@5

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  v3 = a1;
  v14 = a2;
  if ( v2 )
  {
    result = 0;
  }
  else
  {
    v4 = (_BYTE *)*a1;
    if ( *a1 )
    {
      v5 = (int)(a1 + 1);
      v13 = (int)(a2 + 1);
      v15 = sub_11688(*a2);
      while ( 1 )
      {
        if ( sub_11688((char)v4) == v15 )
        {
          v6 = v14[1];
          if ( !v14[1] )
            return v3;
          v4 = (_BYTE *)v3[1];
          if ( !v3[1] )
            break;
          v7 = v13;
          v8 = v5;
          LOBYTE(result) = v3[1];
          while ( 1 )
          {
            v11 = sub_11688((char)result);
            if ( v11 != sub_11688(v6) )
              break;
            v12 = *(_BYTE *)(v7++ + 1);
            v6 = v12;
            if ( !v12 )
              return v3;
            v10 = (_BYTE *)*(_BYTE *)(v8++ + 1);
            result = v10;
            if ( !v10 )
              return result;
          }
        }
        else
        {
          v4 = (_BYTE *)v3[1];
          if ( !v3[1] )
            break;
        }
        ++v5;
        ++v3;
      }
    }
    result = v4;
  }
  return result;
}
// 12140: could not find valid save-restore pair for r4
// 12140: could not find valid save-restore pair for r5
// 12140: could not find valid save-restore pair for r6
// 12140: could not find valid save-restore pair for r7
// 12140: could not find valid save-restore pair for r8
// 12140: could not find valid save-restore pair for r9
// 12140: could not find valid save-restore pair for r10
// 12140: could not find valid save-restore pair for r11

//----- (000121F8) --------------------------------------------------------
_BYTE *__fastcall sub_121F8(_BYTE *a1, _BYTE *a2)
{
  return sub_12140(a1, a2);
}

//----- (00012208) --------------------------------------------------------
signed int __fastcall sub_12208(int a1, _BYTE *a2, int a3)
{
  bool v3; // zf@1
  _BYTE *v4; // r8@3
  int v5; // r5@3
  signed int result; // r0@4
  int v7; // r9@7
  int v8; // r6@9
  int v9; // r11@14
  int v10; // r4@17
  int v11; // r2@18
  int v12; // r10@20
  int v13; // r0@20
  int v14; // r3@20
  int v15; // [sp+0h] [bp+0h]@9
  int v16; // [sp+4h] [bp+4h]@10

  v3 = a2 == 0;
  if ( a2 )
    v3 = a1 == 0;
  v4 = a2;
  v5 = a1;
  result = v3 != 0;
  if ( v3 )
    return 0;
  v7 = *(_BYTE *)v5;
  if ( !*(_BYTE *)v5 )
    return v7;
  if ( a3 <= 0 )
    return result;
  v8 = a3 - 1;
  v15 = sub_11688(*a2);
  while ( 1 )
  {
    if ( v15 != sub_11688(v7) )
    {
      v7 = *(_BYTE *)(v5 + 1);
      v16 = v8;
      if ( !*(_BYTE *)(v5 + 1) )
        return v7;
      --v8;
      goto LABEL_12;
    }
    v9 = v4[1];
    v16 = v8;
    if ( !v4[1] )
      return v5;
    if ( !v8 )
      return 0;
    v7 = *(_BYTE *)(v5 + 1);
    if ( !*(_BYTE *)(v5 + 1) )
      return v7;
    --v8;
    LOBYTE(result) = *(_BYTE *)(v5 + 1);
    v10 = 0;
    while ( 1 )
    {
      v12 = sub_11688((char)result);
      v13 = sub_11688(v9);
      v14 = (int)&v4[v10];
      if ( v12 != v13 )
        break;
      v9 = *(_BYTE *)(v14 + 2);
      if ( !*(_BYTE *)(v14 + 2) )
        return v5;
      v3 = v10++ == v8;
      v11 = v5 + v10;
      if ( v3 )
        return 0;
      result = *(_BYTE *)(v11 + 1);
      if ( !*(_BYTE *)(v11 + 1) )
        return result;
    }
LABEL_12:
    ++v5;
    if ( v16 <= 0 )
      return 0;
  }
}
// 12208: could not find valid save-restore pair for r4
// 12208: could not find valid save-restore pair for r5
// 12208: could not find valid save-restore pair for r6
// 12208: could not find valid save-restore pair for r7
// 12208: could not find valid save-restore pair for r8
// 12208: could not find valid save-restore pair for r9
// 12208: could not find valid save-restore pair for r10
// 12208: could not find valid save-restore pair for r11

//----- (000122EC) --------------------------------------------------------
_BYTE *__fastcall sub_122EC(_BYTE *result, int a2, int a3)
{
  int v3; // r4@0
  int v4; // r5@0
  unsigned int v5; // r2@1
  _BYTE *v6; // r5@2
  _BYTE *v7; // r3@4
  _BYTE *v8; // t1@5
  int v9; // r4@5
  int v10; // [sp+0h] [bp+0h]@1
  int v11; // [sp+4h] [bp+4h]@1
  int *v12; // [sp+8h] [bp+8h]@1

  v5 = (unsigned int)&result[a3];
  v11 = v4;
  v12 = &v10;
  v10 = v3;
  if ( (unsigned int)result >= v5 )
    return 0;
  v6 = (_BYTE *)*result;
  if ( *result )
  {
    if ( (char)v6 == a2 )
      return result;
    v7 = result + 1;
    while ( 1 )
    {
      v6 = v7;
      if ( v7 == (_BYTE *)v5 )
        break;
      v8 = (_BYTE *)*v7++;
      result = v8;
      v9 = (char)v8;
      if ( !v8 )
        return result;
      if ( v9 == a2 )
        return v6;
    }
    return 0;
  }
  return v6;
}
// 122EC: could not find valid save-restore pair for r4
// 122EC: could not find valid save-restore pair for r5
// 122EC: could not find valid save-restore pair for r7

//----- (00012330) --------------------------------------------------------
char *__fastcall sub_12330(char *a1, const char *a2, size_t a3)
{
  __int64 v3; // r4@0
  int v4; // lr@0
  signed int v5; // r4@1
  char *v6; // r5@1
  char *result; // r0@1
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = v3;
  v5 = a3;
  v6 = a1;
  v9 = &v8;
  v10 = v4;
  result = strncpy(a1, a2, a3);
  if ( v5 > 0 )
    v6[v5 - 1] = 0;
  return result;
}
// 12330: could not find valid save-restore pair for r4
// 12330: could not find valid save-restore pair for r5
// 12330: could not find valid save-restore pair for r7

//----- (00012354) --------------------------------------------------------
_DWORD *__fastcall sub_12354(_DWORD *result, int a2, unsigned int a3)
{
  int v3; // r4@0
  int v4; // r5@0
  unsigned int v5; // r2@1
  int v6; // r3@2
  _DWORD *v7; // r5@4
  unsigned int v8; // r4@4
  int v9; // t1@6
  int v10; // [sp+0h] [bp+0h]@1
  int v11; // [sp+4h] [bp+4h]@1
  int *v12; // [sp+8h] [bp+8h]@1

  v5 = a3 >> 2;
  v11 = v4;
  v12 = &v10;
  v10 = v3;
  if ( a2 && (v6 = *(_DWORD *)a2) != 0 )
  {
    if ( !v5 )
      return result;
    v7 = result;
    v8 = v5;
    while ( 1 )
    {
      *v7 = v6;
      ++v7;
      v9 = *(_DWORD *)(a2 + 4);
      a2 += 4;
      v6 = v9;
      --v8;
      if ( !v9 )
        break;
      if ( !v8 )
        goto LABEL_11;
    }
  }
  else
  {
    v8 = v5;
    v7 = result;
  }
  if ( v8 )
    *v7 = 0;
  if ( v5 )
LABEL_11:
    result[v5 + 0x3FFFFFFF] = 0;
  return result;
}
// 12354: could not find valid save-restore pair for r4
// 12354: could not find valid save-restore pair for r5
// 12354: could not find valid save-restore pair for r7

//----- (00012440) --------------------------------------------------------
int sub_12440(char *a1, size_t a2, const char *a3, ...)
{
  const char *varg_r2; // ST20_4@1
  signed int v4; // r5@1
  char *v5; // r6@1
  int result; // r0@1
  va_list va; // [sp+24h] [bp+24h]@1

  va_start(va, a3);
  varg_r2 = a3;
  v4 = a2;
  v5 = a1;
  result = vsnprintf(a1, a2, a3, va);
  if ( (v4 <= result) | ((unsigned int)result >> 31) )
  {
    result = v4;
    v5[v4 - 1] = 0;
  }
  return result;
}
// 12440: could not find valid save-restore pair for r4
// 12440: could not find valid save-restore pair for r5
// 12440: could not find valid save-restore pair for r6
// 12440: could not find valid save-restore pair for r7

//----- (00012498) --------------------------------------------------------
int __fastcall sub_12498(char *a1, size_t a2, const char *a3, void *a4)
{
  __int64 v4; // r4@0
  int v5; // lr@0
  signed int v6; // r4@1
  char *v7; // r5@1
  int result; // r0@1
  int v9; // [sp+0h] [bp+0h]@1
  int *v10; // [sp+8h] [bp+8h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  v10 = &v9;
  v11 = v5;
  *(_QWORD *)&v9 = v4;
  v6 = a2;
  v7 = a1;
  result = vsnprintf(a1, a2, a3, a4);
  if ( (v6 <= result) | ((unsigned int)result >> 31) )
  {
    result = v6;
    v7[v6 - 1] = 0;
  }
  return result;
}
// 12498: could not find valid save-restore pair for r4
// 12498: could not find valid save-restore pair for r5
// 12498: could not find valid save-restore pair for r7

//----- (000124C8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_124C8(char *a1, size_t a2, const char *a3, void *a4, _BYTE *a5)
{
  int v6; // r5@0 OVERLAPPED
  int v8; // lr@0
  char *v9; // r6@1
  signed int v10; // r4@1
  int result; // r0@1
  signed int v12; // r3@2
  int v13; // [sp+0h] [bp+0h]@1
  __int64 v14; // [sp+8h] [bp+8h]@1
  int *v15; // [sp+10h] [bp+10h]@1
  int v16; // [sp+14h] [bp+14h]@1

  v15 = &v13;
  v16 = v8;
  v14 = *(_QWORD *)&v6;
  v9 = a1;
  *(_QWORD *)&v13 = *(_QWORD *)&a4;
  v10 = a2;
  result = vsnprintf(a1, a2, a3, a4);
  if ( a5 )
  {
    v12 = (unsigned int)result >> 31;
    if ( v10 <= result )
      v12 = 1;
    *a5 = v12;
  }
  else
  {
    v12 = (v10 <= result) | ((unsigned int)result >> 31);
  }
  if ( v12 )
  {
    result = v10;
    v9[v10 - 1] = 0;
  }
  return result;
}
// 124C8: could not find valid save-restore pair for r4
// 124C8: could not find valid save-restore pair for r5
// 124C8: could not find valid save-restore pair for r6
// 124C8: could not find valid save-restore pair for r7
// 124C8: variables would overlap: r3.4 and r3.8
// 124C8: variables would overlap: r4.4 and r3.8
// 124C8: variables would overlap: r5.4 and r5.8
// 124C8: variables would overlap: r6.4 and r5.8

//----- (0001250C) --------------------------------------------------------
char *__fastcall sub_1250C(const char *a1, const char *a2, unsigned int a3, signed int a4)
{
  const char *v4; // r6@1
  char *v5; // r10@1
  unsigned int v6; // r8@1
  signed int v7; // r5@1
  size_t v8; // r9@1
  signed int v9; // r0@1
  signed int v10; // r2@1
  char *result; // r0@4

  v4 = a2;
  v5 = (char *)a1;
  v6 = a3;
  v7 = a4;
  v8 = strlen(a1);
  v9 = strlen(v4);
  v10 = v9;
  if ( v7 >= 0 && v9 >= v7 )
    v10 = v7;
  result = v5;
  if ( v10 + v8 >= v6 )
    v10 = v6 - 1 - v8;
  if ( v10 > 0 )
    result = j_strncat(v5, v4, v10);
  return result;
}

//----- (00012944) --------------------------------------------------------
signed int __fastcall sub_12944(unsigned int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  if ( a1 <= 0x200D )
  {
    if ( a1 >= 0x2000 || a1 == 160 )
      return 1;
    if ( a1 > 0xA0 )
    {
      if ( a1 != 847 )
        return 0;
    }
    else if ( a1 - 130 > 1 )
    {
      return 0;
    }
    return 1;
  }
  if ( a1 == 8239 )
    return 1;
  if ( a1 <= 0x202F )
  {
    if ( a1 - 8232 > 1 )
      return 0;
    return 1;
  }
  if ( a1 == 65279 || a1 == 65532 || a1 == 8288 )
    return 1;
  return 0;
}

//----- (000129B0) --------------------------------------------------------
unsigned int *__fastcall sub_129B0(int a1, unsigned int a2, _BYTE *a3, int a4)
{
  int v4; // r0@1
  _BYTE *v5; // r8@1
  unsigned int *v6; // r6@1
  int v7; // r4@2
  unsigned int v8; // r11@2
  unsigned int v9; // r5@3
  unsigned int v10; // r0@3
  unsigned int v11; // t1@3
  unsigned int v12; // r2@3
  bool v13; // cf@3
  bool v14; // zf@3
  unsigned int *v15; // r3@12
  unsigned int v16; // r4@14
  unsigned int v17; // t1@14
  unsigned int v18; // r2@14
  bool v19; // cf@14
  bool v20; // zf@14
  int v22; // [sp+4h] [bp+4h]@1

  v4 = a2 + 4 * a1;
  v5 = a3;
  v6 = (unsigned int *)a2;
  *a3 = 0;
  v22 = a4;
  if ( a2 <= v4 - 4 )
  {
    v7 = v4 - 4;
    v8 = v4 - 8 - ((v4 + -4 - a2) & 0xFFFFFFFC);
    do
    {
      v9 = v7;
      v11 = *(_DWORD *)v7;
      v7 -= 4;
      v10 = v11;
      v12 = v11 - 9;
      v13 = v11 >= 0x20;
      v14 = v11 == 32;
      if ( v11 != 32 )
      {
        v13 = v12 >= 1;
        v14 = v12 == 1;
      }
      if ( !v14 && v13 && v10 != 13 && (!v22 || !sub_12944(v10)) )
        break;
      *(_DWORD *)(v7 + 4) = 0;
      v9 = v7;
      *v5 = 1;
    }
    while ( v7 != v8 );
    if ( (unsigned int)v6 < v9 )
    {
      v15 = v6;
      do
      {
        v6 = v15;
        v17 = *v15;
        ++v15;
        v16 = v17;
        v18 = v17 - 9;
        v19 = v17 >= 0x20;
        v20 = v17 == 32;
        if ( v17 != 32 )
        {
          v19 = v18 >= 1;
          v20 = v18 == 1;
        }
        if ( !v20 && v19 && v16 != 13 )
          break;
        *v5 = 1;
        v6 = v15;
      }
      while ( (unsigned int)v15 < v9 );
    }
  }
  return v6;
}
// 129B0: could not find valid save-restore pair for r4
// 129B0: could not find valid save-restore pair for r5
// 129B0: could not find valid save-restore pair for r6
// 129B0: could not find valid save-restore pair for r7
// 129B0: could not find valid save-restore pair for r8
// 129B0: could not find valid save-restore pair for r9
// 129B0: could not find valid save-restore pair for r10
// 129B0: could not find valid save-restore pair for r11

//----- (00012B7C) --------------------------------------------------------
char *__fastcall sub_12B7C(char *result, _DWORD *a2, signed int a3, int a4)
{
  signed int v4; // r8@1
  unsigned int v5; // r2@6
  char v6; // r3@8
  _DWORD *v7; // r5@10
  int v8; // r4@10
  int v9; // t1@12
  _DWORD *v10; // r12@12

  v4 = a3;
  if ( a3 > 0 )
    a4 = 0;
  if ( a3 > 0 )
    *a2 = a4;
  if ( result )
  {
    v5 = (unsigned int)a3 >> 2;
    if ( a2 && v5 )
    {
      v6 = *result;
      if ( *result )
      {
        if ( v5 == 1 )
        {
          v10 = a2;
          result = (char *)1;
        }
        else
        {
          v7 = a2;
          v8 = 0;
          do
          {
            ++v8;
            *v7 = v6;
            ++v7;
            v9 = (unsigned __int8)(result++)[1];
            v6 = v9;
            v10 = v7;
          }
          while ( v9 && v5 - v8 != 1 );
          result = (char *)(v8 + 1);
        }
      }
      else
      {
        v10 = a2;
        result = (char *)1;
      }
      *v10 = 0;
    }
    else
    {
      result = (char *)1;
    }
    if ( v4 > 0 )
      a2[v5 + 0x3FFFFFFF] = 0;
  }
  return result;
}
// 12B7C: could not find valid save-restore pair for r4
// 12B7C: could not find valid save-restore pair for r5
// 12B7C: could not find valid save-restore pair for r6
// 12B7C: could not find valid save-restore pair for r7
// 12B7C: could not find valid save-restore pair for r8

//----- (00012C04) --------------------------------------------------------
int __fastcall sub_12C04(int a1, _BYTE *a2, int a3, char a4)
{
  bool v4; // zf@5
  signed int v5; // r4@8
  int result; // r0@11
  unsigned int v7; // r3@17
  _BYTE *v8; // r5@19
  int v9; // r4@19
  unsigned int v10; // t1@23
  _BYTE *v11; // r12@23

  if ( a3 > 0 )
    a4 = 0;
  if ( a3 > 0 )
    *a2 = a4;
  v4 = a2 == 0;
  if ( a2 )
    v4 = a1 == 0;
  v5 = !v4;
  if ( v4 )
  {
    result = v5;
  }
  else
  {
    if ( !a3 )
      return 1;
    v7 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( a3 == 1 )
      {
        v11 = a2;
        result = 1;
      }
      else
      {
        v8 = a2;
        v9 = 0;
        do
        {
          if ( v7 > 0x7F )
            LOBYTE(v7) = 63;
          ++v9;
          *v8++ = v7;
          v10 = *(_DWORD *)(a1 + 4);
          a1 += 4;
          v7 = v10;
          v11 = v8;
        }
        while ( v10 && a3 - v9 != 1 );
        result = v9 + 1;
      }
    }
    else
    {
      v11 = a2;
      result = 1;
    }
    *v11 = 0;
  }
  if ( a3 > 0 )
    a2[a3 - 1] = 0;
  return result;
}

//----- (00012C90) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_12C90(const char *a1)
{
  int v1; // r4@0
  int v2; // r5@0 OVERLAPPED
  int v4; // r7@0
  int v5; // lr@0
  char *v6; // r5@1
  int v7; // r6@1
  char *v8; // r0@1
  unsigned int *v9; // r0@1
  int result; // r0@2
  char v11; // [sp+0h] [bp+0h]@1
  int v12; // [sp+Ch] [bp+Ch]@1
  __int64 v13; // [sp+10h] [bp+10h]@1
  int v14; // [sp+18h] [bp+18h]@1
  int v15; // [sp+1Ch] [bp+1Ch]@1

  v14 = v4;
  v15 = v5;
  v13 = *(_QWORD *)&v2;
  v6 = (char *)a1;
  v12 = v1;
  v7 = strlen(a1);
  v8 = sub_12B7C(v6, &v11, 4 * (v7 + 1), ((4 * (v7 + 1) + 15) & 0xFFFFFFF0) + 8);
  v11 = 0;
  v9 = sub_129B0((int)(v8 - 1), (unsigned int)&v11, &v11, 0);
  if ( v11 )
  {
    sub_12C04((int)v9, v6, v7, v11);
    result = (unsigned __int8)v11;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 12C90: could not find valid save-restore pair for r4
// 12C90: could not find valid save-restore pair for r5
// 12C90: could not find valid save-restore pair for r6
// 12C90: could not find valid save-restore pair for r7
// 12C90: variables would overlap: r5.4 and r5.8
// 12C90: variables would overlap: r6.4 and r5.8

//----- (00013234) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_13234(const char *a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  const char *v6; // r4@1
  signed int result; // r0@1
  int v8; // r3@2
  bool v9; // zf@2
  int v10; // [sp+0h] [bp+0h]@1
  int *v11; // [sp+8h] [bp+8h]@1
  int v12; // [sp+Ch] [bp+Ch]@1

  v11 = &v10;
  v12 = v5;
  *(_QWORD *)&v10 = *(_QWORD *)&a4;
  v6 = a1;
  result = strlen(a1);
  if ( result > 0 )
  {
    v8 = v6[--result];
    v9 = v8 == 92;
    if ( v8 != 92 )
      v9 = v8 == 47;
    if ( v9 )
      v6[result] = 0;
  }
  return result;
}
// 13234: could not find valid save-restore pair for r4
// 13234: could not find valid save-restore pair for r7
// 13234: variables would overlap: r3.4 and r3.8
// 13234: variables would overlap: r4.4 and r3.8

//----- (0001325C) --------------------------------------------------------
char *__fastcall sub_1325C(const char *a1, char *a2, signed int a3)
{
  char *v3; // r8@1
  signed int v4; // r9@1
  const char *v5; // r6@1
  char *result; // r0@1
  int v7; // r3@2
  bool v8; // zf@10
  int v9; // r9@14
  size_t v10; // r4@15

  v3 = a2;
  v4 = a3;
  v5 = a1;
  result = (char *)(strlen(a1) - 1);
  if ( (signed int)result > 0 )
  {
    v7 = result[(_DWORD)v5];
    if ( (unsigned int)(v7 - 46) <= 1 )
    {
LABEL_10:
      v8 = v7 == 47;
      if ( v7 != 47 )
        v8 = v7 == 92;
      if ( !v8 && (signed int)result < v4 )
      {
        v9 = v4 - 1;
        if ( (signed int)result >= v9 )
          v10 = v9;
        else
          v10 = (size_t)result;
        if ( v3 != v5 )
          result = (char *)memcpy(v3, v5, v10);
        v3[v10] = 0;
        return result;
      }
    }
    else
    {
      while ( v7 != 92 )
      {
        if ( !--result )
          break;
        v7 = result[(_DWORD)v5];
        if ( (unsigned int)(v7 - 46) <= 1 )
          goto LABEL_10;
      }
    }
  }
  if ( v3 != v5 )
  {
    result = strncpy(v3, v5, v4);
    if ( v4 > 0 )
      v3[v4 - 1] = 0;
  }
  return result;
}
// 1325C: could not find valid save-restore pair for r4
// 1325C: could not find valid save-restore pair for r5
// 1325C: could not find valid save-restore pair for r6
// 1325C: could not find valid save-restore pair for r7
// 1325C: could not find valid save-restore pair for r8

//----- (0001335C) --------------------------------------------------------
char *__fastcall sub_1335C(const char *a1, const char *a2, signed int a3)
{
  const char *v3; // r5@1
  char *result; // r0@1
  int v5; // r3@1
  unsigned int v6; // r4@1
  bool v7; // zf@1
  int v8; // t1@8
  bool v9; // zf@8
  const char *v10; // r6@1
  signed int v11; // r5@1
  const char *v12; // r4@1
  unsigned int v13; // r2@1
  unsigned int v14; // [sp+0h] [bp+0h]@1

  v10 = a2;
  v11 = a3;
  v12 = a1;
  sub_1325C(a1, (char *)a1, a3);
  v13 = v11;
  v3 = v12;
  v14 = v13;
  result = (char *)(strlen(v12) - 1);
  v5 = result[(_DWORD)v12];
  v6 = (unsigned int)&result[(_DWORD)v12];
  v7 = v5 == 47;
  if ( v5 != 47 )
    v7 = v5 == 92;
  if ( v7 || (unsigned int)v3 >= v6 )
  {
LABEL_5:
    result = sub_1250C(v3, v10, v14, -1);
  }
  else
  {
    while ( v5 != 46 )
    {
      v8 = *(_BYTE *)(v6-- - 1);
      v5 = v8;
      v9 = v8 == 47;
      if ( v8 != 47 )
        v9 = v5 == 92;
      if ( v9 || (const char *)v6 == v3 )
        goto LABEL_5;
    }
  }
  return result;
}
// 1335C: could not find valid save-restore pair for r4
// 1335C: could not find valid save-restore pair for r5

//----- (00013390) --------------------------------------------------------
signed int __fastcall sub_13390(const char *a1, int a2, int a3, int a4)
{
  int v4; // lr@0
  const char *v5; // r5@1
  signed int result; // r0@1
  const char *v7; // r1@2
  int v8; // r2@3
  char *v9; // r3@3
  bool v10; // zf@3
  int v11; // [sp+0h] [bp+0h]@1
  int *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v12 = &v11;
  v13 = v4;
  v11 = a4;
  v5 = a1;
  result = strlen(a1) - 1;
  if ( result > 0 )
  {
    v7 = &v5[result];
    while ( 1 )
    {
      v8 = *v7;
      v9 = (char *)v7--;
      v10 = v8 == 92;
      if ( v8 != 92 )
        v10 = v8 == 47;
      if ( v10 )
        break;
      if ( !--result )
      {
        v9 = (char *)v5;
        break;
      }
    }
    *v9 = 0;
  }
  return result;
}
// 13390: could not find valid save-restore pair for r7

//----- (000133C8) --------------------------------------------------------
_BYTE *__fastcall sub_133C8(_BYTE *result, char a2)
{
  int v2; // r3@1
  bool v3; // zf@3
  int v4; // t1@7
  int *v5; // [sp+0h] [bp+0h]@1

  v5 = (int *)&v5;
  v2 = *result;
  if ( *result )
  {
    ++result;
    do
    {
      v3 = v2 == 92;
      if ( v2 != 92 )
        v3 = v2 == 47;
      if ( v3 )
        result[0xFFFFFFFF] = a2;
      v4 = *result++;
      v2 = v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (00013450) --------------------------------------------------------
int __fastcall sub_13450(const char *a1, size_t a2)
{
  __int64 v2; // r4@0
  int v3; // lr@0
  const char *v4; // r4@1
  size_t v5; // r5@1
  int result; // r0@2
  signed int v7; // r0@6
  int v8; // r2@6
  bool v9; // zf@6
  int v10; // r2@11
  bool v11; // zf@11
  int v12; // r2@16
  bool v13; // zf@16
  int v14; // r3@22
  _BYTE *v15; // r4@22
  bool v16; // zf@23
  int v17; // t1@27
  __int64 v18; // [sp+0h] [bp+0h]@1
  __int64 *v19; // [sp+8h] [bp+8h]@1
  int v20; // [sp+Ch] [bp+Ch]@1

  v18 = v2;
  v4 = a1;
  v5 = a2;
  v19 = &v18;
  v20 = v3;
  if ( !*a1 )
    return *a1;
  result = sub_11A70(a1, "./");
  if ( result )
  {
    result = sub_11A70(v4, ".\\");
    if ( result )
    {
      v7 = strlen(v4);
      v8 = v4[v7 - 1];
      v9 = v8 == 92;
      if ( v8 != 92 )
        v9 = v8 == 47;
      if ( v9 )
        --v7;
      if ( v7 <= 0 )
      {
        if ( v7 )
          return 1;
        goto LABEL_20;
      }
      v10 = v4[v7 - 1];
      v11 = v10 == 92;
      if ( v10 != 92 )
        v11 = v10 == 47;
      if ( !v11 )
      {
        while ( --v7 )
        {
          v12 = v4[v7 - 1];
          v13 = v12 == 92;
          if ( v12 != 92 )
            v13 = v12 == 47;
          if ( v13 )
            goto LABEL_22;
        }
LABEL_20:
        sub_12440((char *)v4, v5, ".%c", 47, v18, v19, v20);
        return 1;
      }
LABEL_22:
      v4[v7] = 0;
      v14 = *v4;
      v15 = v4 + 1;
      if ( !v14 )
        return 1;
      do
      {
        v16 = v14 == 92;
        if ( v14 != 92 )
          v16 = v14 == 47;
        if ( v16 )
          *(v15 - 1) = 47;
        v17 = *v15++;
        v14 = v17;
      }
      while ( v17 );
      result = 1;
    }
  }
  return result;
}
// 13450: could not find valid save-restore pair for r4
// 13450: could not find valid save-restore pair for r5
// 13450: could not find valid save-restore pair for r7

//----- (0001350C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
size_t __fastcall sub_1350C(const char *a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  const char *v6; // r4@1
  size_t result; // r0@1
  int v8; // r3@2
  bool v9; // zf@2
  int v10; // [sp+0h] [bp+0h]@1
  int *v11; // [sp+8h] [bp+8h]@1
  int v12; // [sp+Ch] [bp+Ch]@1

  v11 = &v10;
  v12 = v5;
  *(_QWORD *)&v10 = *(_QWORD *)&a4;
  v6 = a1;
  result = (size_t)&a1[strlen(a1) - 1];
  if ( (unsigned int)v6 < result )
  {
    do
    {
      v8 = *(_BYTE *)(result - 1);
      v9 = v8 == 92;
      if ( v8 != 92 )
        v9 = v8 == 47;
      if ( v9 )
        break;
      --result;
    }
    while ( (const char *)result != v6 );
  }
  return result;
}
// 1350C: could not find valid save-restore pair for r4
// 1350C: could not find valid save-restore pair for r7
// 1350C: variables would overlap: r3.4 and r3.8
// 1350C: variables would overlap: r4.4 and r3.8

//----- (0001353C) --------------------------------------------------------
const char *__fastcall sub_1353C(const char *result, void *a2, int a3)
{
  int v3; // r6@1
  void *v4; // r5@1
  const char *v5; // r1@1
  signed int v6; // r0@4
  int v7; // r3@5
  int v8; // r2@6
  bool v9; // zf@6
  int v10; // r4@10
  bool v11; // zf@10
  size_t v12; // r4@15
  char *src; // [sp+4h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = result;
  if ( a3 <= 0 )
    result = 0;
  if ( a3 > 0 )
  {
    src = (char *)v5;
    v6 = strlen(result);
    if ( v6 )
    {
      v7 = (int)&src[v6 - 1];
      if ( src == (char *)v7 )
      {
LABEL_21:
        v6 = 0;
        goto LABEL_15;
      }
      v8 = *(_BYTE *)(v7 - 1);
      v9 = v8 == 92;
      if ( v8 != 92 )
        v9 = v8 == 47;
      if ( !v9 )
      {
        while ( src != (char *)--v7 )
        {
          v10 = *(_BYTE *)(v7 - 1);
          v11 = v10 == 92;
          if ( v10 != 92 )
            v11 = v10 == 47;
          if ( v11 )
            goto LABEL_14;
        }
        goto LABEL_21;
      }
LABEL_14:
      v6 = v7 - (_DWORD)src;
    }
LABEL_15:
    v12 = v3 - 1;
    if ( v6 < v3 - 1 )
      v12 = v6;
    memcpy(v4, src, v12);
    result = (const char *)v12;
    if ( v12 )
      result = (const char *)1;
    *((_BYTE *)v4 + v12) = 0;
  }
  return result;
}
// 1353C: could not find valid save-restore pair for r4
// 1353C: could not find valid save-restore pair for r5
// 1353C: could not find valid save-restore pair for r6
// 1353C: could not find valid save-restore pair for r7

//----- (000135BC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
const char *__fastcall sub_135BC(const char *a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  const char *v6; // r4@1
  size_t v7; // r0@1
  const char *v8; // r3@1
  int v9; // r2@5
  bool v10; // zf@5
  const char *result; // r0@8
  int v12; // [sp+0h] [bp+0h]@1
  int *v13; // [sp+8h] [bp+8h]@1
  int v14; // [sp+Ch] [bp+Ch]@1

  v13 = &v12;
  v14 = v5;
  *(_QWORD *)&v12 = *(_QWORD *)&a4;
  v6 = a1;
  v7 = strlen(a1) - 1;
  v8 = &v6[v7];
  if ( v6 == &v6[v7] )
  {
LABEL_11:
    result = 0;
  }
  else
  {
    while ( *(v8 - 1) != 46 )
    {
      if ( v6 == --v8 )
        goto LABEL_11;
    }
    v9 = *v8;
    v10 = v9 == 92;
    if ( v9 != 92 )
      v10 = v9 == 47;
    if ( v10 )
      result = 0;
    else
      result = v8;
  }
  return result;
}
// 135BC: could not find valid save-restore pair for r4
// 135BC: could not find valid save-restore pair for r7
// 135BC: variables would overlap: r3.4 and r3.8
// 135BC: variables would overlap: r4.4 and r3.8

//----- (00013640) --------------------------------------------------------
signed int __fastcall sub_13640(_BYTE *a1, int a2, unsigned __int8 a3)
{
  _BYTE *v3; // r4@1
  int v4; // r0@1
  _BYTE *v5; // r3@1
  _BYTE *v6; // r12@1
  int v7; // r5@1
  signed int v8; // r8@1
  bool v9; // zf@4
  int v10; // r6@9
  signed int result; // r0@12
  int v12; // r6@14
  bool v13; // zf@15
  int v14; // r0@20
  bool v15; // zf@20
  int v16; // r5@35
  int v17; // t1@37

  v3 = a1;
  v4 = 1;
  v5 = v3;
  v6 = v3;
  v7 = *v3;
  v8 = 1;
LABEL_2:
  while ( v7 )
  {
    while ( !v4 || (char)v7 != 46 )
    {
      v9 = (char)v7 == 92;
      if ( (char)v7 != 92 )
        v9 = (char)v7 == 47;
      if ( !v9 )
        goto LABEL_24;
      *v5 = a2;
      v7 = v6[1];
      if ( v5 == v3 )
        v10 = 0;
      else
        v10 = (unsigned __int8)v4 & a3 & 1;
      v4 = 1;
      ++v6;
      v5 += 1 - v10;
      if ( !v7 )
        goto LABEL_12;
    }
    v12 = v6[1];
    if ( v12 != 46 )
    {
      v13 = v12 == 92;
      if ( v12 != 92 )
        v13 = v12 == 47;
      if ( v13 )
      {
        v7 = v6[2];
        v6 += 2;
        goto LABEL_2;
      }
      if ( v6[1] )
      {
LABEL_24:
        v9 = v5 == v6;
        v4 = 0;
        ++v5;
        ++v6;
        if ( !v9 )
          *(v5 - 1) = v7;
        v7 = *v6;
        goto LABEL_2;
      }
      if ( v5 != v3 && *(v5 - 1) == a2 )
        --v5;
      LOBYTE(v7) = 0;
      break;
    }
    v14 = v6[2];
    v15 = v14 == 47;
    if ( v14 != 47 )
      v15 = v14 == 92;
    if ( !v15 && v6[2] )
      goto LABEL_24;
    if ( v5 != v3 )
    {
      while ( 1 )
      {
        v16 = *(v5-- - 1);
        if ( v16 != a2 )
          break;
        if ( v3 == v5 )
          goto LABEL_39;
      }
      while ( v5 != v3 )
      {
        v17 = *(v5-- - 1);
        if ( v17 == a2 )
          goto LABEL_40;
      }
    }
LABEL_39:
    v8 = 0;
LABEL_40:
    v7 = v6[2];
    v6 += 2;
    v4 = v5 - v3 + ((unsigned int)(v5 - v3) <= 0) - (v5 - v3);
  }
LABEL_12:
  result = v8;
  *v5 = v7;
  return result;
}

//----- (00013738) --------------------------------------------------------
signed int __fastcall sub_13738(const char *a1, int a2)
{
  const char *v2; // r5@1
  int v3; // r8@1
  signed int result; // r0@1
  signed int v5; // r4@1
  int v6; // r3@2
  bool v7; // zf@2

  v2 = a1;
  v3 = a2;
  result = strlen(a1);
  v5 = result;
  if ( result > 0 )
  {
    v6 = v2[result - 1];
    v7 = v6 == 92;
    if ( v6 != 92 )
      v7 = v6 == 47;
    if ( !v7 )
    {
      if ( result + 1 >= v3 )
        result = ((int (*)(const char *, ...))Error)("V_AppendSlash: ran out of space on %s.", v2);
      v2[v5] = 47;
      v2[v5 + 1] = 0;
    }
  }
  return result;
}
// 3BE0: invalid function type has been ignored
// 13738: could not find valid save-restore pair for r4
// 13738: could not find valid save-restore pair for r5
// 13738: could not find valid save-restore pair for r6
// 13738: could not find valid save-restore pair for r7

//----- (0001381C) --------------------------------------------------------
int __fastcall sub_1381C(char *buf, size_t size, char *src, char *a4)
{
  char *v4; // r6@1
  char *v5; // r4@1
  signed int v6; // r5@1
  int v7; // r2@1
  char *v8; // r8@1
  int result; // r0@13

  v4 = src;
  v5 = buf;
  v6 = size;
  v7 = (unsigned __int8)*src;
  v8 = a4;
  if ( v7 && (v4[1] == 58 || (v7 = (char)v7, (char)v7 == 47) || v7 == 92) )
  {
    strncpy(buf, v4, size);
    if ( v6 > 0 )
      v5[v6 - 1] = 0;
  }
  else
  {
    if ( a4 && (LOBYTE(a4) = *a4, *v8) && (v8[1] == 58 || (a4 = (char *)(char)a4, (char)a4 == 47) || a4 == (char *)92) )
    {
      strncpy(buf, v8, size);
      if ( v6 > 0 )
        v5[v6 - 1] = 0;
    }
    else
    {
      if ( !getcwd(buf, size) )
        ((void (__fastcall *)(const char *))Error)("V_MakeAbsolutePath: _getcwd failed.");
      if ( v8 )
      {
        sub_13738(v5, v6);
        sub_1250C(v5, v8, v6, -1);
      }
    }
    sub_13738(v5, v6);
    sub_1250C(v5, v4, v6, -1);
  }
  result = sub_13640(v5, 47, 1u);
  if ( !result )
    result = j_Error();
  return result;
}
// 3BE0: invalid function type has been ignored

//----- (00013A80) --------------------------------------------------------
signed int __fastcall sub_13A80(int a1)
{
  int v1; // r3@1
  signed int result; // r0@4
  int *v3; // [sp+0h] [bp+0h]@1

  v3 = (int *)&v3;
  v1 = *(_BYTE *)a1;
  if ( *(_BYTE *)a1 && (*(_BYTE *)(a1 + 1) == 58 || (v1 = (char)v1, (char)v1 == 47)) )
    result = 1;
  else
    result = (unsigned int)(v1 - 92) <= 0;
  return result;
}

//----- (00013AF0) --------------------------------------------------------
int __fastcall sub_13AF0(int a1, char *s, int a3, int a4, int a5, char a6)
{
  const char *v6; // r5@1
  const char *v7; // r4@1
  int v8; // r10@1
  int v9; // r11@1
  char *v10; // r3@2
  int v11; // r1@2
  char *v12; // r2@2
  int v13; // r0@2
  int v14; // r8@3
  size_t v15; // r5@6
  int v16; // r0@6
  int v17; // r1@6
  int v18; // r8@7
  int v19; // r6@9
  signed int v20; // r8@11
  char v22; // [sp+4h] [bp+4h]@11
  size_t v23; // [sp+8h] [bp+8h]@1
  char *sa; // [sp+10h] [bp+10h]@1
  const char *needle; // [sp+14h] [bp+14h]@1

  v6 = (const char *)a4;
  v7 = (const char *)a1;
  v8 = a4;
  sa = (char *)a3;
  needle = s;
  v23 = strlen(s);
  v9 = strlen(sa);
  *v6 = 0;
  while ( 1 )
  {
    v19 = v8 - (_DWORD)v6 + a5;
    if ( !a6 )
      break;
    v10 = strstr(v7, needle);
    v11 = v8 - (_DWORD)v6 + a5;
    v12 = (char *)v7;
    v13 = (int)v6;
    if ( !v10 )
      goto LABEL_11;
LABEL_3:
    v14 = v10 - v7;
    if ( !v19 )
      return 0;
    if ( !sub_116D4(v13, v11, v12, v10 - v7) )
      return 0;
    if ( v19 <= v14 )
      return 0;
    v15 = (size_t)&v6[strlen(v6)];
    v16 = v15;
    v17 = v8 - v15 + a5;
    v6 = (const char *)(v15 + v9);
    if ( !v17 )
      return 0;
    v18 = v14 + v23;
    if ( !sub_116D4(v16, v17, sa, v9) )
      return 0;
    v7 += v18;
  }
  v10 = sub_12140(v7, needle);
  v11 = v8 - (_DWORD)v6 + a5;
  v12 = (char *)v7;
  v13 = (int)v6;
  if ( v10 )
    goto LABEL_3;
LABEL_11:
  v22 = (char)v10;
  v20 = strlen(v7);
  strncpy((char *)v6, v7, v8 - (_DWORD)v6 + a5);
  if ( v19 > 0 )
    v6[v19 - 1] = v22;
  return v19 > v20;
}
// 13AF0: could not find valid save-restore pair for r4
// 13AF0: could not find valid save-restore pair for r5
// 13AF0: could not find valid save-restore pair for r6
// 13AF0: could not find valid save-restore pair for r7
// 13AF0: could not find valid save-restore pair for r8
// 13AF0: could not find valid save-restore pair for r9
// 13AF0: could not find valid save-restore pair for r10
// 13AF0: could not find valid save-restore pair for r11

//----- (00013BE8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__fastcall sub_13BE8(const char *a1, signed int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  signed int v8; // r4@1
  const char *v9; // r6@1
  signed int v10; // r0@2
  signed int v11; // r4@3
  char *v12; // r5@5
  char *result; // r0@5
  __int64 v14; // [sp+0h] [bp+0h]@1
  __int64 v15; // [sp+8h] [bp+8h]@1
  __int64 *v16; // [sp+10h] [bp+10h]@1
  int v17; // [sp+14h] [bp+14h]@1

  v14 = *(_QWORD *)&a4;
  v8 = a2;
  v16 = &v14;
  v17 = v7;
  v15 = *(_QWORD *)&v5;
  v9 = a1;
  if ( a2 == -1 )
  {
    v11 = strlen(a1) + 1;
  }
  else
  {
    v10 = strlen(a1);
    if ( v8 <= v10 )
      v11 = v8 + 1;
    else
      v11 = v10 + 1;
  }
  v12 = (char *)sub_1E9D4(v11);
  strncpy(v12, v9, v11);
  result = v12;
  if ( v11 > 0 )
    v12[v11 - 1] = 0;
  return result;
}
// 13BE8: could not find valid save-restore pair for r4
// 13BE8: could not find valid save-restore pair for r5
// 13BE8: could not find valid save-restore pair for r6
// 13BE8: could not find valid save-restore pair for r7
// 13BE8: variables would overlap: r3.4 and r3.8
// 13BE8: variables would overlap: r4.4 and r3.8
// 13BE8: variables would overlap: r5.4 and r5.8
// 13BE8: variables would overlap: r6.4 and r5.8

//----- (00013CC0) --------------------------------------------------------
signed int __fastcall sub_13CC0(const char *a1, signed int a2, char *a3, signed int a4)
{
  char *v4; // r8@1
  signed int v5; // r5@1
  signed int v6; // r4@1
  const char *v7; // r9@1
  signed int result; // r0@1

  v4 = a3;
  v5 = a2;
  v6 = a4;
  v7 = a1;
  result = strlen(a1);
  if ( result <= v5 )
  {
    result = (signed int)strncpy(v4, v7, v6);
    if ( v6 > 0 )
      v4[v6 - 1] = 0;
  }
  else if ( v6 )
  {
    result = sub_1172C(v7, -v5, result, v4, v6);
  }
  return result;
}

//----- (00013EA8) --------------------------------------------------------
int __fastcall sub_13EA8(int a1, char *a2, size_t a3, char *a4, unsigned int a5)
{
  int v5; // lr@0
  char *v6; // r6@1
  size_t v7; // r10@1
  char *v8; // r9@1
  int v9; // r0@2
  int v10; // r1@2
  int v11; // r2@2
  int v12; // r3@2
  int v13; // r1@2
  int v14; // r2@2
  int v15; // r3@2
  int v16; // r1@2
  int v17; // r2@2
  int result; // r0@4
  int v19; // [sp+4h] [bp+4h]@1
  int v20; // [sp+8h] [bp+8h]@2
  int v21; // [sp+Ch] [bp+Ch]@2
  int v22; // [sp+10h] [bp+10h]@2
  int v23; // [sp+14h] [bp+14h]@2
  int v24; // [sp+18h] [bp+18h]@2
  int v25; // [sp+1Ch] [bp+1Ch]@2
  int v26; // [sp+20h] [bp+20h]@2
  int v27; // [sp+24h] [bp+24h]@2
  int v28; // [sp+28h] [bp+28h]@2
  int v29; // [sp+2Ch] [bp+2Ch]@2
  int v30; // [sp+30h] [bp+30h]@2
  int v31; // [sp+34h] [bp+34h]@2
  int v32; // [sp+7Ch] [bp+7Ch]@1

  v6 = a2;
  v32 = v5;
  v7 = a3;
  v8 = a4;
  v19 = a1;
  if ( a1 > 0 || (time((time_t *)&v19), (result = v19) != 0) )
  {
    v9 = Plat_localtime(&v19, &v31);
    v10 = *(_DWORD *)(v9 + 4);
    v11 = *(_DWORD *)(v9 + 8);
    v12 = *(_DWORD *)(v9 + 12);
    v20 = *(_DWORD *)v9;
    v21 = v10;
    v22 = v11;
    v23 = v12;
    v13 = *(_DWORD *)(v9 + 20);
    v14 = *(_DWORD *)(v9 + 24);
    v15 = *(_DWORD *)(v9 + 28);
    v24 = *(_DWORD *)(v9 + 16);
    v25 = v13;
    v26 = v14;
    v27 = v15;
    v16 = *(_DWORD *)(v9 + 36);
    v17 = *(_DWORD *)(v9 + 40);
    v28 = *(_DWORD *)(v9 + 32);
    v29 = v16;
    v30 = v17;
    if ( v6 )
    {
      *v6 = 0;
      if ( !strftime(v6, v7, "%A %b %d", (const struct tm *)&v20) )
        return 0;
    }
    if ( v8 )
    {
      *v8 = 0;
      if ( !strftime(v8, a5 - 6, "%I:%M ", (const struct tm *)&v20) )
        return 0;
      if ( v22 > 11 )
      {
        sub_1250C(v8, "p.m.", a5, -1);
        return 1;
      }
      sub_1250C(v8, "a.m.", a5, -1);
    }
    result = 1;
  }
  return result;
}
// 3AF8: using guessed type int __fastcall Plat_localtime(_DWORD, _DWORD);

//----- (00013FD0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_13FD0(char *a1, int a2, int a3, int a4)
{
  int v4; // r4@0
  int v5; // r5@0 OVERLAPPED
  int v7; // r7@0 OVERLAPPED
  int v9; // r9@0 OVERLAPPED
  int v11; // r11@0
  int v12; // lr@0
  int v13; // r8@1
  int v14; // r6@1
  char *v15; // r5@1
  int v16; // r3@1
  void *v17; // r2@2
  char *v18; // r0@8
  int v19; // r1@8
  int v20; // r9@10
  signed int v21; // r10@10
  signed int v22; // r4@10
  char *v23; // r11@10
  _BYTE *v24; // t1@11
  char *v25; // r0@11
  signed int v26; // r1@11
  int v27; // r2@18
  int v28; // r3@18
  size_t v29; // r4@18
  int v30; // [sp+Ch] [bp+Ch]@1
  char *v31; // [sp+14h] [bp+14h]@8
  int v32; // [sp+1Ch] [bp+1Ch]@1
  __int64 v33; // [sp+20h] [bp+20h]@1
  __int64 v34; // [sp+28h] [bp+28h]@1
  __int64 v35; // [sp+30h] [bp+30h]@1
  int v36; // [sp+38h] [bp+38h]@1
  int v37; // [sp+3Ch] [bp+3Ch]@1

  v34 = *(_QWORD *)&v7;
  v13 = a4;
  v33 = *(_QWORD *)&v5;
  v14 = a3;
  v15 = a1;
  v32 = v4;
  v36 = v11;
  v37 = v12;
  v35 = *(_QWORD *)&v9;
  v16 = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(v13 + 12) = 0;
  v30 = a2;
  if ( v16 >= 0 )
  {
    if ( *(_DWORD *)v13 )
    {
      free(*(void **)v13);
      *(_DWORD *)v13 = 0;
    }
    v17 = 0;
    *(_DWORD *)(v13 + 4) = 0;
  }
  else
  {
    v17 = *(void **)v13;
  }
  *(_DWORD *)(v13 + 16) = v17;
  if ( v14 > 0 )
  {
    while ( 1 )
    {
      v20 = v30 - 4;
      v21 = 0;
      v22 = -1;
      v23 = 0;
      do
      {
        v24 = *(_BYTE **)(v20 + 4);
        v20 += 4;
        v25 = sub_12140(v15, v24);
        v26 = v23 == 0;
        if ( v25 )
        {
          if ( v25 < v23 )
            v26 = 1;
          if ( v26 )
          {
            v23 = v25;
            v22 = v21;
          }
        }
        ++v21;
      }
      while ( v21 != v14 );
      if ( !v23 )
        break;
      v29 = strlen(*(const char **)(v30 + 4 * v22));
      if ( v15 < v23 )
      {
        v31 = sub_13BE8(v15, v23 - v15, v27, v28);
        sub_14108(v13, *(_DWORD *)(v13 + 12), &v31);
      }
      v15 = &v23[v29];
    }
  }
  if ( *v15 )
  {
    v18 = sub_13BE8(v15, -1, (int)v17, *v15);
    v19 = *(_DWORD *)(v13 + 12);
    v31 = v18;
    sub_14108(v13, v19, &v31);
  }
}
// 13FD0: could not find valid save-restore pair for r4
// 13FD0: could not find valid save-restore pair for r5
// 13FD0: could not find valid save-restore pair for r6
// 13FD0: could not find valid save-restore pair for r7
// 13FD0: could not find valid save-restore pair for r8
// 13FD0: could not find valid save-restore pair for r9
// 13FD0: could not find valid save-restore pair for r10
// 13FD0: could not find valid save-restore pair for r11
// 13FD0: variables would overlap: r5.4 and r5.8
// 13FD0: variables would overlap: r6.4 and r5.8
// 13FD0: variables would overlap: r7.4 and r7.8
// 13FD0: variables would overlap: r8.4 and r7.8
// 13FD0: variables would overlap: r9.4 and r9.8
// 13FD0: variables would overlap: r10.4 and r9.8

//----- (000140DC) --------------------------------------------------------
void __fastcall sub_140DC(char *a1, int a2, int a3)
{
  int v3; // r4@0
  int v4; // r7@0
  int v5; // lr@0
  int v6; // [sp+4h] [bp+4h]@1
  int v7; // [sp+Ch] [bp+Ch]@1
  int v8; // [sp+10h] [bp+10h]@1
  int v9; // [sp+14h] [bp+14h]@1

  v8 = v4;
  v9 = v5;
  v7 = v3;
  v6 = a2;
  sub_13FD0(a1, (int)&v6, 1, a3);
}
// 140DC: could not find valid save-restore pair for r4
// 140DC: could not find valid save-restore pair for r7

//----- (00014108) --------------------------------------------------------
int __fastcall sub_14108(int a1, int a2, _DWORD *a3)
{
  int v3; // r6@1
  int v4; // r5@1
  signed int v5; // r1@1
  _DWORD *v6; // r8@1
  int i; // r3@1
  int v8; // r4@1
  char *v9; // r3@2
  int v10; // r2@3
  int v11; // r4@4
  int v12; // r0@5
  signed int v14; // r2@9
  char *v15; // r0@14
  char *v16; // r0@15
  int v17; // r4@15

  v3 = a2;
  v4 = a1;
  v5 = *(_DWORD *)(a1 + 12);
  v6 = a3;
  i = *(_DWORD *)(a1 + 4);
  v8 = v5 + 1;
  if ( v5 + 1 <= i || (v14 = *(_DWORD *)(a1 + 8), v14 < 0) )
  {
    v9 = *(char **)a1;
  }
  else
  {
    if ( v14 )
    {
      for ( i = v14 + v5 / v14 * v14; v8 > i; i = (i + v8) / 2 )
        ;
    }
    else if ( i || (i = 8, v8 > 8) )
    {
      do
        i *= 2;
      while ( v8 > i );
    }
    v15 = *(char **)a1;
    *(_DWORD *)(v4 + 4) = i;
    if ( v15 )
    {
      v16 = (char *)realloc(v15, 4 * i);
      v17 = *(_DWORD *)(v4 + 12);
      v9 = v16;
      *(_DWORD *)v4 = v16;
      v8 = v17 + 1;
    }
    else
    {
      v9 = (char *)malloc(4 * i);
      *(_DWORD *)v4 = v9;
    }
  }
  *(_DWORD *)(v4 + 12) = v8;
  v10 = v8 - v3 - 1;
  *(_DWORD *)(v4 + 16) = v9;
  if ( v10 > 0 )
  {
    v12 = 4 * (v3 + 1);
    v11 = v12 - 4;
    memmove(&v9[v12], &v9[v12 - 4], 4 * v10);
    v9 = *(char **)v4;
  }
  else
  {
    v11 = 4 * v3;
  }
  if ( &v9[v11] )
    *(_DWORD *)&v9[v11] = *v6;
  return v3;
}
// 14108: could not find valid save-restore pair for r4
// 14108: could not find valid save-restore pair for r5
// 14108: could not find valid save-restore pair for r6
// 14108: could not find valid save-restore pair for r7

//----- (000141B0) --------------------------------------------------------
int __fastcall sub_141B0(int result, int a2)
{
  int v2; // r8@1
  int v3; // r6@1
  int v4; // r5@1
  int v5; // r4@3

  v2 = result;
  v3 = a2;
  v4 = (unsigned __int8)byte_2CB80;
  if ( !byte_2CB80 )
  {
    byte_2CB80 = 1;
    if ( a2 > 0 )
    {
      v5 = v4;
      do
      {
        ++v5;
        if ( dword_2CB84 )
        {
          if ( !dword_2CB88 )
            goto LABEL_9;
        }
        else
        {
          result = (*(int (__fastcall **)(const char *))(v2 + v4))("VEngineCvar004");
          dword_2CB84 = result;
          cvar = result;
          if ( !dword_2CB88 )
          {
LABEL_9:
            result = (*(int (__fastcall **)(const char *))(v2 + v4))("VProcessUtils001");
            dword_2CB88 = result;
            goto LABEL_6;
          }
        }
LABEL_6:
        v4 += 4;
      }
      while ( v5 != v3 );
    }
  }
  return result;
}
// 141B0: could not find valid save-restore pair for r4
// 141B0: could not find valid save-restore pair for r5
// 141B0: could not find valid save-restore pair for r6
// 141B0: could not find valid save-restore pair for r7
// 141B0: could not find valid save-restore pair for r8
// 141B0: could not find valid save-restore pair for r9
// 141B0: could not find valid save-restore pair for r10
// 141B0: could not find valid save-restore pair for r11
// 2CB80: using guessed type char byte_2CB80;
// 2CB84: using guessed type int dword_2CB84;
// 2CB88: using guessed type int dword_2CB88;

//----- (0001428C) --------------------------------------------------------
signed int __fastcall sub_1428C(int a1, _BYTE *a2, signed int *a3)
{
  int v3; // r3@1
  signed int result; // r0@1
  signed int v5; // r3@1
  int *v6; // [sp+0h] [bp+0h]@1

  v3 = *a2;
  v6 = (int *)&v6;
  result = *(_BYTE *)(a1 + v3 + 2328);
  v5 = result;
  if ( result )
    v5 = 1;
  *a3 = v5;
  return result;
}

//----- (000142BC) --------------------------------------------------------
int __fastcall sub_142BC(int a1, const char *a2, _DWORD *a3)
{
  _DWORD *v3; // r11@1
  const char *v4; // r10@1
  int v5; // r5@1
  int v6; // r9@1
  int v7; // r4@2
  int v8; // r6@4
  int v9; // r8@4
  int v10; // r8@4
  int result; // r0@5

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a1 + 16);
  if ( v6 <= 0 )
  {
LABEL_6:
    *v3 = 0;
    result = 0;
  }
  else
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = v5 + v7;
      v9 = *(_BYTE *)(v5 + v7++ + 24);
      v10 = v9 + 35;
      if ( !strcmp(v4, *(const char **)(v5 + 8 * v10 + 4)) )
        break;
      if ( v7 == v6 )
        goto LABEL_6;
    }
    *v3 = *(_DWORD *)(v5 + 8 * v10);
    result = *(_BYTE *)(v8 + 24);
  }
  return result;
}
// 142BC: could not find valid save-restore pair for r4
// 142BC: could not find valid save-restore pair for r5
// 142BC: could not find valid save-restore pair for r6
// 142BC: could not find valid save-restore pair for r7
// 142BC: could not find valid save-restore pair for r8
// 142BC: could not find valid save-restore pair for r9
// 142BC: could not find valid save-restore pair for r10

//----- (00014328) --------------------------------------------------------
void *__fastcall sub_14328(void *result)
{
  __int64 v1; // r4@0
  int v2; // lr@0
  size_t v3; // r5@1
  const void **v4; // r4@1
  void *v5; // r0@3
  int v6; // [sp+0h] [bp+0h]@1
  int *v7; // [sp+8h] [bp+8h]@1
  int v8; // [sp+Ch] [bp+Ch]@1

  v7 = &v6;
  v8 = v2;
  *(_QWORD *)&v6 = v1;
  v3 = *((_DWORD *)result + 1);
  v4 = (const void **)result;
  *((_DWORD *)result + 2) = 0;
  if ( v3 )
  {
    v5 = malloc(v3);
    result = memcpy(v5, *v4, v3);
    *v4 = result;
  }
  else
  {
    *(_DWORD *)result = 0;
  }
  return result;
}
// 14328: could not find valid save-restore pair for r4
// 14328: could not find valid save-restore pair for r5
// 14328: could not find valid save-restore pair for r7

//----- (00014404) --------------------------------------------------------
void *sub_14404()
{
  return &unk_2CBA4;
}

//----- (0001441C) --------------------------------------------------------
void *sub_1441C()
{
  return &unk_2D5BC;
}

//----- (00014438) --------------------------------------------------------
int __fastcall sub_14438(int a1, int a2, char *s, int a4, int a5)
{
  int v5; // r6@1
  int v6; // r5@1
  int v7; // r4@1
  int v8; // r9@2
  int v9; // r10@2
  int v10; // r6@3
  int v11; // r3@3
  const char *v12; // r0@3
  signed int v13; // r0@3

  v5 = a4;
  v6 = a1;
  v7 = 0;
  *(_BYTE *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = s;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)a1 = &off_28908;
  *(_DWORD *)(a1 + 12) = strlen(s);
  *(_DWORD *)(v6 + 20) = 0;
  memset((void *)(v6 + 280), 0, 0x800u);
  if ( v5 > 0 )
  {
    v8 = 8 * v5;
    v9 = v6 + 23;
    do
    {
      v10 = *(_BYTE *)(a5 + v7);
      v11 = a5 + v7;
      v7 += 8;
      *(_BYTE *)(v9++ + 1) = v10;
      v10 += 35;
      v12 = *(const char **)(v11 + 4);
      *(_DWORD *)(v6 + 8 * v10 + 4) = v12;
      v13 = strlen(v12);
      *(_DWORD *)(v6 + 8 * v10) = v13;
      if ( *(_DWORD *)(v6 + 20) < v13 )
        *(_DWORD *)(v6 + 20) = v13;
    }
    while ( v7 != v8 );
  }
  return v6;
}
// 14438: could not find valid save-restore pair for r4
// 14438: could not find valid save-restore pair for r5
// 14438: could not find valid save-restore pair for r6
// 14438: could not find valid save-restore pair for r7
// 14438: could not find valid save-restore pair for r8
// 14438: could not find valid save-restore pair for r9
// 28908: using guessed type void *;

//----- (000145D4) --------------------------------------------------------
void **__fastcall sub_145D4(void **result, signed int a2)
{
  __int64 v2; // r4@0
  int v3; // lr@0
  void **v4; // r4@1
  signed int v5; // r5@1
  signed int v6; // r3@2
  void *v7; // r0@5
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = v2;
  v4 = result;
  v5 = a2 + 1;
  v9 = &v8;
  v10 = v3;
  if ( (signed int)result[2] >= 0 )
    goto LABEL_2;
  if ( !(*((_BYTE *)result + 21) & 2) )
  {
    v5 = a2;
LABEL_2:
    v6 = (signed int)result[1];
    goto LABEL_3;
  }
  v6 = (signed int)result[1];
  if ( v5 > v6 )
  {
    result = (void **)sub_14328(result);
    v6 = (signed int)v4[1];
  }
  else
  {
    v5 = a2;
  }
LABEL_3:
  if ( v5 > v6 && (signed int)v4[2] >= 0 )
  {
    v7 = *v4;
    v4[1] = (void *)v5;
    if ( v7 )
    {
      result = (void **)realloc(v7, v5);
      *v4 = result;
    }
    else
    {
      result = (void **)malloc(v5);
      *v4 = result;
    }
  }
  return result;
}
// 145D4: could not find valid save-restore pair for r4
// 145D4: could not find valid save-restore pair for r5
// 145D4: could not find valid save-restore pair for r7

//----- (00014678) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_14678(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r3@1
  signed int v7; // r0@1
  bool v8; // nf@1
  signed int v9; // r2@1
  int v10; // r0@2
  int v11; // r4@5
  int v13; // [sp+0h] [bp+0h]@1
  int *v14; // [sp+8h] [bp+8h]@1
  int v15; // [sp+Ch] [bp+Ch]@1

  v14 = &v13;
  v15 = v5;
  *(_QWORD *)&v13 = *(_QWORD *)&a4;
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 48);
  v9 = v7 << 31;
  v8 = v7 << 31 < 0;
  if ( v8 )
  {
    v10 = v7 >> 1;
    v9 = *(_DWORD *)(v6 + 44);
  }
  else
  {
    v10 = v6 + (v7 >> 1);
    v6 = *(_DWORD *)(v6 + 44);
  }
  if ( v8 )
  {
    v11 = *(_DWORD *)(v6 + v10);
    v10 += v6;
    v6 = *(_DWORD *)(v11 + v9);
  }
  return ((int (__fastcall *)(int))v6)(v10);
}
// 14678: could not find valid save-restore pair for r4
// 14678: could not find valid save-restore pair for r7
// 14678: variables would overlap: r3.4 and r3.8
// 14678: variables would overlap: r4.4 and r3.8

//----- (000146A4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_146A4(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r3@1
  signed int v7; // r0@1
  bool v8; // nf@1
  signed int v9; // r2@1
  int v10; // r0@2
  int v11; // r4@5
  int v13; // [sp+0h] [bp+0h]@1
  int *v14; // [sp+8h] [bp+8h]@1
  int v15; // [sp+Ch] [bp+Ch]@1

  v14 = &v13;
  v15 = v5;
  *(_QWORD *)&v13 = *(_QWORD *)&a4;
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 40);
  v9 = v7 << 31;
  v8 = v7 << 31 < 0;
  if ( v8 )
  {
    v10 = v7 >> 1;
    v9 = *(_DWORD *)(v6 + 36);
  }
  else
  {
    v10 = v6 + (v7 >> 1);
    v6 = *(_DWORD *)(v6 + 36);
  }
  if ( v8 )
  {
    v11 = *(_DWORD *)(v6 + v10);
    v10 += v6;
    v6 = *(_DWORD *)(v11 + v9);
  }
  return ((int (__fastcall *)(int))v6)(v10);
}
// 146A4: could not find valid save-restore pair for r4
// 146A4: could not find valid save-restore pair for r7
// 146A4: variables would overlap: r3.4 and r3.8
// 146A4: variables would overlap: r4.4 and r3.8

//----- (000146D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_146D0(int a1, int a2, int a3, int a4)
{
  __int64 v5; // r5@0
  int v6; // lr@0
  int v7; // r4@1
  char v8; // r2@1
  int result; // r0@1
  int v10; // r3@2
  int v11; // r2@3
  __int64 v12; // [sp+0h] [bp+0h]@1
  __int64 v13; // [sp+8h] [bp+8h]@1
  __int64 *v14; // [sp+10h] [bp+10h]@1
  int v15; // [sp+14h] [bp+14h]@1

  v12 = *(_QWORD *)&a4;
  v7 = a1;
  v14 = &v12;
  v15 = v6;
  v13 = v5;
  v8 = *(_BYTE *)(a1 + 20);
  result = v8 & 2;
  if ( v8 & 2 )
  {
    result = 0;
  }
  else
  {
    v10 = *(_DWORD *)(v7 + 12);
    if ( *(_DWORD *)(v7 + 28) < v10 + a2 )
    {
      *(_BYTE *)(v7 + 20) = v8 | 2;
    }
    else
    {
      v11 = *(_DWORD *)(v7 + 32);
      if ( v10 < v11 || (v10 = v10 - v11 + a2, *(_DWORD *)(v7 + 4) < v10) )
      {
        result = sub_146A4(v7, a2, v11, v10);
        if ( !result )
          *(_BYTE *)(v7 + 20) |= 2u;
      }
      else
      {
        result = 1;
      }
    }
  }
  return result;
}
// 146D0: could not find valid save-restore pair for r4
// 146D0: could not find valid save-restore pair for r5
// 146D0: could not find valid save-restore pair for r6
// 146D0: could not find valid save-restore pair for r7
// 146D0: variables would overlap: r3.4 and r3.8
// 146D0: variables would overlap: r4.4 and r3.8

//----- (0001472C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_DWORD *__fastcall sub_1472C(_DWORD *result, void *a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  size_t v8; // r5@1
  void *v9; // r6@1
  _DWORD *v10; // r4@1
  int v11; // [sp+0h] [bp+0h]@1
  __int64 v12; // [sp+8h] [bp+8h]@1
  int *v13; // [sp+10h] [bp+10h]@1
  int v14; // [sp+14h] [bp+14h]@1

  v12 = *(_QWORD *)&v5;
  v8 = a3;
  v9 = a2;
  v13 = &v11;
  v14 = v7;
  *(_QWORD *)&v11 = *(_QWORD *)&a4;
  v10 = result;
  if ( a3 > 0 )
  {
    result = (_DWORD *)sub_146D0((int)result, a3, a3, a4);
    if ( result )
    {
      result = memcpy(v9, (const void *)(v10[3] - v10[8] + *v10), v8);
      v10[3] += v8;
    }
  }
  return result;
}
// 1472C: could not find valid save-restore pair for r4
// 1472C: could not find valid save-restore pair for r5
// 1472C: could not find valid save-restore pair for r6
// 1472C: could not find valid save-restore pair for r7
// 1472C: variables would overlap: r3.4 and r3.8
// 1472C: variables would overlap: r4.4 and r3.8
// 1472C: variables would overlap: r5.4 and r5.8
// 1472C: variables would overlap: r6.4 and r5.8

//----- (00014768) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_14768(int result, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r4@1
  int v9; // r3@1
  int v10; // r2@1
  int v11; // r3@2
  int v12; // r2@4
  int v13; // r6@4
  int v14; // [sp+0h] [bp+0h]@1
  __int64 v15; // [sp+8h] [bp+8h]@1
  int *v16; // [sp+10h] [bp+10h]@1
  int v17; // [sp+14h] [bp+14h]@1

  v16 = &v14;
  v17 = v7;
  *(_QWORD *)&v14 = *(_QWORD *)&a4;
  v8 = result;
  v15 = *(_QWORD *)&v5;
  v9 = *(_BYTE *)(result + 21);
  v10 = v9 << 31;
  if ( v9 & 1 )
  {
    v11 = *(_BYTE *)(result + 20);
    if ( !*(_BYTE *)(result + 20) )
    {
      while ( 1 )
      {
        result = sub_146D0(v8, 1, v10, v11);
        if ( !result )
          break;
        v12 = *(_DWORD *)(v8 + 12);
        result = *(_DWORD *)(v8 + 32);
        v13 = v12 + 1;
        v10 = v12 - result;
        v11 = *(_BYTE *)(*(_BYTE *)(*(_DWORD *)v8 + v10) + ctype_ + 1) << 28;
        if ( !(*(_BYTE *)(*(_BYTE *)(*(_DWORD *)v8 + v10) + ctype_ + 1) & 8) )
          break;
        *(_DWORD *)(v8 + 12) = v13;
      }
    }
  }
  return result;
}
// 14768: could not find valid save-restore pair for r4
// 14768: could not find valid save-restore pair for r5
// 14768: could not find valid save-restore pair for r6
// 14768: could not find valid save-restore pair for r7
// 14768: variables would overlap: r3.4 and r3.8
// 14768: variables would overlap: r4.4 and r3.8
// 14768: variables would overlap: r5.4 and r5.8
// 14768: variables would overlap: r6.4 and r5.8

//----- (000147B8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_147B8(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int result; // r0@1
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = *(_QWORD *)&a4;
  v6 = a1;
  v9 = &v8;
  v10 = v5;
  result = sub_146D0(a1, a2 + a3, a3, a4);
  *(_BYTE *)(v6 + 20) &= 0xFDu;
  return result;
}
// 147B8: could not find valid save-restore pair for r4
// 147B8: could not find valid save-restore pair for r7
// 147B8: variables would overlap: r3.4 and r3.8
// 147B8: variables would overlap: r4.4 and r3.8

//----- (000147F8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_147F8(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r5@1
  int v9; // r4@1
  int result; // r0@1
  int v11; // r3@2
  int v12; // [sp+0h] [bp+0h]@1
  __int64 v13; // [sp+8h] [bp+8h]@1
  int *v14; // [sp+10h] [bp+10h]@1
  int v15; // [sp+14h] [bp+14h]@1

  v14 = &v12;
  v15 = v7;
  v13 = *(_QWORD *)&v5;
  v8 = a2;
  *(_QWORD *)&v12 = *(_QWORD *)&a4;
  v9 = a1;
  result = *(_BYTE *)(a1 + 21) & 1;
  if ( result )
  {
    v11 = *(_BYTE *)(v9 + 20);
    if ( *(_BYTE *)(v9 + 20) )
    {
      result = 0;
    }
    else
    {
      do
      {
        if ( !sub_147B8(v9, v8, 1, v11) )
          break;
        if ( !(*(_BYTE *)(*(_BYTE *)(*(_DWORD *)v9 + *(_DWORD *)(v9 + 12) + v8 - *(_DWORD *)(v9 + 32)) + ctype_ + 1) & 8) )
          break;
        ++v8;
        v11 = *(_BYTE *)(v9 + 20) << 30;
      }
      while ( !(*(_BYTE *)(v9 + 20) & 2) );
      result = v8;
    }
  }
  return result;
}
// 147F8: could not find valid save-restore pair for r4
// 147F8: could not find valid save-restore pair for r5
// 147F8: could not find valid save-restore pair for r6
// 147F8: could not find valid save-restore pair for r7
// 147F8: variables would overlap: r3.4 and r3.8
// 147F8: variables would overlap: r4.4 and r3.8
// 147F8: variables would overlap: r5.4 and r5.8
// 147F8: variables would overlap: r6.4 and r5.8

//----- (00014854) --------------------------------------------------------
int __fastcall sub_14854(int a1, int a2, _BYTE *a3, int a4)
{
  _BYTE *v4; // r8@1
  int v5; // r4@1
  int v6; // r9@1
  int v7; // r6@1
  int result; // r0@2

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a4;
  if ( *(_BYTE *)(a1 + 20) & 2 || !sub_147B8(a1, a2, a4, *(_BYTE *)(a1 + 20) << 30) )
    result = 0;
  else
    result = sub_11BC8((_BYTE *)(*(_DWORD *)v5 + v6 + *(_DWORD *)(v5 + 12) - *(_DWORD *)(v5 + 32)), v4, v7) == 0;
  return result;
}
// 14854: could not find valid save-restore pair for r4
// 14854: could not find valid save-restore pair for r5
// 14854: could not find valid save-restore pair for r6
// 14854: could not find valid save-restore pair for r7
// 14854: could not find valid save-restore pair for r8

//----- (000148A8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_148A8(int a1, int a2, int *a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int *v8; // r5@1
  int v9; // r6@1
  int v10; // r4@1
  int v11; // r3@1
  int v12; // r0@2
  int v13; // r2@6
  int v14; // r3@6
  int result; // r0@8
  int v16; // [sp+0h] [bp+0h]@1
  __int64 v17; // [sp+8h] [bp+8h]@1
  int *v18; // [sp+10h] [bp+10h]@1
  int v19; // [sp+14h] [bp+14h]@1

  v18 = &v16;
  v19 = v7;
  v17 = *(_QWORD *)&v5;
  v8 = a3;
  *(_QWORD *)&v16 = *(_QWORD *)&a4;
  v9 = *(_DWORD *)(a1 + 12);
  v10 = a1;
  v11 = *(_DWORD *)(a1 + 28);
  if ( v9 + a2 >= v11 )
  {
    result = 0;
    *a3 = 0;
  }
  else
  {
    v12 = *a3;
    if ( v11 < v9 + a2 + *a3 )
    {
      v12 = v11 - v9 - a2;
      *a3 = v12;
    }
    if ( !(*(_BYTE *)(v10 + 20) & 2) )
    {
      sub_147B8(v10, a2, v12, *(_BYTE *)(v10 + 20) << 30);
      v12 = *v8;
    }
    v13 = *(_DWORD *)(v10 + 28);
    v14 = v13 - *(_DWORD *)(v10 + 12);
    if ( v14 < v12 )
    {
      v12 = v13 - *(_DWORD *)(v10 + 12);
      *v8 = v14;
    }
    result = v12 != 0;
  }
  return result;
}
// 148A8: could not find valid save-restore pair for r4
// 148A8: could not find valid save-restore pair for r5
// 148A8: could not find valid save-restore pair for r6
// 148A8: could not find valid save-restore pair for r7
// 148A8: variables would overlap: r3.4 and r3.8
// 148A8: variables would overlap: r4.4 and r3.8
// 148A8: variables would overlap: r5.4 and r5.8
// 148A8: variables would overlap: r6.4 and r5.8

//----- (00014954) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_14954(int a1, int a2, int a3, int a4)
{
  int v4; // r4@0
  int v5; // r5@0 OVERLAPPED
  __int64 v7; // r7@0
  int v8; // r9@0 OVERLAPPED
  int v10; // r11@0
  int v11; // lr@0
  int v12; // r10@1
  int v13; // r6@1
  int v14; // r11@3
  int result; // r0@4
  int v16; // r0@5
  int v17; // r2@5
  int v18; // r5@5
  int v19; // r4@12
  int v20; // t1@12
  int v21; // t1@18
  int v22; // [sp+0h] [bp+0h]@4
  int v23; // [sp+Ch] [bp+Ch]@1
  __int64 v24; // [sp+10h] [bp+10h]@1
  __int64 v25; // [sp+18h] [bp+18h]@1
  __int64 v26; // [sp+20h] [bp+20h]@1
  int v27; // [sp+28h] [bp+28h]@1
  int v28; // [sp+2Ch] [bp+2Ch]@1

  v26 = *(_QWORD *)&v8;
  v12 = a1;
  v25 = v7;
  v27 = v10;
  v28 = v11;
  v24 = *(_QWORD *)&v5;
  v23 = v4;
  v13 = *(_BYTE *)(a1 + 21) & 1;
  if ( *(_BYTE *)(a1 + 21) & 1 )
    v13 = sub_147F8(a1, 0, a3, a4);
  v14 = v13;
  while ( 1 )
  {
    v22 = 128;
    result = sub_148A8(v12, v14, &v22, a4);
    if ( !result )
      break;
    v16 = *(_DWORD *)v12;
    a4 = *(_BYTE *)(v12 + 21) & 1;
    v17 = *(_DWORD *)(v12 + 12) + v14 - *(_DWORD *)(v12 + 32);
    v18 = *(_DWORD *)v12 + v17;
    if ( *(_BYTE *)(v12 + 21) & 1 )
    {
      if ( v22 > 0 )
      {
        a4 = *(_BYTE *)(v16 + v17);
        if ( *(_BYTE *)(ctype_ + a4 + 1) & 8 )
          goto LABEL_21;
        if ( !*(_BYTE *)(v16 + v17) )
          return v14 + a4 - v13 + 1;
        a4 = 0;
        while ( ++a4 != v22 )
        {
          v20 = *(_BYTE *)(v18++ + 1);
          v19 = v20;
          if ( *(_BYTE *)(ctype_ + v20 + 1) & 8 || !v19 )
            return v14 + a4 - v13 + 1;
        }
        goto LABEL_20;
      }
LABEL_22:
      a4 = v22;
      v14 += v22;
    }
    else
    {
      if ( v22 <= 0 )
        goto LABEL_22;
      if ( !*(_BYTE *)(v16 + v17) )
      {
LABEL_21:
        a4 = 0;
        return v14 + a4 - v13 + 1;
      }
      while ( ++a4 != v22 )
      {
        v21 = *(_BYTE *)(v18++ + 1);
        if ( !v21 )
          return v14 + a4 - v13 + 1;
      }
LABEL_20:
      v14 += a4;
    }
  }
  if ( v14 != v13 )
    result = v14 - v13 + 1;
  return result;
}
// 14954: could not find valid save-restore pair for r4
// 14954: could not find valid save-restore pair for r5
// 14954: could not find valid save-restore pair for r6
// 14954: could not find valid save-restore pair for r7
// 14954: could not find valid save-restore pair for r8
// 14954: could not find valid save-restore pair for r9
// 14954: could not find valid save-restore pair for r10
// 14954: could not find valid save-restore pair for r11
// 14954: variables would overlap: r5.4 and r5.8
// 14954: variables would overlap: r6.4 and r5.8
// 14954: variables would overlap: r9.4 and r9.8
// 14954: variables would overlap: r10.4 and r9.8

//----- (00014A64) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_14A64(int a1, int a2, int a3, int a4)
{
  int v4; // r4@0
  int v5; // r5@0 OVERLAPPED
  __int64 v7; // r7@0
  int v8; // r9@0 OVERLAPPED
  int v10; // r11@0
  int v11; // lr@0
  int v12; // r11@1
  int v13; // r10@1
  int v14; // r5@3
  bool v15; // zf@4
  int v16; // r4@7
  int v17; // t1@11
  bool v18; // zf@11
  int result; // r0@17
  int v20; // [sp+0h] [bp+0h]@2
  int v21; // [sp+Ch] [bp+Ch]@1
  __int64 v22; // [sp+10h] [bp+10h]@1
  __int64 v23; // [sp+18h] [bp+18h]@1
  __int64 v24; // [sp+20h] [bp+20h]@1
  int v25; // [sp+28h] [bp+28h]@1
  int v26; // [sp+2Ch] [bp+2Ch]@1

  v23 = v7;
  v25 = v10;
  v26 = v11;
  v12 = 0;
  v24 = *(_QWORD *)&v8;
  v13 = a1;
  v22 = *(_QWORD *)&v5;
  v21 = v4;
  while ( 1 )
  {
    v20 = 128;
    if ( !sub_148A8(v13, v12, &v20, a4) )
    {
      result = v12;
      if ( !v12 )
        return result;
      return v12 + 1;
    }
    a4 = *(_DWORD *)(v13 + 12) + v12 - *(_DWORD *)(v13 + 32);
    v14 = *(_DWORD *)v13 + a4;
    if ( v20 > 0 )
      break;
LABEL_16:
    v12 += v20;
  }
  a4 = *(_BYTE *)(*(_DWORD *)v13 + a4);
  v15 = a4 == 10;
  if ( a4 != 10 )
    v15 = a4 == 13;
  if ( !v15 )
  {
    v16 = 0;
    if ( !a4 )
    {
      v16 = 0;
LABEL_19:
      v12 += v16;
      return v12 + 1;
    }
    while ( ++v16 != v20 )
    {
      v17 = *(_BYTE *)(v14++ + 1);
      a4 = v17;
      v18 = v17 == 10;
      if ( v17 != 10 )
        v18 = a4 == 13;
      if ( v18 )
        return v12 + v16 + 2;
      if ( !a4 )
        goto LABEL_19;
    }
    goto LABEL_16;
  }
  v16 = 0;
  return v12 + v16 + 2;
}
// 14A64: could not find valid save-restore pair for r4
// 14A64: could not find valid save-restore pair for r5
// 14A64: could not find valid save-restore pair for r6
// 14A64: could not find valid save-restore pair for r7
// 14A64: could not find valid save-restore pair for r8
// 14A64: could not find valid save-restore pair for r9
// 14A64: could not find valid save-restore pair for r10
// 14A64: could not find valid save-restore pair for r11
// 14A64: variables would overlap: r5.4 and r5.8
// 14A64: variables would overlap: r6.4 and r5.8
// 14A64: variables would overlap: r9.4 and r9.8
// 14A64: variables would overlap: r10.4 and r9.8

//----- (00014C40) --------------------------------------------------------
int __fastcall sub_14C40(int a1, int a2, int a3)
{
  __int64 v3; // r4@0
  int v4; // lr@0
  int v5; // r4@1
  int v6; // r5@1
  int result; // r0@2
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = v3;
  v5 = a1;
  v6 = a3;
  v9 = &v8;
  v10 = v4;
  if ( *(_BYTE *)(a1 + 20) & 2 || !sub_147B8(a1, a3, a2, *(_BYTE *)(a1 + 20) << 30) )
    result = 0;
  else
    result = *(_DWORD *)v5 + v6 + *(_DWORD *)(v5 + 12) - *(_DWORD *)(v5 + 32);
  return result;
}
// 14C40: could not find valid save-restore pair for r4
// 14C40: could not find valid save-restore pair for r5
// 14C40: could not find valid save-restore pair for r7

//----- (00014C74) --------------------------------------------------------
int __fastcall sub_14C74(int result, int a2, int a3)
{
  int v3; // r3@4
  int v4; // r3@6
  int v5; // r3@9
  int *v6; // [sp+0h] [bp+0h]@1

  v6 = (int *)&v6;
  if ( a2 == 1 )
  {
    v3 = *(_DWORD *)(result + 28);
    a3 += *(_DWORD *)(result + 12);
    *(_DWORD *)(result + 12) = a3;
  }
  else if ( a2 == 2 )
  {
    v3 = *(_DWORD *)(result + 28);
    a3 = v3 - a3;
    *(_DWORD *)(result + 12) = a3;
  }
  else
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(result + 28);
      *(_DWORD *)(result + 12) = a3;
      if ( a3 <= v5 )
        goto LABEL_6;
LABEL_10:
      *(_BYTE *)(result + 20) |= 2u;
      return result;
    }
    v3 = *(_DWORD *)(result + 28);
    a3 = *(_DWORD *)(result + 12);
  }
  if ( a3 > v3 )
    goto LABEL_10;
LABEL_6:
  v4 = *(_DWORD *)(result + 32);
  *(_BYTE *)(result + 20) &= 0xFDu;
  if ( v4 > a3 || (v4 += *(_DWORD *)(result + 4), v4 <= a3) )
    result = sub_146A4(result, -1, a3, v4);
  return result;
}

//----- (00014CD8) --------------------------------------------------------
_DWORD *__fastcall sub_14CD8(_DWORD *result, _BYTE *a2, int a3, int a4)
{
  void *v4; // r8@1
  int v5; // r5@1
  int v6; // r4@1
  int v7; // r3@3
  _DWORD *v8; // r9@3

  v4 = a2;
  v5 = (int)result;
  v6 = a3;
  if ( *((_BYTE *)result + 20) )
  {
    *a2 = 0;
  }
  else
  {
    if ( a3 )
    {
      result = (_DWORD *)sub_14A64((int)result, (int)a2, a3, a4);
      v8 = result;
      if ( !result )
        goto LABEL_4;
      if ( v6 < (signed int)result )
      {
        sub_1472C((_DWORD *)v5, v4, v6 - 1, v7);
        *((char *)v4 + v6 - 1) = 0;
        return (_DWORD *)sub_14C74(v5, 1, (int)v8 + -v6 - 1);
      }
    }
    else
    {
      result = (_DWORD *)sub_14A64((int)result, (int)a2, 0, a4);
      v8 = result;
      if ( !result )
      {
LABEL_4:
        *(_BYTE *)v4 = 0;
        *(_BYTE *)(v5 + 20) |= 2u;
        return result;
      }
    }
    result = sub_1472C((_DWORD *)v5, v4, (int)v8 - 1, v7);
    *((_BYTE *)v8 + (_DWORD)v4 - 1) = 0;
  }
  return result;
}
// 14CD8: could not find valid save-restore pair for r4

//----- (00014D70) --------------------------------------------------------
int __fastcall sub_14D70(int a1, const char *a2)
{
  char *v2; // r8@1
  int v3; // r10@1
  signed int v4; // r4@1
  int v5; // r11@2
  int v6; // r3@5
  int v7; // r5@6
  int v8; // r6@7
  signed int v9; // r3@7
  int v10; // r2@8
  int v12; // [sp+4h] [bp+4h]@1

  v2 = (char *)a2;
  v3 = a1;
  v4 = strlen(a2);
  v12 = *(_DWORD *)(v3 + 12);
  if ( *(_DWORD *)(v3 + 4) - v12 - *(_DWORD *)(v3 + 32) >= *(_DWORD *)(v3 + 28) - v12 )
    v5 = *(_DWORD *)(v3 + 28) - v12;
  else
    v5 = *(_DWORD *)(v3 + 4) - v12 - *(_DWORD *)(v3 + 32);
  if ( v4 <= v5 )
  {
    v6 = *(_BYTE *)(v3 + 20);
    if ( !(v6 & 2) )
    {
      while ( 1 )
      {
        v7 = sub_147B8(v3, 0, v5, v6);
        if ( !v7 )
          break;
        v8 = *(_DWORD *)(v3 + 12) - *(_DWORD *)(v3 + 32) + *(_DWORD *)v3;
        v9 = sub_12208(v8, v2, v5);
        if ( v9 )
        {
          sub_14C74(v3, 1, v9 + v4 - v8);
          return v7;
        }
        sub_14C74(v3, 1, v5 - v4 - 1);
        v10 = *(_DWORD *)(v3 + 28);
        if ( *(_DWORD *)(v3 + 4) + 1 - v4 >= v10 - *(_DWORD *)(v3 + 12) )
          v5 = v10 - *(_DWORD *)(v3 + 12);
        else
          v5 = *(_DWORD *)(v3 + 4) + 1 - v4;
        if ( v4 <= v5 )
        {
          v6 = *(_BYTE *)(v3 + 20) << 30;
          if ( !(*(_BYTE *)(v3 + 20) & 2) )
            continue;
        }
        break;
      }
    }
  }
  v7 = 0;
  sub_14C74(v3, 0, v12);
  return v7;
}
// 14D70: could not find valid save-restore pair for r4
// 14D70: could not find valid save-restore pair for r5
// 14D70: could not find valid save-restore pair for r6
// 14D70: could not find valid save-restore pair for r7
// 14D70: could not find valid save-restore pair for r8
// 14D70: could not find valid save-restore pair for r9
// 14D70: could not find valid save-restore pair for r10
// 14D70: could not find valid save-restore pair for r11

//----- (00014E58) --------------------------------------------------------
_DWORD *__fastcall sub_14E58(_DWORD *result, _BYTE *a2, int a3)
{
  int v3; // r4@1
  signed int v4; // r5@1
  void *v5; // r8@1
  int v6; // r1@4
  int v7; // r3@4
  _DWORD *v8; // r6@4
  int v9; // r2@7
  int v10; // r3@7

  v3 = (int)result;
  v4 = a3;
  v5 = a2;
  if ( *((_BYTE *)result + 20) )
  {
    *a2 = 0;
    return result;
  }
  if ( !a3 )
    v4 = 0x7FFFFFFF;
  result = (_DWORD *)sub_14954((int)result, (int)a2, a3, *((_BYTE *)result + 20));
  v7 = *(_BYTE *)(v3 + 21);
  v8 = result;
  if ( !(v7 & 1) )
  {
    if ( result )
      goto LABEL_6;
LABEL_9:
    *(_BYTE *)v5 = (_BYTE)v8;
    *(_BYTE *)(v3 + 20) |= 2u;
    return result;
  }
  result = (_DWORD *)sub_14768(v3, v6, *(_BYTE *)(v3 + 21) << 31, *(_BYTE *)(v3 + 21));
  if ( !v8 )
    goto LABEL_9;
LABEL_6:
  if ( v4 >= (signed int)v8 )
  {
    result = sub_1472C((_DWORD *)v3, v5, (int)v8 - 1, v7);
    *((_BYTE *)v5 + (_DWORD)v8 - 1) = 0;
    v10 = *(_BYTE *)(v3 + 21) << 31;
    if ( *(_BYTE *)(v3 + 21) & 1 )
      return result;
  }
  else
  {
    sub_1472C((_DWORD *)v3, v5, v4 - 1, v7);
    *((char *)v5 + v4 - 1) = 0;
    result = (_DWORD *)sub_14C74(v3, 1, (int)v8 + -v4 - 1);
    v10 = *(_BYTE *)(v3 + 21) << 31;
    if ( *(_BYTE *)(v3 + 21) & 1 )
      return result;
  }
  result = (_DWORD *)sub_146D0(v3, 1, v9, v10);
  if ( result )
    ++*(_DWORD *)(v3 + 12);
  return result;
}
// 14E58: could not find valid save-restore pair for r4
// 14E58: could not find valid save-restore pair for r5
// 14E58: could not find valid save-restore pair for r6
// 14E58: could not find valid save-restore pair for r7

//----- (00014F00) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_14F00(int a1, int a2, _DWORD **a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0 OVERLAPPED
  __int64 v8; // r9@0
  int v9; // r11@0
  int v10; // lr@0
  _DWORD **v11; // r6@1
  int v12; // r4@1
  int v13; // r5@1
  int result; // r0@1
  int v15; // r0@3
  int v16; // r8@3
  int v17; // r2@4
  int v18; // r3@4
  int v19; // r11@5
  int v20; // r3@7
  int v21; // r8@7
  int v22; // r2@13
  _DWORD *v23; // r11@17
  int v24; // r0@17
  char **v25; // r1@18
  int v26; // r2@18
  unsigned __int32 v27; // r0@19
  int v28; // r0@20
  int v29; // r1@20
  _BYTE *v30; // r1@25
  int v31; // r11@26
  _DWORD *v32; // r6@26
  int v38; // r0@27
  int v39; // r1@27
  _BYTE *v40; // r3@31
  int v41; // r0@32
  _BYTE *v42; // [sp+0h] [bp+0h]@32
  int v43; // [sp+8h] [bp+8h]@17
  int v44; // [sp+10h] [bp+10h]@18
  int v45; // [sp+1Ch] [bp+1Ch]@1
  __int64 v46; // [sp+20h] [bp+20h]@1
  __int64 v47; // [sp+28h] [bp+28h]@1
  __int64 v48; // [sp+30h] [bp+30h]@1
  int v49; // [sp+38h] [bp+38h]@1
  int v50; // [sp+3Ch] [bp+3Ch]@1

  v47 = *(_QWORD *)&v6;
  v46 = *(_QWORD *)&v4;
  v11 = a3;
  v45 = v3;
  v12 = a1;
  v49 = v9;
  v50 = v10;
  v48 = v8;
  v13 = *(_BYTE *)(a1 + 20);
  result = 0;
  if ( !v13 )
  {
    result = *(_BYTE *)(v12 + 21) & 1;
    if ( *(_BYTE *)(v12 + 21) & 1 )
    {
      while ( 1 )
      {
LABEL_3:
        v15 = *(_BYTE *)a2;
        v16 = a2 + 1;
        if ( !*(_BYTE *)a2 )
          return v13;
        while ( 1 )
        {
          v17 = *(_DWORD *)(v12 + 12);
          v18 = *(_DWORD *)(v12 + 28);
          if ( v17 >= v18 )
          {
            result = v13;
            *(_BYTE *)(v12 + 20) |= 2u;
            return result;
          }
          v19 = v15;
          if ( v15 == 32 )
          {
            sub_14768(v12, a2, v17, v18);
            a2 = v16;
            goto LABEL_3;
          }
          if ( v15 == 37 )
            break;
          if ( !(*(_BYTE *)(v12 + 20) & 2) )
          {
            if ( sub_147B8(v12, *(_BYTE *)(v12 + 20) & 2, 1, v18) )
            {
              v22 = *(_DWORD *)(v12 + 12);
              if ( *(_BYTE *)(*(_DWORD *)v12 + v22 - *(_DWORD *)(v12 + 32)) == v19 )
              {
                a2 = v16++;
                *(_DWORD *)(v12 + 12) = v22 + 1;
                v15 = *(_BYTE *)a2;
                if ( *(_BYTE *)a2 )
                  continue;
              }
            }
          }
          return v13;
        }
        LOBYTE(v20) = *(_BYTE *)(a2 + 1);
        v21 = a2 + 2;
        if ( !*(_BYTE *)(a2 + 1) )
          return v13;
        v20 = (char)v20;
        switch ( (char)v20 )
        {
          default:
            return v13;
          case 120:
            v23 = *v11;
            ++v11;
            v43 = 128;
            v24 = sub_148A8(v12, 0, &v43, v20);
            if ( !v24 )
              goto LABEL_36;
            v25 = (char **)&v44;
            v26 = 16;
            goto LABEL_19;
          case 117:
            v23 = *v11;
            ++v11;
            v43 = 128;
            v24 = sub_148A8(v12, 0, &v43, v20);
            if ( !v24 )
              goto LABEL_36;
            v27 = strtoul(
                    (const char *)(*(_DWORD *)v12 + *(_DWORD *)(v12 + 12) - *(_DWORD *)(v12 + 32)),
                    (char **)&v44,
                    10);
            goto LABEL_20;
          case 115:
            v30 = *v11;
            ++v11;
            sub_14E58((_DWORD *)v12, v30, 0);
            goto LABEL_22;
          case 102:
            v31 = (int)(v11 + 1);
            v32 = *v11;
            v43 = 128;
            if ( !sub_148A8(v12, 0, &v43, v20) )
            {
              result = v13;
              *v32 = 0;
              return result;
            }
            _R0 = COERCE_UNSIGNED_INT64(strtod((const char *)(*(_DWORD *)(v12 + 12)
                                                            - *(_DWORD *)(v12 + 32)
                                                            + *(_DWORD *)v12), (char **)&v44));
            __asm
            {
              VMOV            D16, R0, R1
              VCVT.F32.F64    S15, D16
              VSTR            S15, [R6]
            }
            v38 = *(_DWORD *)(v12 + 12);
            v39 = v38 - *(_DWORD *)(v12 + 32);
            if ( v44 == *(_DWORD *)v12 + v39 )
              return v13;
            v11 = (_DWORD **)v31;
            *(_DWORD *)(v12 + 12) = v38 + v44 - (*(_DWORD *)v12 + v39);
            goto LABEL_22;
          case 100:
          case 105:
            v23 = *v11;
            ++v11;
            v43 = 128;
            v24 = sub_148A8(v12, 0, &v43, v20);
            if ( !v24 )
            {
LABEL_36:
              *v23 = v24;
              return v13;
            }
            v25 = (char **)&v44;
            v26 = 10;
LABEL_19:
            v27 = strtol((const char *)(*(_DWORD *)v12 + *(_DWORD *)(v12 + 12) - *(_DWORD *)(v12 + 32)), v25, v26);
LABEL_20:
            *v23 = v27;
            v28 = *(_DWORD *)(v12 + 12);
            v29 = v28 - *(_DWORD *)(v12 + 32);
            if ( v44 == *(_DWORD *)v12 + v29 )
              return v13;
            *(_DWORD *)(v12 + 12) = v28 + v44 - (*(_DWORD *)v12 + v29);
LABEL_22:
            ++v13;
            a2 = v21;
            break;
          case 99:
            v40 = *v11;
            if ( *(_BYTE *)(v12 + 20) & 2
              || (v42 = *v11, v41 = sub_147B8(v12, *(_BYTE *)(v12 + 20) & 2, 1, (int)v40), v40 = v42, !v41) )
            {
              result = v13;
              *v40 = 0;
              return result;
            }
            ++v11;
            *v42 = *(_BYTE *)(*(_DWORD *)v12 + (*(_DWORD *)(v12 + 12))++ - *(_DWORD *)(v12 + 32));
            goto LABEL_22;
        }
      }
    }
  }
  return result;
}
// 14F00: could not find valid save-restore pair for r4
// 14F00: could not find valid save-restore pair for r5
// 14F00: could not find valid save-restore pair for r6
// 14F00: could not find valid save-restore pair for r7
// 14F00: could not find valid save-restore pair for r8
// 14F00: could not find valid save-restore pair for r9
// 14F00: could not find valid save-restore pair for r10
// 14F00: could not find valid save-restore pair for r11
// 14F00: variables would overlap: r5.4 and r5.8
// 14F00: variables would overlap: r6.4 and r5.8
// 14F00: variables would overlap: r7.4 and r7.8
// 14F00: variables would overlap: r8.4 and r7.8

//----- (00015130) --------------------------------------------------------
int __fastcall sub_15130(int a1, int a2, int a3, int a4)
{
  int varg_r1; // ST14_4@1
  int varg_r2; // [sp+18h] [bp+18h]@1
  int varg_r3; // [sp+1Ch] [bp+1Ch]@1

  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  return sub_14F00(a1, a2, (_DWORD **)&varg_r2);
}
// 15130: could not find valid save-restore pair for r7

//----- (0001515C) --------------------------------------------------------
signed int __fastcall sub_1515C(int a1)
{
  int v1; // lr@0
  int v2; // r4@1
  int v3; // r0@3
  int v5; // r3@8
  int v6; // r2@8
  int v7; // r2@9
  int v8; // r3@12
  int v9; // r0@13
  int v10; // r3@18
  int v11; // r3@20
  int v12; // r3@22
  int v13; // r3@24
  unsigned __int8 v14; // [sp+0h] [bp+0h]@9
  unsigned __int8 v15; // [sp+8h] [bp+8h]@13
  int v16; // [sp+24h] [bp+24h]@1

  v2 = a1;
  v16 = v1;
  if ( !(*(_BYTE *)(a1 + 21) & 1) )
    return 0;
  if ( *(_BYTE *)(a1 + 20) )
    return 0;
  v3 = sub_14C40(a1, 2, *(_BYTE *)(a1 + 20));
  if ( !v3 || *(_BYTE *)v3 != 47 || *(_BYTE *)(v3 + 1) != 47 )
    return 0;
  v5 = *(_DWORD *)(v2 + 12) + 2;
  v6 = *(_BYTE *)(v2 + 21) << 31;
  *(_DWORD *)(v2 + 12) = v5;
  if ( v6 < 0 )
  {
    v14 = 0;
    sub_15130(v2, (int)"%c", (int)&v14, v5);
    v7 = v14;
LABEL_10:
    if ( !*(_BYTE *)(v2 + 20) && v7 != 10 )
    {
LABEL_12:
      while ( 1 )
      {
        v8 = *(_BYTE *)(v2 + 21) << 31;
        if ( *(_BYTE *)(v2 + 21) & 1 )
          break;
        if ( sub_146D0(v2, 1, (int)&v15, v8) )
        {
          v11 = *(_DWORD *)(v2 + 12);
          v9 = *(_BYTE *)(*(_DWORD *)v2 + v11 - *(_DWORD *)(v2 + 32));
          *(_DWORD *)(v2 + 12) = v11 + 1;
LABEL_14:
          if ( *(_BYTE *)(v2 + 20) || v9 == 10 )
            return 1;
        }
        else
        {
          v10 = *(_BYTE *)(v2 + 20);
          v15 = 0;
          if ( v10 )
            return 1;
        }
      }
      v15 = 0;
      sub_15130(v2, (int)"%c", (int)&v15, v8);
      v9 = v15;
      goto LABEL_14;
    }
    return 1;
  }
  if ( sub_146D0(v2, 1, v6, v5) )
  {
    v13 = *(_DWORD *)(v2 + 12);
    v7 = *(_BYTE *)(*(_DWORD *)v2 + v13 - *(_DWORD *)(v2 + 32));
    *(_DWORD *)(v2 + 12) = v13 + 1;
    goto LABEL_10;
  }
  v12 = *(_BYTE *)(v2 + 20);
  v14 = 0;
  if ( !v12 )
    goto LABEL_12;
  return 1;
}

//----- (00015250) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_15250(int a1, int a2, int a3)
{
  int v3; // r4@0
  int v4; // r5@0 OVERLAPPED
  int v6; // r7@0
  int v7; // lr@0
  int v8; // r5@1
  int v9; // r4@1
  int result; // r0@2
  int v11; // r3@6
  char v12; // r5@8
  int v13; // [sp+0h] [bp+0h]@2
  int v14; // [sp+Ch] [bp+Ch]@1
  __int64 v15; // [sp+10h] [bp+10h]@1
  int v16; // [sp+18h] [bp+18h]@1
  int v17; // [sp+1Ch] [bp+1Ch]@1

  v16 = v6;
  v17 = v7;
  v15 = *(_QWORD *)&v4;
  v8 = a2;
  v14 = v3;
  v9 = a1;
  if ( *(_BYTE *)(a1 + 21) & 1 )
  {
    LOBYTE(v13) = 0;
    sub_15130(a1, (int)"%c", (int)&v13, 0);
    LOBYTE(result) = v13;
  }
  else
  {
    result = sub_146D0(a1, 1, a3, *(_BYTE *)(a1 + 21) << 31);
    if ( result )
    {
      v11 = *(_DWORD *)(v9 + 12);
      LOBYTE(result) = *(_BYTE *)(*(_DWORD *)v9 + v11 - *(_DWORD *)(v9 + 32));
      *(_DWORD *)(v9 + 12) = v11 + 1;
      result = (char)result;
      if ( *(_BYTE *)(v8 + 4) != (char)result )
        return result;
      goto LABEL_7;
    }
  }
  result = (char)result;
  if ( *(_BYTE *)(v8 + 4) != (char)result )
    return result;
LABEL_7:
  v13 = *(_DWORD *)(v8 + 20);
  result = sub_148A8(v9, 0, &v13, v13);
  if ( result )
  {
    v12 = (**(int (__fastcall ***)(int, int, int *))v8)(
            v8,
            *(_DWORD *)(v9 + 12) - *(_DWORD *)(v9 + 32) + *(_DWORD *)v9,
            &v13);
    sub_14C74(v9, 1, v13);
    result = v12;
  }
  return result;
}
// 15250: could not find valid save-restore pair for r4
// 15250: could not find valid save-restore pair for r5
// 15250: could not find valid save-restore pair for r6
// 15250: could not find valid save-restore pair for r7
// 15250: variables would overlap: r5.4 and r5.8
// 15250: variables would overlap: r6.4 and r5.8

//----- (00015360) --------------------------------------------------------
_DWORD *__fastcall sub_15360(_DWORD *result, int a2, _BYTE *a3, int a4)
{
  int v4; // r5@1
  int v5; // r4@1
  _BYTE *v6; // r10@1
  signed int v7; // r8@1
  int v8; // r6@3
  int v9; // r9@10
  int v10; // r2@11
  char v11; // r0@12

  v4 = a2;
  v5 = (int)result;
  v6 = a3;
  v7 = a4;
  if ( *((_BYTE *)result + 21) & 1 && a2 )
  {
    v8 = *((_BYTE *)result + 20);
    if ( *((_BYTE *)result + 20) )
    {
      *a3 = 0;
    }
    else
    {
      if ( !a4 )
        v7 = 0x7FFFFFFF;
      sub_14768((int)result, *((_BYTE *)result + 21), (int)a3, *((_BYTE *)result + 21) << 31);
      result = (_DWORD *)sub_14854(v5, v8, *(_BYTE **)(v4 + 8), *(_DWORD *)(v4 + 12));
      if ( result )
      {
        v9 = v8;
        sub_14C74(v5, 1, *(_DWORD *)(v4 + 12));
        while ( 1 )
        {
          result = (_DWORD *)v5;
          if ( *(_BYTE *)(v5 + 20) )
            break;
          if ( sub_14854(v5, *(_BYTE *)(v5 + 20), *(_BYTE **)(v4 + 8), *(_DWORD *)(v4 + 12)) )
          {
            result = (_DWORD *)sub_14C74(v5, 1, *(_DWORD *)(v4 + 12));
            break;
          }
          v11 = sub_15250(v5, v4, v10);
          if ( v7 > v9 )
            v6[v9++] = v11;
        }
        if ( v7 <= v9 )
          v9 = v7 - 1;
        v6[v9] = 0;
      }
    }
  }
  else
  {
    result = sub_14E58(result, a3, a4);
  }
  return result;
}

//----- (000155C0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_155C0(int a1, int a2, _BYTE *a3, int a4, char a5)
{
  int v5; // r4@0
  int v6; // r5@0 OVERLAPPED
  int v8; // r7@0 OVERLAPPED
  int v10; // r9@0 OVERLAPPED
  int v12; // r11@0
  int v13; // lr@0
  int v14; // r8@1
  _BYTE *v15; // r6@1
  int v16; // r9@1
  int v17; // r4@1
  signed int result; // r0@5
  int v19; // r3@8
  signed int v20; // r5@12
  bool v21; // zf@16
  bool v22; // nf@16
  unsigned __int8 v23; // vf@16
  signed int v24; // r10@19
  int v25; // r0@21
  int v26; // r0@22
  int v27; // r3@24
  int v28; // r0@24
  signed int v29; // r9@28
  int v30; // r3@29
  bool v31; // zf@30
  int v32; // r3@36
  int v33; // r3@40
  int v34; // r0@40
  unsigned __int8 v35; // [sp+8h] [bp+8h]@8
  int v36; // [sp+14h] [bp+14h]@1
  __int64 v37; // [sp+18h] [bp+18h]@1
  __int64 v38; // [sp+20h] [bp+20h]@1
  __int64 v39; // [sp+28h] [bp+28h]@1
  int v40; // [sp+30h] [bp+30h]@1
  int v41; // [sp+34h] [bp+34h]@1

  v38 = *(_QWORD *)&v8;
  v14 = a4;
  v37 = *(_QWORD *)&v6;
  v15 = a3;
  v39 = *(_QWORD *)&v10;
  v16 = a2;
  v36 = v5;
  v17 = a1;
  v40 = v12;
  v41 = v13;
  *a3 = 0;
  do
  {
    if ( *(_BYTE *)(v17 + 20) )
      return -1;
    sub_14768(v17, a2, (int)a3, *(_BYTE *)(v17 + 20));
  }
  while ( a5 && sub_1515C(v17) );
  if ( *(_BYTE *)(v17 + 21) & 1 )
  {
    v35 = 0;
    sub_15130(v17, (int)"%c", (int)&v35, 0);
    v19 = v35;
  }
  else
  {
    if ( !sub_146D0(v17, 1, *(_BYTE *)(v17 + 21) << 31, *(_BYTE *)(v17 + 21)) )
      return -1;
    v27 = *(_DWORD *)(v17 + 12);
    v28 = v27 + 1;
    v19 = *(_BYTE *)(*(_DWORD *)v17 + v27 - *(_DWORD *)(v17 + 32));
    *(_DWORD *)(v17 + 12) = v28;
  }
  if ( !v19 )
    return -1;
  if ( (char)v19 == 34 )
  {
    v29 = 0;
    do
    {
      v32 = *(_BYTE *)(v17 + 20);
      if ( *(_BYTE *)(v17 + 20) )
        goto LABEL_39;
      if ( *(_BYTE *)(v17 + 21) & 1 )
      {
        v35 = *(_BYTE *)(v17 + 20);
        sub_15130(v17, (int)"%c", (int)&v35, v32);
        v30 = v35;
      }
      else
      {
        if ( !sub_146D0(v17, 1, (int)&v35, v32) )
          goto LABEL_39;
        v33 = *(_DWORD *)(v17 + 12);
        v34 = v33 + 1;
        v30 = *(_BYTE *)(*(_DWORD *)v17 + v33 - *(_DWORD *)(v17 + 32));
        *(_DWORD *)(v17 + 12) = v34;
      }
      v31 = v30 == 34;
      if ( v30 != 34 )
        v31 = v30 == 0;
      if ( v31 )
      {
LABEL_39:
        result = v29;
        v15[v29] = 0;
        return result;
      }
      v15[v29++] = v30;
    }
    while ( v29 != v14 );
    result = v29;
    v15[v29 - 1] = 0;
  }
  else if ( *(_BYTE *)(v16 + (unsigned __int8)v19) )
  {
    *v15 = v19;
    result = 1;
    v15[1] = 0;
  }
  else
  {
    v20 = 1;
    while ( 1 )
    {
      v15[v20 - 1] = v19;
      v24 = v20;
      if ( v20 == v14 )
        break;
      if ( *(_BYTE *)(v17 + 21) & 1 )
      {
        v35 = 0;
        sub_15130(v17, (int)"%c", (int)&v35, 0);
        LOBYTE(v19) = v35;
      }
      else
      {
        v25 = sub_146D0(v17, 1, (int)&v35, *(_BYTE *)(v17 + 21) << 31);
        LOBYTE(v19) = v25;
        if ( v25 )
        {
          v19 = *(_DWORD *)(v17 + 12);
          v26 = v19 + 1;
          LOBYTE(v19) = *(_BYTE *)(*(_DWORD *)v17 + v19 - *(_DWORD *)(v17 + 32));
          *(_DWORD *)(v17 + 12) = v26;
        }
      }
      ++v20;
      if ( *(_BYTE *)(v17 + 20) )
        goto LABEL_26;
      if ( !*(_BYTE *)(v16 + (unsigned __int8)v19) )
      {
        v23 = __OFSUB__((char)v19, 34);
        v21 = (char)v19 == 34;
        v22 = (char)v19 - 34 < 0;
        if ( (char)v19 != 34 )
        {
          v23 = __OFSUB__((char)v19, 32);
          v21 = (char)v19 == 32;
          v22 = (char)v19 - 32 < 0;
        }
        if ( !((unsigned __int8)(v22 ^ v23) | v21) )
          continue;
      }
      sub_14C74(v17, 1, -1);
LABEL_26:
      result = v24;
      v15[v24] = 0;
      return result;
    }
    result = v20;
    v15[v20 - 1] = 0;
  }
  return result;
}
// 155C0: could not find valid save-restore pair for r4
// 155C0: could not find valid save-restore pair for r5
// 155C0: could not find valid save-restore pair for r6
// 155C0: could not find valid save-restore pair for r7
// 155C0: could not find valid save-restore pair for r8
// 155C0: could not find valid save-restore pair for r9
// 155C0: could not find valid save-restore pair for r10
// 155C0: could not find valid save-restore pair for r11
// 155C0: variables would overlap: r5.4 and r5.8
// 155C0: variables would overlap: r6.4 and r5.8
// 155C0: variables would overlap: r7.4 and r7.8
// 155C0: variables would overlap: r8.4 and r7.8
// 155C0: variables would overlap: r9.4 and r9.8
// 155C0: variables would overlap: r10.4 and r9.8

//----- (00015784) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_15784(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int result; // r0@1
  int v8; // r2@5
  int v9; // r3@5
  int v10; // [sp+0h] [bp+0h]@1
  int *v11; // [sp+8h] [bp+8h]@1
  int v12; // [sp+Ch] [bp+Ch]@1

  v11 = &v10;
  v12 = v5;
  *(_QWORD *)&v10 = *(_QWORD *)&a4;
  v6 = a1;
  result = *(_BYTE *)(a1 + 20) & 1;
  if ( result )
  {
    result = 0;
  }
  else if ( !(*(_BYTE *)(v6 + 21) & 8) )
  {
    v8 = *(_DWORD *)(v6 + 16);
    v9 = *(_DWORD *)(v6 + 32);
    if ( v8 < v9 || (v9 = v8 - v9 + a2, *(_DWORD *)(v6 + 4) < v9) )
    {
      result = sub_14678(v6, a2, v8, v9);
      if ( !result )
        *(_BYTE *)(v6 + 20) |= 1u;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 15784: could not find valid save-restore pair for r4
// 15784: could not find valid save-restore pair for r7
// 15784: variables would overlap: r3.4 and r3.8
// 15784: variables would overlap: r4.4 and r3.8

//----- (000157D0) --------------------------------------------------------
int __fastcall sub_157D0(int result, int a2, int a3)
{
  __int64 v3; // r4@0
  int v4; // lr@0
  int v5; // r4@1
  int v6; // r3@2
  int v7; // r3@3
  int v8; // r2@6
  char v9; // r2@8
  int v10; // [sp+0h] [bp+0h]@1
  int *v11; // [sp+8h] [bp+8h]@1
  int v12; // [sp+Ch] [bp+Ch]@1

  v11 = &v10;
  v12 = v4;
  *(_QWORD *)&v10 = v3;
  v5 = result;
  if ( *(_BYTE *)(result + 21) & 8 )
    goto LABEL_3;
  v6 = *(_BYTE *)(result + 20);
  if ( v6 & 1 )
    goto LABEL_3;
  result = sub_15784(result, 1, a3, v6);
  if ( result )
  {
    v7 = *(_DWORD *)(v5 + 16);
    v8 = v7 - *(_DWORD *)(v5 + 32);
    if ( v8 < 0 )
      goto LABEL_4;
    *(_BYTE *)(*(_DWORD *)v5 + v8) = 0;
LABEL_3:
    v7 = *(_DWORD *)(v5 + 16);
LABEL_4:
    *(_DWORD *)(v5 + 28) = v7;
    return result;
  }
  v9 = *(_BYTE *)(v5 + 20) & 0xFE;
  *(_DWORD *)(v5 + 28) = *(_DWORD *)(v5 + 16);
  *(_BYTE *)(v5 + 20) = v9;
  return result;
}
// 157D0: could not find valid save-restore pair for r4
// 157D0: could not find valid save-restore pair for r5
// 157D0: could not find valid save-restore pair for r7

//----- (00015818) --------------------------------------------------------
char *__fastcall sub_15818(char *result, const void *a2, int a3, int a4)
{
  const void *v4; // r6@1
  int v5; // r5@1
  size_t v6; // r4@1
  int v7; // r1@5
  int v8; // r2@5
  int v9; // r3@5
  int v10; // r4@5

  v4 = a2;
  v5 = (int)result;
  v6 = a3;
  if ( a3 )
  {
    result = (char *)sub_15784((int)result, a3, a3, a4);
    if ( result )
    {
      result = (char *)(*(_DWORD *)(v5 + 16) - *(_DWORD *)(v5 + 32));
      if ( (signed int)result >= 0 )
      {
        result = (char *)memcpy(&result[*(_DWORD *)v5], v4, v6);
        v8 = *(_DWORD *)(v5 + 16);
        v9 = *(_DWORD *)(v5 + 28);
        v10 = v6 + v8;
        *(_DWORD *)(v5 + 16) = v10;
        if ( v10 > v9 )
          result = (char *)sub_157D0(v5, v7, v8);
      }
    }
  }
  return result;
}
// 15818: could not find valid save-restore pair for r4

//----- (00015870) --------------------------------------------------------
char *__fastcall sub_15870(char *result, const char *a2, int a3, int a4)
{
  const char *v4; // r8@1
  int v5; // r4@1
  int v6; // r3@1
  int v7; // r2@3
  const char *v8; // r1@3
  char *v9; // r0@3
  int v10; // r5@7
  int v11; // r3@8
  int v12; // r3@9
  char *i; // r5@9
  const char *v14; // r6@10
  int v15; // r2@10
  int v16; // r3@11
  signed int v17; // r5@12
  int v18; // r0@14
  int v19; // r1@16
  int v20; // r2@22
  int v21; // r3@22
  unsigned __int8 v22; // cf@23
  int v23; // r1@26
  int v24; // r1@29
  int v25; // r2@29
  int v26; // r3@29
  int v27; // [sp+0h] [bp+0h]@1

  v4 = a2;
  v27 = a4;
  v5 = (int)result;
  v6 = (unsigned __int8)result[21];
  if ( v6 & 1 )
  {
    if ( a2 )
    {
      if ( !(v6 & 0x10) )
      {
        v10 = *((_DWORD *)result + 6);
        if ( v10 > 0 )
        {
          v11 = *((_DWORD *)result + 4);
          if ( v11 )
          {
            v20 = *(_DWORD *)result;
            v21 = *(_BYTE *)(*(_DWORD *)result + v11 - 1 - *((_DWORD *)result + 8));
            if ( v21 == 10 )
            {
              while ( 1 )
              {
                v22 = __CFADD__(v10--, -1);
                if ( !v22 )
                  break;
                if ( sub_15784(v5, 1, v20, v21) )
                {
                  v23 = *(_DWORD *)(v5 + 16);
                  *(_BYTE *)(*(_DWORD *)v5 + v23 - *(_DWORD *)(v5 + 32)) = 9;
                  v20 = *(_DWORD *)(v5 + 28);
                  v21 = *(_DWORD *)(v5 + 16) + 1;
                  *(_DWORD *)(v5 + 16) = v21;
                  if ( v21 > v20 )
                    sub_157D0(v5, v23, v20);
                }
              }
            }
          }
          for ( i = strchr(v4, 10); i; i = strchr(v14, 10) )
          {
            v14 = i + 1;
            sub_15818((char *)v5, v4, i + 1 - v4, v12);
            v4 = i + 1;
            if ( !i[1] )
              break;
            v16 = *(_BYTE *)(v5 + 21) << 27;
            v17 = *(_BYTE *)(v5 + 21) & 0x10 ? 0 : *(_DWORD *)(v5 + 24);
            while ( 1 )
            {
              --v17;
              v18 = v5;
              if ( v17 < 0 )
                break;
              while ( sub_15784(v18, 1, v15, v16) )
              {
                v19 = *(_DWORD *)(v5 + 16);
                *(_BYTE *)(*(_DWORD *)v5 + v19 - *(_DWORD *)(v5 + 32)) = 9;
                v15 = *(_DWORD *)(v5 + 28);
                v16 = *(_DWORD *)(v5 + 16) + 1;
                *(_DWORD *)(v5 + 16) = v16;
                if ( v16 <= v15 )
                  break;
                sub_157D0(v5, v19, v15);
                --v17;
                v18 = v5;
                if ( v17 < 0 )
                  goto LABEL_18;
              }
            }
LABEL_18:
            ;
          }
        }
      }
      result = (char *)strlen(v4);
      v7 = (int)result;
      if ( result )
      {
        v9 = (char *)v5;
        v8 = v4;
        return sub_15818(v9, v8, v7, v27);
      }
    }
  }
  else
  {
    if ( a2 )
    {
      v7 = strlen(a2) + 1;
      v8 = v4;
      v9 = (char *)v5;
      return sub_15818(v9, v8, v7, v27);
    }
    result = (char *)sub_15784((int)result, 1, a3, v6);
    if ( result )
    {
      v24 = *(_DWORD *)(v5 + 16);
      *(_BYTE *)(*(_DWORD *)v5 + v24 - *(_DWORD *)(v5 + 32)) = 0;
      v25 = *(_DWORD *)(v5 + 28);
      v26 = *(_DWORD *)(v5 + 16) + 1;
      *(_DWORD *)(v5 + 16) = v26;
      if ( v26 > v25 )
        result = (char *)sub_157D0(v5, v24, v25);
    }
  }
  return result;
}
// 15870: could not find valid save-restore pair for r4

//----- (000159D8) --------------------------------------------------------
char *__fastcall sub_159D8(char *a1, const char *a2, void *a3)
{
  int v3; // lr@0
  char *v4; // r5@1
  int v5; // r2@1
  int v6; // r3@1
  int v8; // [sp+0h] [bp+0h]@1
  int v9; // [sp+80Ch] [bp+80Ch]@1

  v9 = v3;
  v4 = a1;
  sub_12498((char *)&v8, 0x800u, a2, a3);
  return sub_15870(v4, (const char *)&v8, v5, v6);
}

//----- (00015A10) --------------------------------------------------------
char *__fastcall sub_15A10(char *a1, const char *a2, int a3, int a4)
{
  const char *varg_r1; // ST14_4@1
  int varg_r2; // [sp+18h] [bp+18h]@1
  int varg_r3; // [sp+1Ch] [bp+1Ch]@1

  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  return sub_159D8(a1, a2, &varg_r2);
}
// 15A10: could not find valid save-restore pair for r7

//----- (00015EE8) --------------------------------------------------------
int __fastcall sub_15EE8(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r5@1
  int v5; // r3@1
  int result; // r0@6
  int v7; // r1@6
  int v8; // r2@6
  int v9; // r3@6

  v3 = a3;
  v4 = a1;
  v5 = *(_DWORD *)(a1 + 16);
  if ( a2 == 1 )
  {
    v3 = a3 + v5;
  }
  else if ( a2 == 2 )
  {
    v5 = *(_DWORD *)(a1 + 28);
    v3 = v5 - a3;
  }
  else if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 16);
  }
  result = sub_14678(a1, ~v3, a3, v5);
  v9 = *(_DWORD *)(v4 + 28);
  *(_DWORD *)(v4 + 16) = v3;
  if ( v3 > v9 )
    result = sub_157D0(v4, v7, v8);
  return result;
}

//----- (00015F8C) --------------------------------------------------------
int __fastcall sub_15F8C(int result, int a2)
{
  int v2; // r2@1
  int v3; // r3@1
  int *v4; // [sp+0h] [bp+0h]@1

  v2 = *(_DWORD *)(result + 16);
  v3 = *(_DWORD *)(result + 28);
  v4 = (int *)&v4;
  if ( v2 > v3 )
    result = sub_157D0(result, a2, v2);
  return result;
}

//----- (0001602C) --------------------------------------------------------
signed int __fastcall sub_1602C(int a1, int a2, int a3)
{
  int *v3; // r6@1
  int v4; // r4@1
  int *v5; // r5@1
  signed int result; // r0@2
  int v7; // r0@3
  int v8; // r8@4
  int v9; // r0@4
  int v10; // r4@4

  v3 = (int *)a2;
  v4 = a1;
  v5 = (int *)a3;
  if ( *(_BYTE *)(a1 + 20) || (v7 = sub_14A64(a1, a2, a3, *(_BYTE *)(a1 + 20)), v7 <= 1) )
  {
    sub_14C74(v4, 2, 0);
    result = 0;
  }
  else
  {
    v8 = v7 - 1;
    v9 = v4;
    v10 = *(_DWORD *)v4 + *(_DWORD *)(v4 + 12) - *(_DWORD *)(v4 + 32);
    sub_14C74(v9, 1, v8);
    if ( v3 )
      *v3 = v10;
    if ( v5 )
    {
      *v5 = v8;
      result = 1;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 1602C: could not find valid save-restore pair for r4
// 1602C: could not find valid save-restore pair for r5
// 1602C: could not find valid save-restore pair for r6
// 1602C: could not find valid save-restore pair for r7

//----- (000160E4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_160E4(int a1, int a2, int a3, int a4)
{
  __int64 v5; // r5@0
  int v6; // lr@0
  int v7; // r4@1
  char v8; // r12@1
  int result; // r0@4
  __int64 v10; // [sp+0h] [bp+0h]@1
  __int64 v11; // [sp+8h] [bp+8h]@1
  __int64 *v12; // [sp+10h] [bp+10h]@1
  int v13; // [sp+14h] [bp+14h]@1

  v11 = v5;
  v10 = *(_QWORD *)&a4;
  v7 = a1;
  v12 = &v10;
  v13 = v6;
  v8 = *(_BYTE *)(a1 + 52);
  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 21) = a4;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 52) = v8 & 0xFC;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 8) = -1;
  if ( (unsigned __int8)a4 << 28 >= 0 )
  {
    *(_DWORD *)(a1 + 28) = -1;
    sub_157D0(a1, v8 & 0xFC, a3);
  }
  else
  {
    *(_DWORD *)(a1 + 28) = a3;
  }
  result = v7;
  *(_DWORD *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 48) = 0;
  *(_DWORD *)(v7 + 36) = sub_142AC;
  *(_DWORD *)(v7 + 44) = sub_14354;
  return result;
}
// 160E4: could not find valid save-restore pair for r4
// 160E4: could not find valid save-restore pair for r5
// 160E4: could not find valid save-restore pair for r6
// 160E4: could not find valid save-restore pair for r7
// 160E4: variables would overlap: r3.4 and r3.8
// 160E4: variables would overlap: r4.4 and r3.8
// 142AC: using guessed type int sub_142AC();
// 14354: using guessed type int sub_14354();

//----- (000161B8) --------------------------------------------------------
int __fastcall sub_161B8(int a1, int a2, int a3, int a4, char a5)
{
  unsigned __int64 v5; // r8@1
  int v6; // r4@1
  int v7; // r5@1
  int v8; // r1@1
  int v9; // r2@1
  int result; // r0@1

  v5 = __PAIR__(a3, a2);
  v6 = a1;
  v7 = a4;
  sub_7FBC(a1, a2, a3, a4);
  result = 0;
  *(_QWORD *)v6 = v5;
  *(_DWORD *)(v6 + 16) = v7;
  *(_BYTE *)(v6 + 21) = a5;
  *(_DWORD *)(v6 + 28) = -1;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  *(_BYTE *)(v6 + 20) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  if ( v7 >= 0 )
    result = sub_157D0(v6, v8, v9);
  return result;
}

//----- (00016580) --------------------------------------------------------
int __fastcall sub_16580(int a1, int a2, size_t a3, int a4)
{
  char v8; // r9@1
  size_t v9; // r5@1
  int v10; // r8@1
  int v11; // r4@1
  char v13; // r2@1
  int v14; // r2@1
  int result; // r0@4
  int v16; // r1@5
  int v17; // r2@5

  __asm { VMOV.I32        D16, #0 }
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  *(_DWORD *)a1 = 0;
  _LR = a1 + 4;
  __asm { VST1.32         {D16}, [LR] }
  v13 = *(_BYTE *)(a1 + 52);
  *(_BYTE *)(a1 + 20) = 0;
  v14 = v13 & 0xFC;
  *(_BYTE *)(a1 + 52) = v14;
  sub_7FBC(a1, a2, v14, a4);
  *(_DWORD *)(v11 + 8) = v10;
  *(_DWORD *)(v11 + 4) = v9;
  if ( v9 )
  {
    *(_DWORD *)v11 = malloc(v9);
    *(_DWORD *)(v11 + 12) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    *(_BYTE *)(v11 + 21) = v8;
    *(_DWORD *)(v11 + 24) = 0;
    *(_DWORD *)(v11 + 32) = 0;
    if ( !(v8 & 8) )
    {
      *(_DWORD *)(v11 + 28) = -1;
      sub_157D0(v11, v16, v17);
      goto LABEL_4;
    }
  }
  else
  {
    *(_DWORD *)(v11 + 12) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    *(_DWORD *)(v11 + 24) = 0;
    *(_DWORD *)(v11 + 32) = 0;
    *(_BYTE *)(v11 + 21) = v8;
  }
  *(_DWORD *)(v11 + 28) = 0;
LABEL_4:
  result = v11;
  *(_DWORD *)(v11 + 40) = 0;
  *(_DWORD *)(v11 + 48) = 0;
  *(_DWORD *)(v11 + 36) = sub_142AC;
  *(_DWORD *)(v11 + 44) = sub_14354;
  return result;
}
// 16580: could not find valid save-restore pair for r4
// 16580: could not find valid save-restore pair for r5
// 16580: could not find valid save-restore pair for r6
// 16580: could not find valid save-restore pair for r7
// 16580: could not find valid save-restore pair for r8
// 142AC: using guessed type int sub_142AC();
// 14354: using guessed type int sub_14354();

//----- (00016648) --------------------------------------------------------
int __fastcall sub_16648(int a1, int a2, _DWORD *a3)
{
  int result; // r0@1

  result = 0;
  *a3 = 0;
  return result;
}

//----- (000166D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_166D0(void *result, signed int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  void *v8; // r6@1
  int v9; // r5@1
  int i; // r4@1
  signed int v11; // r3@3
  void *v12; // r0@8
  int v13; // [sp+0h] [bp+0h]@1
  __int64 v14; // [sp+8h] [bp+8h]@1
  int *v15; // [sp+10h] [bp+10h]@1
  int v16; // [sp+14h] [bp+14h]@1

  v14 = *(_QWORD *)&v5;
  v8 = result;
  v9 = a2;
  v15 = &v13;
  v16 = v7;
  *(_QWORD *)&v13 = *(_QWORD *)&a4;
  i = *((_DWORD *)result + 1);
  *((_DWORD *)result + 3) = a2;
  if ( a2 > i )
  {
    v11 = *((_DWORD *)result + 2);
    if ( v11 < 0 )
      goto LABEL_18;
    if ( v11 )
    {
      for ( i = v11 + (a2 - 1) / v11 * v11; a2 > i; i = (i + a2) / 2 )
        ;
    }
    else if ( i || (i = 32, a2 > 32) )
    {
      do
        i *= 2;
      while ( a2 > i );
    }
    v12 = *(void **)result;
    *((_DWORD *)v8 + 1) = i;
    if ( v12 )
    {
      result = realloc(v12, i);
      i = *((_DWORD *)v8 + 1);
      *(_DWORD *)v8 = result;
    }
    else
    {
      result = malloc(i);
      *(_DWORD *)v8 = result;
    }
    if ( v9 > i )
LABEL_18:
      *((_DWORD *)v8 + 3) = i;
  }
  return result;
}
// 166D0: could not find valid save-restore pair for r4
// 166D0: could not find valid save-restore pair for r5
// 166D0: could not find valid save-restore pair for r6
// 166D0: could not find valid save-restore pair for r7
// 166D0: variables would overlap: r3.4 and r3.8
// 166D0: variables would overlap: r4.4 and r3.8
// 166D0: variables would overlap: r5.4 and r5.8
// 166D0: variables would overlap: r6.4 and r5.8

//----- (00016744) --------------------------------------------------------
void *__fastcall sub_16744(void *a1, char *a2, int a3, int a4)
{
  char *v4; // r6@1
  signed int v5; // r5@2
  void *v6; // r4@4
  void *result; // r0@4
  size_t v8; // r2@4
  void *v9; // r0@5

  v4 = a2;
  if ( a2 )
    v5 = a3;
  else
    v5 = 0;
  v6 = a1;
  result = sub_166D0(a1, v5, a3, a4);
  v8 = *((_DWORD *)v6 + 3);
  if ( v8 )
  {
    v9 = *(void **)v6;
    if ( *(_DWORD *)v6 >= (unsigned int)&v4[v5] || v4 >= (char *)v9 + v8 )
      result = j_memcpy(v9, v4, v8);
    else
      result = j_memmove(v9, v4, v8);
  }
  return result;
}
// 16744: could not find valid save-restore pair for r4

//----- (000167E4) --------------------------------------------------------
int __fastcall sub_167E4(int a1, int a2)
{
  int v2; // lr@0
  size_t v3; // r2@1
  int result; // r0@2
  _DWORD *v5; // [sp+0h] [bp+0h]@1
  int v6; // [sp+4h] [bp+4h]@1

  v5 = &v5;
  v6 = v2;
  v3 = *(_DWORD *)(a2 + 12);
  if ( v3 == *(_DWORD *)(a1 + 12) )
    result = memcmp(*(const void **)a2, *(const void **)a1, v3) == 0;
  else
    result = 0;
  return result;
}
// 167E4: could not find valid save-restore pair for r7

//----- (00016870) --------------------------------------------------------
void *__fastcall sub_16870(void *a1, const char *a2, int a3, int a4)
{
  char *v4; // r4@1
  void *v5; // r5@1
  int v6; // r2@2

  v4 = (char *)a2;
  v5 = a1;
  if ( a2 )
    v6 = strlen(a2) + 1;
  else
    v6 = 0;
  return sub_16744(v5, v4, v6, a4);
}
// 16870: could not find valid save-restore pair for r7

//----- (000168A0) --------------------------------------------------------
int __fastcall sub_168A0(int a1)
{
  int result; // r0@1
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  result = *(_DWORD *)(a1 + 12);
  if ( result )
    --result;
  return result;
}

//----- (000168CC) --------------------------------------------------------
char *__fastcall sub_168CC(int a1)
{
  char *result; // r0@2
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  if ( *(_DWORD *)(a1 + 12) )
    result = *(char **)a1;
  else
    result = "";
  return result;
}

//----- (000168F0) --------------------------------------------------------
char *__fastcall sub_168F0(int a1)
{
  char *result; // r0@2
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  if ( *(_DWORD *)(a1 + 12) )
    result = *(char **)a1;
  else
    result = "";
  return result;
}

//----- (000169D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_169D0(void *a1, const char *a2, int a3, int a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  sub_16870(a1, a2, a3, a4);
  return v6;
}
// 169D0: could not find valid save-restore pair for r4
// 169D0: could not find valid save-restore pair for r7
// 169D0: variables would overlap: r3.4 and r3.8
// 169D0: variables would overlap: r4.4 and r3.8

//----- (00016AB8) --------------------------------------------------------
int __fastcall sub_16AB8(int a1, const char *a2)
{
  const char *v2; // r8@1
  int v3; // r4@1
  int v4; // r5@1
  int v5; // r10@2
  size_t v6; // r0@3
  int v7; // r2@3
  int v8; // r3@3
  signed int v9; // r9@3
  signed int v10; // r1@4
  int v11; // r2@6
  int v12; // r3@6
  int v13; // r6@6
  int v14; // r11@7
  int v15; // r5@7
  int result; // r0@9
  int v17; // r5@11

  v2 = a2;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 12);
  if ( v4 )
    v5 = --v4;
  else
    v5 = 0;
  v6 = strlen(a2);
  v9 = v6;
  if ( (signed int)(v4 + v6) <= 0 )
    v10 = 0;
  else
    v10 = v4 + v6 + 1;
  sub_166D0((void *)v3, v10, v7, v8);
  v13 = *(_DWORD *)(v3 + 12);
  if ( v13 )
  {
    v14 = v13 - 1;
    v15 = v13 - 1 - v4;
    if ( v15 < v9 )
      v9 = v15;
  }
  else
  {
    sub_166D0((void *)v3, 1, v11, v12);
    v17 = -v4;
    v14 = 0;
    if ( v17 < v9 )
      v9 = v17;
    **(_BYTE **)v3 = 0;
  }
  memcpy((void *)(*(_DWORD *)v3 + v5), v2, v9);
  result = v3;
  *(_BYTE *)(*(_DWORD *)v3 + v14) = 0;
  return result;
}
// 16AB8: could not find valid save-restore pair for r4
// 16AB8: could not find valid save-restore pair for r5
// 16AB8: could not find valid save-restore pair for r6
// 16AB8: could not find valid save-restore pair for r7
// 16AB8: could not find valid save-restore pair for r8
// 16AB8: could not find valid save-restore pair for r9
// 16AB8: could not find valid save-restore pair for r10

//----- (00016E50) --------------------------------------------------------
_DWORD *__fastcall sub_16E50(_DWORD *a1, int a2, int a3)
{
  __int64 v3; // r4@0
  int v4; // lr@0
  _DWORD *v9; // r4@1
  _DWORD *result; // r0@1
  __int64 v12; // [sp+0h] [bp+0h]@1
  __int64 *v13; // [sp+8h] [bp+8h]@1
  int v14; // [sp+Ch] [bp+Ch]@1

  __asm { VMOV.I32        D16, #0 }
  v12 = v3;
  v9 = a1;
  v13 = &v12;
  v14 = v4;
  *a1 = 0;
  _R3 = (int)(a1 + 1);
  __asm { VST1.32         {D16}, [R3] }
  sub_7FBC((int)a1, a2, a3, (int)(a1 + 1));
  v9[2] = 0;
  result = v9;
  v9[1] = 0;
  v9[3] = 0;
  return result;
}
// 16E50: could not find valid save-restore pair for r4
// 16E50: could not find valid save-restore pair for r5
// 16E50: could not find valid save-restore pair for r7

//----- (00016E7C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_DWORD *__fastcall sub_16E7C(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  const char *v12; // r6@1
  _DWORD *v13; // r4@1
  int v15; // r2@1
  int v16; // r3@1
  __int64 v18; // [sp+0h] [bp+0h]@1
  __int64 v19; // [sp+8h] [bp+8h]@1
  __int64 *v20; // [sp+10h] [bp+10h]@1
  int v21; // [sp+14h] [bp+14h]@1

  __asm { VMOV.I32        D16, #0 }
  v19 = *(_QWORD *)&v5;
  v12 = (const char *)a2;
  v18 = *(_QWORD *)&a4;
  v13 = a1;
  v20 = &v18;
  v21 = v7;
  *a1 = 0;
  _R3 = (int)(a1 + 1);
  __asm { VST1.32         {D16}, [R3] }
  sub_7FBC((int)a1, a2, a3, (int)(a1 + 1));
  *(_QWORD *)(v13 + 1) = 0LL;
  v13[3] = 0;
  sub_16870(v13, v12, v15, v16);
  return v13;
}
// 16E7C: could not find valid save-restore pair for r4
// 16E7C: could not find valid save-restore pair for r5
// 16E7C: could not find valid save-restore pair for r6
// 16E7C: could not find valid save-restore pair for r7
// 16E7C: variables would overlap: r3.4 and r3.8
// 16E7C: variables would overlap: r4.4 and r3.8
// 16E7C: variables would overlap: r5.4 and r5.8
// 16E7C: variables would overlap: r6.4 and r5.8

//----- (00016FA0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_DWORD *__fastcall sub_16FA0(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v12; // r6@1
  _DWORD *v13; // r4@1
  int v15; // r2@1
  int v16; // r3@1
  const char *v17; // r1@1
  __int64 v19; // [sp+0h] [bp+0h]@1
  __int64 v20; // [sp+8h] [bp+8h]@1
  __int64 *v21; // [sp+10h] [bp+10h]@1
  int v22; // [sp+14h] [bp+14h]@1

  __asm { VMOV.I32        D16, #0 }
  v20 = *(_QWORD *)&v5;
  v12 = a2;
  v19 = *(_QWORD *)&a4;
  v13 = a1;
  v21 = &v19;
  v22 = v7;
  *a1 = 0;
  _R3 = (int)(a1 + 1);
  __asm { VST1.32         {D16}, [R3] }
  sub_7FBC((int)a1, a2, a3, (int)(a1 + 1));
  v13[2] = 0;
  v13[1] = 0;
  v13[3] = 0;
  v16 = *(_DWORD *)(v12 + 12);
  v17 = "";
  if ( v16 )
    v17 = *(const char **)v12;
  sub_16870(v13, v17, v15, v16);
  return v13;
}
// 16FA0: could not find valid save-restore pair for r4
// 16FA0: could not find valid save-restore pair for r5
// 16FA0: could not find valid save-restore pair for r6
// 16FA0: could not find valid save-restore pair for r7
// 16FA0: variables would overlap: r3.4 and r3.8
// 16FA0: variables would overlap: r4.4 and r3.8
// 16FA0: variables would overlap: r5.4 and r5.8
// 16FA0: variables would overlap: r6.4 and r5.8

//----- (00016FE8) --------------------------------------------------------
_DWORD *__fastcall sub_16FE8(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // lr@0
  _DWORD *v5; // r5@1
  int v7; // r0@1
  int v8; // r2@1
  int v9; // r8@3
  int v10; // r9@9
  char *v11; // r10@9
  signed int v12; // r0@10
  signed int v13; // r4@10
  size_t v18; // r9@19
  int v19; // r2@19
  int v20; // r3@19
  int v21; // r2@19
  int v22; // r3@19
  int v23; // r1@19
  int v24; // r2@19
  int v25; // r3@19
  signed int v27; // r3@22
  signed int v28; // r0@22
  void *dest; // [sp+0h] [bp+0h]@19
  int v30; // [sp+4h] [bp+4h]@19
  int v31; // [sp+8h] [bp+8h]@19
  int v32; // [sp+Ch] [bp+Ch]@19
  int v33; // [sp+2Ch] [bp+2Ch]@1

  v5 = a1;
  v7 = a3;
  _NF = a3 < 0;
  v33 = v4;
  v8 = *(_DWORD *)(a2 + 12);
  if ( !_NF )
  {
    if ( !v8 )
    {
      v9 = 0;
      if ( a4 == 0x7FFFFFFF )
      {
        v10 = *(_DWORD *)(a2 + 12);
        goto LABEL_25;
      }
LABEL_6:
      if ( a4 >= 0 )
      {
        if ( !v8 )
          goto LABEL_8;
        v10 = v8 - 1;
        if ( a4 < v8 - 1 )
          v10 = a4;
        goto LABEL_17;
      }
      v27 = -a4;
      v28 = *(_DWORD *)(a2 + 12);
      if ( v8 )
        v28 = v8 - 1;
      a4 = v27 - v28 * (v27 / v28);
      v10 = v28 - a4;
LABEL_25:
      if ( v9 >= v10 )
        goto LABEL_21;
      v11 = "";
      if ( !v8 )
        goto LABEL_19;
      goto LABEL_18;
    }
    v9 = v8 - 1;
    if ( v7 < v8 - 1 )
      v9 = v7;
    if ( a4 != 0x7FFFFFFF )
      goto LABEL_6;
LABEL_14:
    v10 = v8 - 1;
LABEL_17:
    if ( v9 >= v10 )
      goto LABEL_21;
LABEL_18:
    v11 = *(char **)a2;
    goto LABEL_19;
  }
  v12 = -v7;
  v13 = *(_DWORD *)(a2 + 12);
  if ( v8 )
    v13 = v8 - 1;
  v9 = v13 - (v12 - v13 * (v12 / v13));
  if ( a4 != 0x7FFFFFFF )
    goto LABEL_6;
  if ( v8 )
    goto LABEL_14;
LABEL_8:
  if ( v9 >= 0 )
  {
LABEL_21:
    sub_16E7C(v5, (int)"", v8, a4);
    return v5;
  }
  v10 = 0;
  v11 = "";
LABEL_19:
  __asm { VMOV.I32        D16, #0 }
  _R3 = &v30;
  v18 = v10 - v9;
  dest = 0;
  __asm { VST1.32         {D16}, [R3] }
  sub_7FBC((int)&dest, a2, v8, (int)&v30);
  v31 = 0;
  v30 = 0;
  v32 = 0;
  sub_166D0(&dest, v18 + 1, v19, v20);
  *((_BYTE *)memcpy(dest, &v11[v9], v18) + v18) = 0;
  sub_16FA0(v5, (int)&dest, v21, v22);
  sub_7FBC((int)&dest, v23, v24, v25);
  return v5;
}

//----- (000171E8) --------------------------------------------------------
int __fastcall sub_171E8(int a1)
{
  int v1; // r3@1
  int v2; // r4@1
  int v3; // r2@2
  int v4; // r3@2
  int v5; // r4@2
  int result; // r0@2
  int v7; // r2@4
  int v8; // r0@5
  int v9; // r6@5

  v1 = *(_BYTE *)a1 + 1;
  v2 = *(_WORD *)(toupper_tab_ + 2 * v1);
  if ( *(_WORD *)(toupper_tab_ + 2 * v1) )
  {
    v3 = *(_WORD *)(toupper_tab_ + 2 * (*(_BYTE *)(a1 + 1) + 1));
    v4 = a1 + 4;
    v5 = *(_DWORD *)&aU_0[4 * v2];
    result = v5 << 8;
    if ( v3 )
    {
      do
      {
        v8 = *(_DWORD *)&aU_0[4 * (v3 ^ v5)];
        v9 = *(_WORD *)(toupper_tab_ + 2 * (*(_BYTE *)(v4 - 2) + 1)) ^ v8;
        if ( !*(_WORD *)(toupper_tab_ + 2 * (*(_BYTE *)(v4 - 2) + 1)) )
          break;
        v7 = *(_BYTE *)(v4 - 1);
        v4 += 2;
        v5 = *(_DWORD *)&aU_0[4 * v9];
        v3 = *(_WORD *)(toupper_tab_ + 2 * (v7 + 1));
      }
      while ( v3 );
      result = v8 | (v5 << 8);
    }
  }
  else
  {
    result = *(_WORD *)(toupper_tab_ + 2 * v1);
  }
  return result;
}

//----- (00017618) --------------------------------------------------------
unsigned int __fastcall sub_17618(int a1, int a2, int a3)
{
  unsigned int v3; // r5@1
  int *v4; // r6@2
  signed int v5; // r4@2
  int v6; // t1@3
  unsigned int v7; // r1@4
  int v8; // r2@4

  v3 = a2 ^ a3;
  if ( a2 > 3 )
  {
    v4 = (int *)a1;
    v5 = a2;
    do
    {
      v6 = *v4;
      ++v4;
      v5 -= 4;
      v3 = 1540483477 * (1540483477 * v6 ^ ((unsigned int)(1540483477 * v6) >> 24)) ^ 1540483477 * v3;
    }
    while ( v5 > 3 );
    v7 = a2 - 4;
    v8 = (v7 >> 2) + 1;
    a2 = v7 - 4 * (v7 >> 2);
    a1 += 4 * v8;
  }
  if ( a2 == 2 )
    goto LABEL_10;
  if ( a2 == 3 )
  {
    v3 ^= *(_BYTE *)(a1 + 2) << 16;
LABEL_10:
    v3 ^= *(_BYTE *)(a1 + 1) << 8;
    goto LABEL_11;
  }
  if ( a2 == 1 )
LABEL_11:
    v3 = 1540483477 * (v3 ^ *(_BYTE *)a1);
  return 1540483477 * (v3 ^ (v3 >> 13)) ^ (1540483477 * (v3 ^ (v3 >> 13)) >> 15);
}

//----- (000178A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int *__fastcall sub_178A0(unsigned int a1, int a2, unsigned int a3, int (__fastcall *a4)(int, unsigned int, unsigned int), int a5)
{
  int v5; // r4@0
  int v6; // r5@0 OVERLAPPED
  int v8; // r7@0 OVERLAPPED
  int v10; // r9@0 OVERLAPPED
  int v12; // r11@0
  int v13; // lr@0
  unsigned int v14; // r6@1
  unsigned int v15; // r4@1
  int v17; // r5@1
  char *v18; // r3@3
  signed int v20; // r2@6
  int v24; // r2@10
  char *v29; // r2@12
  int v30; // lr@13
  int v31; // lr@14
  char v32; // r1@15
  unsigned int v33; // r9@16
  bool v34; // cf@17
  signed int v35; // r3@20
  int v39; // r3@24
  char *v43; // r3@27
  char *v44; // r11@27
  int v45; // r0@28
  int v46; // r0@29
  char v47; // r2@30
  bool v48; // cf@33
  signed int v49; // r3@36
  int v53; // r3@40
  char *v56; // r3@43
  char *v57; // r2@43
  int v58; // lr@44
  int v59; // lr@45
  char v60; // r1@46
  char *v61; // r3@47
  bool v62; // cf@48
  signed int v63; // r3@51
  int v66; // r3@55
  char *v70; // r2@58
  int v71; // lr@59
  int v72; // lr@60
  char v73; // r1@61
  int v74; // r5@62
  unsigned int v75; // r10@62
  int (__fastcall *v76)(int, char *, unsigned int, char *); // r4@62
  char *v77; // r9@63
  unsigned int v78; // r2@66
  bool v79; // cf@66
  signed int v81; // r2@69
  int v85; // r2@73
  char *v88; // r2@76
  int v89; // lr@78
  int v90; // lr@79
  char v91; // r3@80
  unsigned int v92; // r11@82
  unsigned int i; // r9@83
  unsigned int v94; // r10@84
  bool v95; // cf@85
  char v96; // r3@88
  int v97; // r3@91
  int v101; // r3@95
  char *v104; // r3@97
  int v105; // r0@98
  char *v106; // r2@99
  int v107; // r0@99
  char v108; // r1@100
  char *v109; // r2@106
  char *v110; // r3@106
  char v111; // r1@107
  int *result; // r0@111
  unsigned int v113; // r1@112
  char *v114; // r2@114
  unsigned int v115; // r9@117
  char *v116; // r10@117
  bool v117; // cf@117
  signed int v118; // r3@120
  int v121; // r3@124
  char *v124; // r3@127
  char *v125; // r2@127
  int v126; // r12@128
  int v127; // r12@129
  char v128; // r1@130
  unsigned int v129; // r3@132
  char *v131; // r0@136
  char *v132; // r3@136
  unsigned int v133; // r12@137
  char v134; // r2@137
  char *v135; // r2@141
  int v136; // r1@141
  char v137; // r0@142
  char *v138; // r2@145
  char v139; // r1@146
  char *v140; // r2@148
  char *v141; // r3@148
  unsigned int v142; // r12@149
  char v143; // r1@149
  char *v144; // r2@152
  char *v145; // r3@152
  char v146; // r1@153
  int v147; // [sp+0h] [bp+0h]@1
  unsigned int v148; // [sp+4h] [bp+4h]@1
  int v149; // [sp+8h] [bp+8h]@1
  int *v150; // [sp+Ch] [bp+Ch]@1
  unsigned int v151; // [sp+10h] [bp+10h]@3
  int *v152; // [sp+14h] [bp+14h]@1
  int v153; // [sp+18h] [bp+18h]@3
  char *v154; // [sp+1Ch] [bp+1Ch]@62
  unsigned int v155; // [sp+20h] [bp+20h]@1
  int v156; // [sp+24h] [bp+24h]@62
  unsigned int v157; // [sp+28h] [bp+28h]@1
  int v158; // [sp+2Ch] [bp+2Ch]@1
  unsigned int v159; // [sp+30h] [bp+30h]@1
  int (__fastcall *v160)(int, unsigned int, unsigned int); // [sp+34h] [bp+34h]@1
  double v161; // [sp+38h] [bp+38h]@133
  int v162; // [sp+40h] [bp+40h]@1
  int v163; // [sp+E4h] [bp+E4h]@1
  __int64 v164; // [sp+E8h] [bp+E8h]@1
  __int64 v165; // [sp+F0h] [bp+F0h]@1
  __int64 v166; // [sp+F8h] [bp+F8h]@1
  int v167; // [sp+100h] [bp+100h]@1
  int v168; // [sp+104h] [bp+104h]@1

  v165 = *(_QWORD *)&v8;
  v164 = *(_QWORD *)&v6;
  v14 = a1;
  v163 = v5;
  v15 = a3;
  v167 = v12;
  v168 = v13;
  v166 = *(_QWORD *)&v10;
  _R7 = &v147;
  v159 = a3 >> 4;
  v160 = a4;
  v155 = a1 + a2 * a3;
  v148 = 7 * a3;
  v17 = 16 * (a3 >> 4);
  v150 = &v162;
  v158 = a3 - 16 * (a3 >> 4);
  v157 = a1 + a3;
  v149 = -a3;
  v152 = &v162;
  while ( 2 )
  {
    while ( v148 < v155 - v14 )
    {
      v151 = v14 + 16;
      v18 = (char *)(v14 + v15 * ((v155 - v14) / v15 >> 1));
      v153 = v15 > 0xF;
      _CF = (unsigned int)v18 >= v14 + 16;
      if ( (unsigned int)v18 < v14 + 16 )
        _CF = v14 >= (unsigned int)(v18 + 16);
      v20 = _CF != 0;
      if ( v153 & v20 )
      {
        if ( !v17 )
        {
          v30 = v15;
          v29 = (char *)v14;
LABEL_14:
          v31 = (int)&v18[v30];
          do
          {
            v32 = *v18;
            *v18++ = *v29;
            *v29++ = v32;
          }
          while ( v18 != (char *)v31 );
          goto LABEL_16;
        }
        _LR = v14 + v15 * ((v155 - v14) / v15 >> 1);
        _R1 = v14;
        _R0 = v14 + v15 * ((v155 - v14) / v15 >> 1);
        v24 = 0;
        do
        {
          __asm { VLD1.8          {D16-D17}, [LR]! }
          ++v24;
          __asm
          {
            VLD1.8          {D18-D19}, [R1]
            VST1.8          {D18-D19}, [R0]!
            VST1.8          {D16-D17}, [R1]!
          }
        }
        while ( !_ZF && _CF );
        v18 += v17;
        v29 = (char *)(v14 + v17);
        if ( v15 != v17 )
        {
          v30 = v158;
          goto LABEL_14;
        }
      }
      else
      {
        v135 = (char *)v14;
        v136 = (int)&v18[v15];
        do
        {
          v137 = *v18;
          *v18++ = *v135;
          *v135++ = v137;
        }
        while ( v18 != (char *)v136 );
      }
LABEL_16:
      v33 = v155 + v149;
      if ( v160(a5, v157, v155 + v149) <= 0 )
        goto LABEL_31;
      v34 = v33 >= v157 + 16;
      if ( v33 < v157 + 16 )
        v34 = v157 >= v33 + 16;
      v35 = v34 != 0;
      if ( v153 & v35 )
      {
        if ( !v17 )
        {
          v45 = v15;
          v43 = (char *)v33;
          v44 = (char *)v157;
LABEL_29:
          v46 = (int)&v44[v45];
          do
          {
            v47 = *v44;
            *v44++ = *v43;
            *v43++ = v47;
          }
          while ( v44 != (char *)v46 );
LABEL_31:
          v44 = (char *)(v157 + v15);
          goto LABEL_32;
        }
        _LR = v157;
        _R0 = v33;
        _R1 = v33;
        v39 = 0;
        _R2 = v157;
        do
        {
          __asm { VLD1.8          {D16-D17}, [LR]! }
          ++v39;
          __asm
          {
            VLD1.8          {D18-D19}, [R0]!
            VST1.8          {D18-D19}, [R2]!
            VST1.8          {D16-D17}, [R1]!
          }
        }
        while ( !_CF );
        v43 = (char *)(v33 + v17);
        v44 = (char *)(v157 + v17);
        if ( v15 != v17 )
        {
          v45 = v158;
          goto LABEL_29;
        }
      }
      else
      {
        v144 = (char *)v33;
        v145 = (char *)v157;
        v44 = (char *)(v157 + v15);
        do
        {
          v146 = *v145;
          *v145++ = *v144;
          *v144++ = v146;
        }
        while ( v145 != v44 );
      }
LABEL_32:
      if ( v160(a5, v14, v33) <= 0 )
        goto LABEL_47;
      v48 = v33 >= v151;
      if ( v33 < v151 )
        v48 = v14 >= v33 + 16;
      v49 = v48 != 0;
      if ( v153 & v49 )
      {
        if ( !v17 )
        {
          v58 = v15;
          v57 = (char *)v33;
          v56 = (char *)v14;
LABEL_45:
          v59 = (int)&v56[v58];
          do
          {
            v60 = *v56;
            *v56++ = *v57;
            *v57++ = v60;
          }
          while ( v56 != (char *)v59 );
          goto LABEL_47;
        }
        _R2 = v14;
        _R0 = v33;
        _R1 = v33;
        v53 = 0;
        do
        {
          __asm { VLD1.8          {D16-D17}, [R2] }
          ++v53;
          __asm
          {
            VLD1.8          {D18-D19}, [R0]!
            VST1.8          {D18-D19}, [R2]!
            VST1.8          {D16-D17}, [R1]!
          }
        }
        while ( !_CF );
        v56 = (char *)(v14 + v17);
        v57 = (char *)(v33 + v17);
        if ( v15 != v17 )
        {
          v58 = v158;
          goto LABEL_45;
        }
      }
      else
      {
        v140 = (char *)v33;
        v141 = (char *)v14;
        do
        {
          v142 = v157;
          v143 = *v141;
          *v141++ = *v140;
          *v140++ = v143;
        }
        while ( (char *)v142 != v141 );
      }
LABEL_47:
      if ( v160(a5, v157, v14) > 0 )
      {
        v62 = v157 >= v151;
        if ( v157 < v151 )
          v62 = v14 >= v157 + 16;
        v63 = v62 != 0;
        if ( !(v153 & v63) )
        {
          v61 = (char *)v157;
          v138 = (char *)v14;
          do
          {
            v139 = *v61;
            *v61++ = *v138;
            *v138++ = v139;
          }
          while ( v61 != v44 );
          goto LABEL_62;
        }
        if ( v17 )
        {
          _R0 = v157;
          _R2 = v14;
          v66 = 0;
          _R1 = v157;
          do
          {
            __asm { VLD1.8          {D16-D17}, [R0]! }
            ++v66;
            __asm
            {
              VLD1.8          {D18-D19}, [R2]
              VST1.8          {D18-D19}, [R1]!
              VST1.8          {D16-D17}, [R2]!
            }
          }
          while ( !_CF );
          v70 = (char *)(v14 + v17);
          v61 = (char *)(v157 + v17);
          if ( v15 == v17 )
            goto LABEL_62;
          v71 = v158;
        }
        else
        {
          v71 = v15;
          v70 = (char *)v14;
          v61 = (char *)v157;
        }
        v72 = (int)&v61[v71];
        do
        {
          v73 = *v61;
          *v61++ = *v70;
          *v70++ = v73;
        }
        while ( v61 != (char *)v72 );
      }
LABEL_62:
      v156 = v17;
      v74 = v149;
      v75 = v33;
      v154 = (char *)v15;
      v76 = (int (__fastcall *)(int, char *, unsigned int, char *))v160;
      while ( 1 )
      {
        v77 = v44;
        if ( v76(a5, v44, v14, v61) < 0 )
          goto LABEL_81;
        do
          v75 += v74;
        while ( ((int (__fastcall *)(int, unsigned int, unsigned int))v76)(a5, v75, v14) > 0 );
        if ( (unsigned int)v44 > v75 )
          break;
        v78 = v75 + 16;
        v79 = (unsigned int)(v44 + 16) >= v75;
        _ZF = v44 + 16 == (char *)v75;
        if ( (unsigned int)(v44 + 16) > v75 )
        {
          v79 = v78 >= (unsigned int)v44;
          _ZF = v78 == (_DWORD)v44;
        }
        if ( !_ZF && v79 )
          v81 = 0;
        else
          v81 = 1;
        if ( v153 & v81 )
        {
          if ( v156 )
          {
            _R1 = v75;
            _LR = v44;
            _R0 = v44;
            v85 = 0;
            do
            {
              __asm { VLD1.8          {D16-D17}, [R0]! }
              ++v85;
              __asm
              {
                VLD1.8          {D18-D19}, [R1]
                VST1.8          {D18-D19}, [LR]!
                VST1.8          {D16-D17}, [R1]!
              }
            }
            while ( !_CF );
            v61 = (char *)v156;
            v77 = &v44[v156];
            v88 = (char *)(v156 + v75);
            if ( v154 != (char *)v156 )
            {
              v89 = v158;
              goto LABEL_79;
            }
            v44 += v156;
          }
          else
          {
            v89 = (int)v154;
            v88 = (char *)v75;
LABEL_79:
            v90 = (int)&v77[v89];
            do
            {
              v91 = *v77;
              *v77++ = *v88;
              *v88++ = v91;
            }
            while ( v77 != (char *)v90 );
LABEL_81:
            v61 = v154;
            v44 = &v154[(_DWORD)v44];
          }
        }
        else
        {
          v114 = (char *)v75;
          v44 = &v154[(_DWORD)v44];
          do
          {
            v61 = (char *)(unsigned __int8)*v77;
            *v77++ = *v114;
            *v114++ = (char)v61;
          }
          while ( v77 != v44 );
        }
      }
      v115 = v75;
      v116 = v44;
      v17 = v156;
      v15 = (unsigned int)v154;
      v117 = v115 >= v151;
      if ( v115 < v151 )
        v117 = v14 >= v115 + 16;
      v118 = v117 != 0;
      if ( v153 & v118 )
      {
        if ( !v156 )
        {
          v126 = (int)v154;
          v125 = (char *)v115;
          v124 = (char *)v14;
          goto LABEL_129;
        }
        _R1 = v14;
        _R2 = v115;
        v121 = 0;
        do
        {
          __asm { VLD1.8          {D16-D17}, [R1] }
          ++v121;
          __asm
          {
            VLD1.8          {D18-D19}, [R2]
            VST1.8          {D18-D19}, [R1]!
            VST1.8          {D16-D17}, [R2]!
          }
        }
        while ( !_CF );
        v124 = (char *)(v14 + v156);
        v125 = (char *)(v115 + v156);
        if ( v154 != (char *)v156 )
        {
          v126 = v158;
LABEL_129:
          v127 = (int)&v124[v126];
          do
          {
            v128 = *v124;
            *v124++ = *v125;
            *v125++ = v128;
          }
          while ( v124 != (char *)v127 );
        }
      }
      else
      {
        v131 = (char *)v115;
        v132 = (char *)v14;
        do
        {
          v133 = v157;
          v134 = *v132;
          *v132++ = *v131;
          *v131++ = v134;
        }
        while ( v132 != (char *)v133 );
      }
      if ( (signed int)(v115 - v14) > (signed int)(v155 - (_DWORD)v44) )
      {
        v129 = v115;
        v116 = (char *)v14;
        v14 = (unsigned int)v44;
        v115 = v155;
        v155 = v129;
        v157 = (unsigned int)&v44[v15];
      }
      v161 = COERCE_DOUBLE(__PAIR__(v155, (unsigned int)v116));
      _R3 = v152;
      v155 = v115;
      __asm
      {
        VLDR            D16, [R7,#0x108+var_D0]
        VST1.32         {D16}, [R3]!
      }
    }
    v92 = v157;
    if ( v155 > v157 )
    {
      for ( i = v14; ; i -= v15 )
      {
        while ( 1 )
        {
          v94 = i + v15;
          if ( v160(a5, i, i + v15) <= 0 )
            goto LABEL_103;
          v95 = v94 >= i + 16;
          if ( v94 < i + 16 )
            v95 = i >= v94 + 16;
          v96 = v95 ? 1 : 0;
          v97 = v15 > 0xF ? v96 & 1 : 0;
          if ( v97 )
            break;
          v109 = (char *)(i + v15);
          v110 = (char *)i;
          do
          {
            v111 = *v110;
            *v110++ = *v109;
            *v109++ = v111;
          }
          while ( (char *)v94 != v110 );
          if ( i == v14 )
          {
LABEL_103:
            if ( v155 <= v92 + v15 )
              goto LABEL_111;
            i = v92;
            v92 += v15;
          }
          else
          {
            i -= v15;
          }
        }
        if ( !v17 )
          break;
        _R2 = i;
        _R0 = i + v15;
        _R1 = i + v15;
        v101 = 0;
        do
        {
          __asm { VLD1.8          {D16-D17}, [R2] }
          ++v101;
          __asm
          {
            VLD1.8          {D18-D19}, [R0]!
            VST1.8          {D18-D19}, [R2]!
            VST1.8          {D16-D17}, [R1]!
          }
        }
        while ( !_ZF && _CF );
        v94 += v17;
        v104 = (char *)(i + v17);
        if ( v15 != v17 )
        {
          v105 = v158;
          goto LABEL_99;
        }
LABEL_101:
        if ( i == v14 )
          goto LABEL_103;
      }
      v105 = v15;
      v104 = (char *)i;
LABEL_99:
      v106 = (char *)v94;
      v107 = (int)&v104[v105];
      do
      {
        v108 = *v104;
        *v104++ = *v106;
        *v106++ = v108;
      }
      while ( v104 != (char *)v107 );
      goto LABEL_101;
    }
LABEL_111:
    result = v150;
    if ( v152 != v150 )
    {
      v14 = *(v152 - 2);
      v113 = *(v152 - 1);
      v152 -= 2;
      v155 = v113;
      v157 = v14 + v15;
      continue;
    }
    return result;
  }
}
// 178A0: could not find valid save-restore pair for r4
// 178A0: could not find valid save-restore pair for r5
// 178A0: could not find valid save-restore pair for r6
// 178A0: could not find valid save-restore pair for r7
// 178A0: could not find valid save-restore pair for r8
// 178A0: could not find valid save-restore pair for r9
// 178A0: could not find valid save-restore pair for r10
// 178A0: could not find valid save-restore pair for r11
// 178A0: variables would overlap: r5.4 and r5.8
// 178A0: variables would overlap: r6.4 and r5.8
// 178A0: variables would overlap: r7.4 and r7.8
// 178A0: variables would overlap: r8.4 and r7.8
// 178A0: variables would overlap: r9.4 and r9.8
// 178A0: variables would overlap: r10.4 and r9.8
// 178A0: too many cbuild loops

//----- (00017E3C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_17E3C(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v7; // [sp+0h] [bp+0h]@1
  int *v8; // [sp+8h] [bp+8h]@1
  int v9; // [sp+Ch] [bp+Ch]@1

  v8 = &v7;
  v9 = v5;
  *(_QWORD *)&v7 = *(_QWORD *)&a4;
  return (*(int (__cdecl **)(_DWORD, int, _DWORD, signed int))(**(_DWORD **)(a1 + 80) + 100))(
           *(_DWORD *)(a1 + 80),
           a2,
           0,
           1);
}
// 17E3C: could not find valid save-restore pair for r4
// 17E3C: could not find valid save-restore pair for r7
// 17E3C: variables would overlap: r3.4 and r3.8
// 17E3C: variables would overlap: r4.4 and r3.8

//----- (00017E58) --------------------------------------------------------
int __fastcall sub_17E58(int a1, int a2)
{
  return sub_CA38(a2, 0);
}

//----- (00017E6C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_17E6C(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r4@1
  int v9; // r6@1
  void *v10; // r2@1
  int result; // r0@1
  __int64 v12; // [sp+0h] [bp+0h]@1
  __int64 v13; // [sp+8h] [bp+8h]@1
  __int64 *v14; // [sp+10h] [bp+10h]@1
  int v15; // [sp+14h] [bp+14h]@1

  v12 = *(_QWORD *)&a4;
  v8 = a1;
  v13 = *(_QWORD *)&v5;
  v14 = &v12;
  v15 = v7;
  v9 = a2;
  *(_DWORD *)(a1 + 52) = 16;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)a1 = &off_28960;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  v10 = malloc(0x100u);
  result = v8;
  *(_WORD *)(v8 + 62) = 0;
  *(_DWORD *)(v8 + 72) = v9;
  *(_DWORD *)(v8 + 48) = v10;
  *(_DWORD *)(v8 + 68) = v10;
  *(_WORD *)(v8 + 60) = -1;
  *(_DWORD *)(v8 + 44) = sub_188C8;
  *(_WORD *)(v8 + 64) = -1;
  *(_WORD *)(v8 + 66) = -1;
  return result;
}
// 17E6C: could not find valid save-restore pair for r4
// 17E6C: could not find valid save-restore pair for r5
// 17E6C: could not find valid save-restore pair for r6
// 17E6C: could not find valid save-restore pair for r7
// 17E6C: variables would overlap: r3.4 and r3.8
// 17E6C: variables would overlap: r4.4 and r3.8
// 17E6C: variables would overlap: r5.4 and r5.8
// 17E6C: variables would overlap: r6.4 and r5.8
// 188C8: using guessed type int sub_188C8();
// 28960: using guessed type void *;

//----- (00017ED8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_17ED8(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r6@1
  int v9; // r5@1
  int v10; // r4@1
  int v11; // r2@3
  void *v12; // r3@3
  int v13; // r2@3
  void *v14; // r0@5
  int v15; // [sp+0h] [bp+0h]@1
  __int64 v16; // [sp+8h] [bp+8h]@1
  int *v17; // [sp+10h] [bp+10h]@1
  int v18; // [sp+14h] [bp+14h]@1

  v17 = &v15;
  v18 = v7;
  v16 = *(_QWORD *)&v5;
  v8 = a1;
  *(_QWORD *)&v15 = *(_QWORD *)&a4;
  v9 = *(_DWORD *)(a1 + 16) - 1;
  v10 = 12 * v9;
  while ( v9 >= 0 )
  {
    while ( 1 )
    {
      v11 = *(_DWORD *)(v8 + 4);
      v12 = *(void **)(v11 + v10);
      v13 = v11 + v10;
      if ( v12 )
      {
        sub_CB24(v12);
        v13 = *(_DWORD *)(v8 + 4) + v10;
      }
      v14 = *(void **)(v13 + 8);
      v10 -= 12;
      --v9;
      if ( !v14 )
        break;
      free(v14);
      if ( v9 < 0 )
        goto LABEL_7;
    }
  }
LABEL_7:
  *(_DWORD *)(v8 + 16) = 0;
}
// 17ED8: could not find valid save-restore pair for r4
// 17ED8: could not find valid save-restore pair for r5
// 17ED8: could not find valid save-restore pair for r6
// 17ED8: could not find valid save-restore pair for r7
// 17ED8: variables would overlap: r3.4 and r3.8
// 17ED8: variables would overlap: r4.4 and r3.8
// 17ED8: variables would overlap: r5.4 and r5.8
// 17ED8: variables would overlap: r6.4 and r5.8

//----- (00017F24) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_17F24(int a1, int a2)
{
  int v2; // r4@0
  int v3; // r5@0 OVERLAPPED
  __int64 v5; // r7@0
  __int64 v6; // r9@0
  int v7; // r11@0
  int v8; // lr@0
  int v9; // r4@1
  int v10; // r11@2
  int v11; // r1@3
  int v12; // r5@6
  int v13; // r5@11
  int v14; // r0@14
  int result; // r0@14
  __int16 *v16; // r3@17
  __int16 *v17; // r3@19
  __int16 *v18; // [sp+4h] [bp+4h]@3
  __int16 *v19; // [sp+8h] [bp+8h]@3
  int v20; // [sp+Ch] [bp+Ch]@1
  int v21; // [sp+10h] [bp+10h]@2
  int v22; // [sp+1Ch] [bp+1Ch]@1
  __int64 v23; // [sp+20h] [bp+20h]@1
  __int64 v24; // [sp+28h] [bp+28h]@1
  __int64 v25; // [sp+30h] [bp+30h]@1
  int v26; // [sp+38h] [bp+38h]@1
  int v27; // [sp+3Ch] [bp+3Ch]@1

  v24 = v5;
  v22 = v2;
  v9 = a1;
  v26 = v7;
  v27 = v8;
  v25 = v6;
  v23 = *(_QWORD *)&v3;
  v20 = a2;
  if ( !a2 )
    goto LABEL_10;
  v10 = *(_WORD *)(a1 + 60);
  v21 = a2;
  if ( v10 == 0xFFFF )
    goto LABEL_10;
  v11 = *(_DWORD *)(a1 + 48);
  v18 = &word_29074;
  v19 = &word_29074;
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = 16 * v10;
      if ( !(*(int (__fastcall **)(int *, int))(v9 + 44))(&v21, v11 + 16 * v10 + 8) )
        break;
      if ( !(dword_2A5EC & 1) && _cxa_guard_acquire(&dword_2A5EC) )
      {
        v16 = v19;
        *v19 = -1;
        v16[1] = -1;
        v16[2] = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v11 = *(_DWORD *)(v9 + 48);
      v10 = *(_WORD *)(v11 + v12);
      if ( v10 == 0xFFFF )
        goto LABEL_10;
    }
    if ( !(*(int (__fastcall **)(int, int *))(v9 + 44))(*(_DWORD *)(v9 + 48) + v12 + 8, &v21) )
      break;
    if ( !(dword_2A5EC & 1) && _cxa_guard_acquire(&dword_2A5EC) )
    {
      v17 = v18;
      *v18 = -1;
      v17[1] = -1;
      v17[2] = -1;
      _cxa_guard_release(&dword_2A5EC);
    }
    v11 = *(_DWORD *)(v9 + 48);
    v10 = *(_WORD *)(v12 + v11 + 2);
    if ( v10 == 0xFFFF )
      goto LABEL_10;
  }
  if ( v10 != 0xFFFF )
  {
    result = *(_DWORD *)(*(_DWORD *)(v9 + 24) + 4 * *(_DWORD *)(v12 + *(_DWORD *)(v9 + 48) + 12));
  }
  else
  {
LABEL_10:
    if ( *(_DWORD *)(v9 + 36) <= 0 )
    {
LABEL_22:
      result = *(_DWORD *)(v9 + 72);
      if ( result )
        result = sub_17F24();
    }
    else
    {
      v13 = 0;
      while ( 1 )
      {
        v14 = *(_DWORD *)(*(_DWORD *)(v9 + 24) + 4 * v13);
        LOWORD(v13) = v13 + 1;
        result = (*(int (**)(void))(*(_DWORD *)v14 + 8))();
        if ( result )
          break;
        v13 = (unsigned __int16)v13;
        if ( (signed int)(unsigned __int16)v13 >= *(_DWORD *)(v9 + 36) )
          goto LABEL_22;
      }
    }
  }
  return result;
}
// 17F24: could not find valid save-restore pair for r4
// 17F24: could not find valid save-restore pair for r5
// 17F24: could not find valid save-restore pair for r6
// 17F24: could not find valid save-restore pair for r7
// 17F24: could not find valid save-restore pair for r8
// 17F24: could not find valid save-restore pair for r9
// 17F24: could not find valid save-restore pair for r10
// 17F24: could not find valid save-restore pair for r11
// 17F24: variables would overlap: r5.4 and r5.8
// 17F24: variables would overlap: r6.4 and r5.8
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00018110) --------------------------------------------------------
int __fastcall sub_18110(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(a1 + 76);
}

//----- (00018120) --------------------------------------------------------
int (*sub_18120())()
{
  return sub_18074;
}
// 18074: using guessed type int sub_18074();

//----- (00018138) --------------------------------------------------------
int __fastcall sub_18138(int a1, int a2, int a3, int a4)
{
  __int64 v4; // r4@0
  int v5; // lr@0
  int v6; // r5@1
  int v7; // r4@1
  int result; // r0@1
  __int64 v9; // [sp+0h] [bp+0h]@1
  __int64 *v10; // [sp+8h] [bp+8h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  v9 = v4;
  v6 = a2;
  v10 = &v9;
  v11 = v5;
  v7 = a1;
  sub_17E6C(a1, 0, a3, a4);
  *(_DWORD *)(v7 + 80) = v6;
  result = v7;
  *(_BYTE *)(v7 + 84) = 0;
  *(_DWORD *)v7 = &off_28988;
  return result;
}
// 18138: could not find valid save-restore pair for r4
// 18138: could not find valid save-restore pair for r5
// 18138: could not find valid save-restore pair for r7
// 28988: using guessed type void *;

//----- (00018168) --------------------------------------------------------
int __fastcall sub_18168(int result, int a2, int a3)
{
  *(_DWORD *)(result + 80) = a2;
  *(_DWORD *)(result + 72) = a3;
  return result;
}

//----- (0001824C) --------------------------------------------------------
int __fastcall sub_1824C(int a1, unsigned int a2, int a3)
{
  int v4; // r9@1
  int v5; // r5@1
  const char *v6; // r8@1
  int v7; // r0@3
  int v8; // r3@3
  const char *v9; // r1@8

  v4 = a1;
  v5 = a3;
  v6 = "Unknown";
  if ( a2 <= 8 )
    v6 = off_28550[a2];
  v7 = sub_189B0(a1 + 44);
  if ( v7 != 0xFFFF )
  {
    v8 = *(_DWORD *)(v4 + 48) + 16 * v7;
    if ( *(_DWORD *)(v8 + 12) == v5 )
    {
LABEL_10:
      v9 = *(const char **)(v8 + 8);
      return Warning("System (%s) failed during stage %s\n", v9, v6, v8);
    }
    while ( 1 )
    {
      v7 = sub_93F0(v4 + 44, (unsigned __int16)v7);
      if ( v7 == 0xFFFF )
        break;
      v8 = *(_DWORD *)(v4 + 48) + 16 * v7;
      if ( *(_DWORD *)(v8 + 12) == v5 )
        goto LABEL_10;
    }
  }
  v9 = "(Unknown)";
  return Warning("System (%s) failed during stage %s\n", v9, v6, v8);
}
// 1824C: could not find valid save-restore pair for r9
// 365C: using guessed type int Warning(const char *, ...);
// 28550: using guessed type char *off_28550[4];

//----- (000182E8) --------------------------------------------------------
signed int __fastcall sub_182E8(int a1)
{
  int v1; // r5@1
  int v2; // r4@1
  signed int result; // r0@5

  v1 = a1;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 36) > 0 )
  {
    while ( (***(int (****)(void))(*(_DWORD *)(v1 + 24) + 4 * v2))() )
    {
      if ( *(_DWORD *)(v1 + 36) <= ++v2 )
        goto LABEL_6;
    }
    sub_1824C(v1, 1u, v2);
    result = 0;
  }
  else
  {
LABEL_6:
    result = 1;
  }
  return result;
}
// 182E8: could not find valid save-restore pair for r4
// 182E8: could not find valid save-restore pair for r5
// 182E8: could not find valid save-restore pair for r6
// 182E8: could not find valid save-restore pair for r7
// 18074: using guessed type int sub_18074();

//----- (00018344) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_18344(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r5@1
  int v9; // r4@2
  int v10; // r0@5
  int v11; // r6@5
  signed int result; // r0@6
  int v13; // [sp+0h] [bp+0h]@1
  __int64 v14; // [sp+8h] [bp+8h]@1
  int *v15; // [sp+10h] [bp+10h]@1
  int v16; // [sp+14h] [bp+14h]@1

  v15 = &v13;
  v16 = v7;
  v14 = *(_QWORD *)&v5;
  v8 = a1;
  *(_QWORD *)&v13 = *(_QWORD *)&a4;
  if ( *(_DWORD *)(a1 + 36) <= 0 )
  {
LABEL_7:
    result = 1;
  }
  else
  {
    v9 = 0;
    while ( 1 )
    {
      v10 = *(_DWORD *)(*(_DWORD *)(v8 + 24) + 4 * v9);
      v11 = (*(int (__cdecl **)(int))(*(_DWORD *)v10 + 12))(v10);
      if ( v11 != 1 )
        break;
      if ( *(_DWORD *)(v8 + 36) <= ++v9 )
        goto LABEL_7;
    }
    sub_1824C(v8, 3u, v9);
    result = v11;
  }
  return result;
}
// 18344: could not find valid save-restore pair for r4
// 18344: could not find valid save-restore pair for r5
// 18344: could not find valid save-restore pair for r6
// 18344: could not find valid save-restore pair for r7
// 18344: variables would overlap: r3.4 and r3.8
// 18344: variables would overlap: r4.4 and r3.8
// 18344: variables would overlap: r5.4 and r5.8
// 18344: variables would overlap: r6.4 and r5.8

//----- (00018390) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_18390(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int v7; // r1@3
  int v8; // r2@3
  int v9; // r3@3
  signed int result; // r0@4
  __int64 v11; // [sp+0h] [bp+0h]@1
  __int64 *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v11 = *(_QWORD *)&a4;
  v6 = a1;
  v12 = &v11;
  v13 = v5;
  *(_DWORD *)(a1 + 76) = 8;
  dword_2DEF4 = a1;
  if ( (**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD, _DWORD))a1)(a1, a2, 8, **(_DWORD **)a1) )
  {
    if ( sub_182E8(v6) )
    {
      if ( (*(int (__fastcall **)(int))(*(_DWORD *)v6 + 4))(v6) )
      {
        result = sub_18344(v6, v7, v8, v9);
        if ( result != 1 )
        {
          result = -1;
          *(_DWORD *)(v6 + 76) = 3;
        }
      }
      else
      {
        result = -1;
        *(_DWORD *)(v6 + 76) = 2;
      }
    }
    else
    {
      result = -1;
      *(_DWORD *)(v6 + 76) = 1;
    }
  }
  else
  {
    *(_DWORD *)(v6 + 76) = 0;
    result = -1;
  }
  return result;
}
// 18390: could not find valid save-restore pair for r4
// 18390: could not find valid save-restore pair for r7
// 18390: variables would overlap: r3.4 and r3.8
// 18390: variables would overlap: r4.4 and r3.8
// 2DEF4: using guessed type int dword_2DEF4;

//----- (000183F8) --------------------------------------------------------
signed int __fastcall sub_183F8(int a1, int a2, int a3, int a4)
{
  return sub_18390(a1, a2, a3, a4);
}

//----- (00018420) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_18420(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r6@1
  int v9; // r3@1
  int v10; // r4@2
  int v11; // r5@3
  int v12; // r0@5
  int v13; // r4@7
  int v14; // r5@8
  int v15; // r0@9
  int v16; // r1@10
  int v17; // r2@10
  int v18; // r3@10
  int v20; // [sp+0h] [bp+0h]@1
  __int64 v21; // [sp+8h] [bp+8h]@1
  int *v22; // [sp+10h] [bp+10h]@1
  int v23; // [sp+14h] [bp+14h]@1

  v22 = &v20;
  v23 = v7;
  v21 = *(_QWORD *)&v5;
  v8 = a1;
  *(_QWORD *)&v20 = *(_QWORD *)&a4;
  v9 = *(_DWORD *)(a1 + 76);
  dword_2DEF4 = a1;
  switch ( v9 )
  {
    case 2:
    case 3:
      goto LABEL_7;
    case 0:
    case 1:
      break;
    default:
      v10 = *(_DWORD *)(a1 + 36) - 1;
      if ( v10 >= 0 )
      {
        v11 = 4 * v10;
        do
        {
          --v10;
          v12 = *(_DWORD *)(*(_DWORD *)(v8 + 24) + v11);
          v11 -= 4;
          (*(void (__cdecl **)(int))(*(_DWORD *)v12 + 16))(v12);
        }
        while ( v10 != -1 );
      }
      (*(void (__fastcall **)(int))(*(_DWORD *)v8 + 12))(v8);
LABEL_7:
      v13 = *(_DWORD *)(v8 + 36) - 1;
      if ( v13 >= 0 )
      {
        v14 = 4 * v13;
        do
        {
          --v13;
          v15 = *(_DWORD *)(*(_DWORD *)(v8 + 24) + v14);
          v14 -= 4;
          (*(void (__cdecl **)(int))(*(_DWORD *)v15 + 4))(v15);
        }
        while ( v13 != -1 );
      }
      break;
  }
  *(_DWORD *)(v8 + 36) = 0;
  sub_18AA8(v8 + 44);
  sub_17ED8(v8, v16, v17, v18);
  return (*(int (__fastcall **)(int))(*(_DWORD *)v8 + 16))(v8);
}
// 18420: could not find valid save-restore pair for r4
// 18420: could not find valid save-restore pair for r5
// 18420: could not find valid save-restore pair for r6
// 18420: could not find valid save-restore pair for r7
// 18420: variables would overlap: r3.4 and r3.8
// 18420: variables would overlap: r4.4 and r3.8
// 18420: variables would overlap: r5.4 and r5.8
// 18420: variables would overlap: r6.4 and r5.8
// 2DEF4: using guessed type int dword_2DEF4;

//----- (000184A4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_184A4(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r4@1
  signed int result; // r0@1
  int v10; // r6@2
  int v11; // r1@2
  int v12; // r2@2
  int v13; // r3@2
  __int64 v14; // [sp+0h] [bp+0h]@1
  __int64 v15; // [sp+8h] [bp+8h]@1
  __int64 *v16; // [sp+10h] [bp+10h]@1
  int v17; // [sp+14h] [bp+14h]@1

  v15 = *(_QWORD *)&v5;
  v14 = *(_QWORD *)&a4;
  v8 = a1;
  v16 = &v14;
  v17 = v7;
  dword_2DEF4 = a1;
  result = sub_18390(a1, a2, a3, a4);
  if ( *(_DWORD *)(v8 + 76) == 8 )
  {
    v10 = (*(int (__fastcall **)(int))(*(_DWORD *)v8 + 8))(v8);
    sub_18420(v8, v11, v12, v13);
    result = v10;
    dword_2DEF4 = *(_DWORD *)(v8 + 72);
  }
  return result;
}
// 184A4: could not find valid save-restore pair for r4
// 184A4: could not find valid save-restore pair for r5
// 184A4: could not find valid save-restore pair for r6
// 184A4: could not find valid save-restore pair for r7
// 184A4: variables would overlap: r3.4 and r3.8
// 184A4: variables would overlap: r4.4 and r3.8
// 184A4: variables would overlap: r5.4 and r5.8
// 184A4: variables would overlap: r6.4 and r5.8
// 2DEF4: using guessed type int dword_2DEF4;

//----- (000184E4) --------------------------------------------------------
int __fastcall sub_184E4(int a1, int a2, int a3, int a4)
{
  return sub_18420(a1, a2, a3, a4);
}

//----- (000184F4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_184F4(int a1, const char *a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r10@1
  const char *v7; // r8@1
  size_t v8; // r9@1
  int v9; // r4@1
  int v10; // r5@1
  int v11; // r3@2
  const char *v12; // r1@2
  int v13; // r2@6
  int v14; // r3@6
  int v15; // r11@6
  signed int v16; // r4@7
  int v17; // r1@7
  int v18; // r5@7
  int v19; // r3@8
  int v20; // r1@10
  int v21; // r3@10
  int v22; // r5@13
  int v23; // r8@15
  signed int result; // r0@15
  int v25; // r0@14
  __int64 v26; // [sp+0h] [bp+0h]@1
  int v27; // [sp+24h] [bp+24h]@1

  v6 = a1;
  v7 = a2;
  v26 = *(_QWORD *)&a4;
  v27 = v5;
  v8 = strlen(a2) + 1;
  sub_1325C(v7, (char *)&v26, v8);
  v9 = *(_DWORD *)(v6 + 16) - 1;
  v10 = 12 * v9;
  while ( v9 >= 0 )
  {
    v11 = *(_DWORD *)(v6 + 4) + v10;
    v10 -= 12;
    v12 = *(const char **)(v11 + 8);
    if ( v12 && !sub_11A70((const char *)&v26, v12) )
      return v9;
    --v9;
  }
  v15 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v6 + 28))(v6, v7);
  if ( v15 )
  {
    v16 = *(_DWORD *)(v6 + 16);
    v17 = *(_DWORD *)(v6 + 8);
    v18 = v16 + 1;
    if ( v16 + 1 > v17 )
    {
      sub_18B7C((void *)(v6 + 4), v18 - v17, v13, v14);
      v19 = *(_DWORD *)(v6 + 16) + 1;
    }
    else
    {
      v19 = v16 + 1;
    }
    v20 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(v6 + 16) = v19;
    v21 = v19 - v16 - 1;
    if ( v21 <= 0 )
      v18 = 3 * v16;
    *(_DWORD *)(v6 + 20) = v20;
    if ( v21 > 0 )
    {
      v25 = 12 * v18;
      v22 = 12 * v18 - 12;
      memmove((void *)(v25 + v20), (const void *)(v20 + v22), 12 * v21);
      v20 = *(_DWORD *)(v6 + 4);
    }
    else
    {
      v22 = 4 * v18;
    }
    *(_DWORD *)(v20 + v22) = v15;
    *(_DWORD *)(*(_DWORD *)(v6 + 4) + v22 + 4) = 0;
    v23 = *(_DWORD *)(v6 + 4) + v22;
    *(_DWORD *)(v23 + 8) = malloc(v8);
    sub_12330(*(char **)(v22 + *(_DWORD *)(v6 + 4) + 8), (const char *)&v26, v8);
    result = v16;
  }
  else
  {
    Warning("AppFramework : Unable to load module %s!\n", v7);
    result = -1;
  }
  return result;
}
// 184F4: could not find valid save-restore pair for r4
// 184F4: variables would overlap: r3.4 and r3.8
// 184F4: variables would overlap: r4.4 and r3.8
// 365C: using guessed type int Warning(const char *, ...);

//----- (00018638) --------------------------------------------------------
signed int __fastcall sub_18638(int a1, int a2)
{
  int v2; // r4@0
  int v3; // r5@1
  int v4; // r6@1
  signed int v5; // r8@2
  int v6; // r3@2
  int v7; // r9@2
  int v8; // r2@2
  int v9; // r4@4
  signed int result; // r0@6
  int v11; // r1@7
  int v12; // r3@7
  int v13; // r1@9
  int v14; // r3@9

  v3 = a1;
  v4 = a2;
  if ( a2 )
  {
    v5 = *(_DWORD *)(a1 + 16);
    v6 = *(_DWORD *)(a1 + 16);
    v7 = 12 * (v5 - 1);
    v8 = 12 * (v5 - 1);
    while ( --v6 >= 0 )
    {
      v9 = *(_DWORD *)(a1 + 4) + v8;
      v8 -= 12;
      v2 = *(_DWORD *)(v9 + 4);
      if ( v2 && a2 == v2 )
        return v6;
    }
    v11 = *(_DWORD *)(a1 + 8);
    v12 = v5 + 1;
    if ( v5 + 1 > v11 )
    {
      sub_18B7C((void *)(a1 + 4), v12 - v11, v8, v12);
      v12 = *(_DWORD *)(v3 + 16) + 1;
    }
    v13 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 16) = v12;
    v14 = v12 - v5 - 1;
    if ( v14 <= 0 )
      v2 = v7 + 12;
    *(_DWORD *)(v3 + 20) = v13;
    if ( v14 > 0 )
    {
      v2 = v7 + 12;
      memmove((void *)(v7 + 24 + v13), (const void *)(v13 + v7 + 12), 12 * v14);
      v13 = *(_DWORD *)(v3 + 4);
    }
    result = v5;
    *(_DWORD *)(v13 + v2) = 0;
    *(_DWORD *)(*(_DWORD *)(v3 + 4) + v2 + 4) = v4;
    *(_DWORD *)(v2 + *(_DWORD *)(v3 + 4) + 8) = 0;
  }
  else
  {
    Warning("AppFramework : Unable to load module %p!\n");
    result = -1;
  }
  return result;
}
// 18638: could not find valid save-restore pair for r4
// 18638: could not find valid save-restore pair for r5
// 18638: could not find valid save-restore pair for r6
// 18638: could not find valid save-restore pair for r7
// 18638: could not find valid save-restore pair for r8
// 365C: using guessed type int Warning(const char *, ...);

//----- (000186F4) --------------------------------------------------------
int __fastcall sub_186F4(int a1, int a2, const char *a3)
{
  int v3; // lr@0
  int v4; // r4@1
  const char *v5; // r5@1
  int v6; // r3@2
  int v7; // r1@2
  void *v8; // r0@2
  int v9; // r1@2
  int (__fastcall *v10)(const char *, int *); // r3@3
  int v11; // r0@4
  int v12; // r1@6
  int result; // r0@6
  int v14; // [sp+0h] [bp+0h]@4
  int v15; // [sp+8h] [bp+8h]@6
  int v16; // [sp+10h] [bp+10h]@6
  int v17; // [sp+24h] [bp+24h]@1

  v4 = a1;
  v5 = a3;
  v17 = v3;
  if ( a2 == -1 )
  {
    result = 0;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 4);
    v7 = 12 * a2;
    v8 = *(void **)(v6 + v7);
    v9 = v7 + v6;
    if ( v8 )
      v10 = (int (__fastcall *)(const char *, int *))sub_CB40(v8);
    else
      v10 = *(int (__fastcall **)(const char *, int *))(v9 + 4);
    v11 = v10(v5, &v14);
    if ( v14 || !v11 )
    {
      Warning("AppFramework : Unable to create system %s!\n", v5, v11);
      result = 0;
    }
    else
    {
      v12 = *(_DWORD *)(v4 + 36);
      v15 = v11;
      v16 = sub_18900(v4 + 24, v12, &v15);
      sub_19DF8(v4 + 44, v5, &v16);
      result = v15;
    }
  }
  return result;
}
// 365C: using guessed type int Warning(const char *, ...);

//----- (0001877C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_1877C(int a1, const char **a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r5@1
  const char **v9; // r4@1
  const char *v10; // r1@1
  int v11; // r3@1
  const char *v12; // t1@3
  int v13; // r0@4
  signed int result; // r0@5
  int v15; // [sp+0h] [bp+0h]@1
  __int64 v16; // [sp+8h] [bp+8h]@1
  int *v17; // [sp+10h] [bp+10h]@1
  int v18; // [sp+14h] [bp+14h]@1

  v17 = &v15;
  v18 = v7;
  v16 = *(_QWORD *)&v5;
  v8 = a1;
  *(_QWORD *)&v15 = *(_QWORD *)&a4;
  v9 = a2;
  v10 = *a2;
  v11 = *v10;
  if ( *v10 )
  {
    while ( 1 )
    {
      v13 = sub_184F4(v8, v10, a3, v11);
      if ( !sub_186F4(v8, v13, v9[1]) )
        break;
      v12 = v9[2];
      v9 += 2;
      v10 = v12;
      v11 = *v12;
      if ( !*v12 )
        goto LABEL_6;
    }
    Warning("Unable to load interface %s from %s\n", v9[1], *v9);
    result = 0;
  }
  else
  {
LABEL_6:
    result = 1;
  }
  return result;
}
// 1877C: could not find valid save-restore pair for r4
// 1877C: could not find valid save-restore pair for r5
// 1877C: could not find valid save-restore pair for r6
// 1877C: could not find valid save-restore pair for r7
// 1877C: variables would overlap: r3.4 and r3.8
// 1877C: variables would overlap: r4.4 and r3.8
// 1877C: variables would overlap: r5.4 and r5.8
// 1877C: variables would overlap: r6.4 and r5.8
// 365C: using guessed type int Warning(const char *, ...);

//----- (000187D4) --------------------------------------------------------
void __fastcall sub_187D4(int a1, int a2, const char *a3)
{
  int v3; // lr@0
  int v4; // r4@1
  const char *v5; // r5@1
  int v6; // [sp+4h] [bp+4h]@1
  int v7; // [sp+8h] [bp+8h]@2
  int v8; // [sp+1Ch] [bp+1Ch]@1

  v4 = a1;
  v5 = a3;
  v8 = v3;
  v6 = a2;
  if ( a2 )
  {
    v7 = sub_18900(a1 + 24, *(_DWORD *)(a1 + 36), &v6);
    sub_19DF8(v4 + 44, v5, &v7);
  }
}

//----- (00018900) --------------------------------------------------------
int __fastcall sub_18900(int a1, int a2, _DWORD *a3)
{
  int v3; // r6@1
  int v4; // r4@1
  signed int v5; // r1@1
  _DWORD *v6; // r8@1
  int i; // r3@1
  int v8; // r5@1
  char *v9; // r3@2
  int v10; // r2@3
  int v11; // r5@4
  int v12; // r0@5
  signed int v14; // r2@9
  char *v15; // r0@13
  char *v16; // r0@14
  int v17; // r5@14

  v3 = a2;
  v4 = a1;
  v5 = *(_DWORD *)(a1 + 12);
  v6 = a3;
  i = *(_DWORD *)(a1 + 4);
  v8 = v5 + 1;
  if ( v5 + 1 <= i || (v14 = *(_DWORD *)(a1 + 8), v14 < 0) )
  {
    v9 = *(char **)a1;
  }
  else
  {
    if ( v14 )
    {
      for ( i = v14 + v5 / v14 * v14; v8 > i; i = (i + v8) / 2 )
        ;
    }
    else if ( i || (i = 8, v8 > 8) )
    {
      do
      {
        i *= 2;
        if ( v8 <= i )
          break;
        i *= 2;
      }
      while ( v8 > i );
    }
    v15 = *(char **)a1;
    *(_DWORD *)(v4 + 4) = i;
    if ( v15 )
    {
      v16 = (char *)realloc(v15, 4 * i);
      v17 = *(_DWORD *)(v4 + 12);
      v9 = v16;
      *(_DWORD *)v4 = v16;
      v8 = v17 + 1;
    }
    else
    {
      v9 = (char *)malloc(4 * i);
      *(_DWORD *)v4 = v9;
    }
  }
  *(_DWORD *)(v4 + 12) = v8;
  v10 = v8 - v3 - 1;
  *(_DWORD *)(v4 + 16) = v9;
  if ( v10 > 0 )
  {
    v12 = 4 * (v3 + 1);
    v11 = v12 - 4;
    memmove(&v9[v12], &v9[v12 - 4], 4 * v10);
    v9 = *(char **)v4;
  }
  else
  {
    v11 = 4 * v3;
  }
  if ( &v9[v11] )
    *(_DWORD *)&v9[v11] = *v6;
  return v3;
}
// 18900: could not find valid save-restore pair for r4
// 18900: could not find valid save-restore pair for r5
// 18900: could not find valid save-restore pair for r6
// 18900: could not find valid save-restore pair for r7

//----- (000189B0) --------------------------------------------------------
int __fastcall sub_189B0(int a1)
{
  int v1; // r9@1
  int v2; // r4@1
  char v3; // r3@1
  __int16 *v4; // r3@3
  signed int v5; // r0@9
  bool v6; // zf@9

  v1 = a1;
  v2 = *(_WORD *)(a1 + 16);
  v3 = dword_2A5EC;
  while ( 1 )
  {
    if ( !(v3 & 1) && _cxa_guard_acquire(&dword_2A5EC) )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      _cxa_guard_release(&dword_2A5EC);
    }
    if ( v2 == 0xFFFF )
      v4 = &word_29074;
    else
      v4 = *(__int16 **)(v1 + 4);
    if ( v2 != 0xFFFF )
      v4 += 8 * v2;
    if ( (unsigned __int16)*v4 == 0xFFFF )
      break;
    v3 = dword_2A5EC;
    if ( !(dword_2A5EC & 1) )
    {
      if ( _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v3 = dword_2A5EC;
    }
    v5 = 0xFFFF;
    v6 = v2 == 0xFFFF;
    if ( v2 == 0xFFFF )
      v2 = (int)&word_29074;
    else
      v5 = *(_DWORD *)(v1 + 4);
    if ( !v6 )
      v2 = v5 + 16 * v2;
    v2 = *(_WORD *)v2;
  }
  return v2;
}
// 189B0: could not find valid save-restore pair for r4
// 189B0: could not find valid save-restore pair for r5
// 189B0: could not find valid save-restore pair for r6
// 189B0: could not find valid save-restore pair for r7
// 189B0: could not find valid save-restore pair for r8
// 189B0: could not find valid save-restore pair for r9
// 189B0: could not find valid save-restore pair for r10
// 189B0: could not find valid save-restore pair for r11
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00018AA8) --------------------------------------------------------
int __fastcall sub_18AA8(int a1)
{
  int v1; // r5@1
  int result; // r0@1
  unsigned int i; // r4@1
  unsigned int v4; // r2@3
  unsigned int v5; // r3@4
  unsigned int v6; // r4@5
  int v7; // r1@13
  int v8; // r3@13
  int v9; // r1@13
  bool v10; // zf@13

  v1 = a1;
  result = sub_189B0(a1);
  for ( i = result; result != 0xFFFF; i = result )
  {
    free(*(void **)(*(_DWORD *)(v1 + 4) + 16 * i + 8));
    result = sub_93F0(v1, i);
  }
  v4 = *(_WORD *)(v1 + 22);
  if ( v4 != 0xFFFF )
  {
    v5 = *(_DWORD *)(v1 + 8);
    if ( v5 )
    {
      v6 = 0;
      do
      {
        if ( v6 < v5 && v4 >= v6 )
        {
          if ( !(dword_2A5EC & 1) )
          {
            result = _cxa_guard_acquire(&dword_2A5EC);
            if ( result )
            {
              word_29074 = -1;
              word_29076 = -1;
              word_29078 = -1;
              result = _cxa_guard_release(&dword_2A5EC);
            }
          }
          v7 = *(_DWORD *)(v1 + 4);
          v4 = 16 * v6;
          v8 = *(_WORD *)(v7 + 16 * v6);
          v9 = v7 + 16 * v6;
          v10 = v8 == v6;
          if ( v8 == v6 )
            v4 = *(_WORD *)(v1 + 22);
          else
            LOWORD(v8) = *(_WORD *)(v1 + 20);
          if ( !v10 )
          {
            *(_WORD *)(v9 + 2) = v8;
            *(_WORD *)(*(_DWORD *)(v1 + 4) + v4) = v6;
            v4 = *(_WORD *)(v1 + 22);
            *(_WORD *)(v1 + 20) = v6;
          }
        }
        if ( v6 == v4 )
          break;
        v5 = *(_DWORD *)(v1 + 8);
        v6 = (unsigned __int16)(v6 + 1);
        if ( v6 >= v5 )
          break;
      }
      while ( v6 != 0xFFFF );
    }
    *(_WORD *)(v1 + 16) = -1;
    *(_WORD *)(v1 + 18) = 0;
  }
  return result;
}
// 18AA8: could not find valid save-restore pair for r4
// 18AA8: could not find valid save-restore pair for r5
// 18AA8: could not find valid save-restore pair for r6
// 18AA8: could not find valid save-restore pair for r7
// 18AA8: could not find valid save-restore pair for r8
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00018B7C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_18B7C(void *result, int a2, int a3, int a4)
{
  int v5; // lr@0
  signed int v6; // r2@1
  _DWORD *v7; // r4@1
  int i; // r3@2
  int v9; // r1@2
  void *v10; // r0@5
  int v11; // [sp+0h] [bp+0h]@1
  int *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v12 = &v11;
  v13 = v5;
  *(_QWORD *)&v11 = *(_QWORD *)&a4;
  v6 = *((_DWORD *)result + 2);
  v7 = result;
  if ( v6 >= 0 )
  {
    i = *((_DWORD *)result + 1);
    v9 = a2 + i;
    if ( v6 )
    {
      for ( i = v6 + (v9 - 1) / v6 * v6; v9 > i; i = (i + v9) / 2 )
        ;
    }
    else
    {
      if ( !i )
        i = 3;
      for ( ; v9 > i; i *= 2 )
        ;
    }
    v10 = *(void **)result;
    v7[1] = i;
    if ( v10 )
    {
      result = realloc(v10, 12 * i);
      *v7 = result;
    }
    else
    {
      result = malloc(12 * i);
      *v7 = result;
    }
  }
  return result;
}
// 18B7C: could not find valid save-restore pair for r4
// 18B7C: could not find valid save-restore pair for r7
// 18B7C: variables would overlap: r3.4 and r3.8
// 18B7C: variables would overlap: r4.4 and r3.8

//----- (00018BE4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__fastcall sub_18BE4(void *result, int a2, int a3, int a4)
{
  int v5; // lr@0
  signed int v6; // r2@1
  void **v7; // r4@1
  int v8; // r3@2
  int v9; // r1@2
  void *v10; // r0@12
  int v11; // [sp+0h] [bp+0h]@1
  int *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v12 = &v11;
  v13 = v5;
  *(_QWORD *)&v11 = *(_QWORD *)&a4;
  v6 = *((_DWORD *)result + 2);
  v7 = (void **)result;
  if ( v6 >= 0 )
  {
    v8 = *((_DWORD *)result + 1);
    v9 = a2 + v8;
    if ( v6 )
    {
      v8 = v6 + (v9 - 1) / v6 * v6;
    }
    else
    {
      if ( !v8 )
        v8 = 2;
      for ( ; v9 > v8; v8 *= 2 )
        ;
    }
    result = (void *)(unsigned __int16)v8;
    if ( v9 > (unsigned __int16)v8 )
    {
      if ( (_WORD)v8 )
      {
        if ( (unsigned __int16)v9 != v9 )
          return result;
        if ( (unsigned __int16)v8 < v9 )
        {
          do
            v8 = (v8 + (unsigned __int16)v9) / 2;
          while ( (unsigned __int16)v9 > (signed int)(unsigned __int16)v8 );
        }
      }
      else
      {
        if ( v9 >= 0x10000 )
          return result;
        --v8;
      }
    }
    v10 = *v7;
    v7[1] = (void *)v8;
    if ( v10 )
    {
      result = realloc(v10, 16 * v8);
      *v7 = result;
    }
    else
    {
      result = malloc(16 * v8);
      *v7 = result;
    }
  }
  return result;
}
// 18BE4: could not find valid save-restore pair for r4
// 18BE4: could not find valid save-restore pair for r7
// 18BE4: variables would overlap: r3.4 and r3.8
// 18BE4: variables would overlap: r4.4 and r3.8

//----- (00018C64) --------------------------------------------------------
int __fastcall sub_18C64(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r4@1
  int v4; // r2@2
  int v5; // r8@5
  int v6; // r6@5
  int v7; // r3@7
  int v8; // r9@7
  __int16 *v9; // r2@7
  int result; // r0@8
  __int16 *v11; // r3@10
  int v12; // r3@13
  __int16 *v13; // r2@14
  int v14; // r3@19
  __int16 *v15; // r2@20
  int v16; // r2@26
  int v17; // r10@29
  int v18; // r2@30
  __int16 *v19; // r10@31
  int v20; // r3@34
  __int16 *v21; // r2@35
  int v22; // r3@50
  __int16 *v23; // r2@51

  v2 = a2;
  v3 = a1;
  if ( dword_2A5EC << 31 < 0 )
  {
    v4 = 1;
    if ( a2 != 0xFFFF )
      goto LABEL_5;
LABEL_44:
    v5 = 1048560;
    v6 = (unsigned __int16)word_29076;
    if ( v4 )
      goto LABEL_6;
    goto LABEL_45;
  }
  if ( _cxa_guard_acquire(&dword_2A5EC) )
  {
    word_29074 = -1;
    word_29076 = -1;
    word_29078 = -1;
    _cxa_guard_release(&dword_2A5EC);
  }
  v4 = dword_2A5EC & 1;
  if ( v2 == 0xFFFF )
    goto LABEL_44;
LABEL_5:
  v5 = 16 * v2;
  v6 = *(_WORD *)(*(_DWORD *)(v3 + 4) + 16 * v2 + 2);
  if ( v4 )
    goto LABEL_6;
LABEL_45:
  if ( _cxa_guard_acquire(&dword_2A5EC) )
  {
    word_29074 = -1;
    word_29076 = -1;
    word_29078 = -1;
    _cxa_guard_release(&dword_2A5EC);
  }
LABEL_6:
  if ( v6 == 0xFFFF )
  {
    v8 = 1048560;
    v7 = *(_DWORD *)(v3 + 4);
    v9 = &word_29074;
  }
  else
  {
    v7 = *(_DWORD *)(v3 + 4);
    v8 = 16 * v6;
    v9 = (__int16 *)(v7 + 16 * v6);
  }
  *(_WORD *)(v7 + v5 + 2) = *v9;
  result = dword_2A5EC << 31;
  if ( !(dword_2A5EC & 1) )
  {
    result = _cxa_guard_acquire(&dword_2A5EC);
    if ( result )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      result = _cxa_guard_release(&dword_2A5EC);
    }
  }
  if ( v6 == 0xFFFF )
    v11 = &word_29074;
  else
    v11 = (__int16 *)(*(_DWORD *)(v3 + 4) + v8);
  if ( (unsigned __int16)*v11 != 0xFFFF )
  {
    if ( !(dword_2A5EC & 1) )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v12 = *(_DWORD *)(v3 + 4);
    if ( v6 == 0xFFFF )
      v13 = &word_29074;
    else
      v13 = (__int16 *)(v12 + v8);
    *(_WORD *)(v12 + 16 * (unsigned __int16)*v13 + 4) = v2;
  }
  if ( v6 != 0xFFFF )
  {
    if ( !(dword_2A5EC & 1) )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v14 = *(_DWORD *)(v3 + 4);
    if ( v2 == 0xFFFF )
      v15 = &word_29074;
    else
      v15 = (__int16 *)(v14 + v5);
    *(_WORD *)(v14 + v8 + 4) = v15[2];
  }
  if ( *(_WORD *)(v3 + 16) == v2 )
  {
    *(_WORD *)(v3 + 16) = v6;
    goto LABEL_38;
  }
  if ( dword_2A5EC << 31 >= 0 )
  {
    result = _cxa_guard_acquire(&dword_2A5EC);
    if ( result )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      result = _cxa_guard_release(&dword_2A5EC);
    }
    v16 = dword_2A5EC & 1;
    if ( v2 != 0xFFFF )
    {
LABEL_29:
      v17 = *(_WORD *)(*(_DWORD *)(v3 + 4) + v5 + 4);
      if ( v16 )
        goto LABEL_30;
LABEL_63:
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
      v18 = dword_2A5EC & 1;
      if ( v17 != 0xFFFF )
        goto LABEL_31;
      goto LABEL_66;
    }
  }
  else
  {
    v16 = 1;
    if ( v2 != 0xFFFF )
      goto LABEL_29;
  }
  v17 = (unsigned __int16)word_29078;
  if ( !v16 )
    goto LABEL_63;
LABEL_30:
  v18 = 1;
  if ( v17 != 0xFFFF )
  {
LABEL_31:
    v19 = (__int16 *)(*(_DWORD *)(v3 + 4) + 16 * v17);
    goto LABEL_32;
  }
LABEL_66:
  v19 = &word_29074;
LABEL_32:
  if ( (unsigned __int16)*v19 == v2 )
  {
    if ( !v18 )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v20 = *(_DWORD *)(v3 + 4);
    if ( v2 == 0xFFFF )
      v21 = &word_29074;
    else
      v21 = (__int16 *)(v20 + v5);
    *(_WORD *)(v20 + 16 * (unsigned __int16)v21[2]) = v6;
  }
  else
  {
    if ( !v18 )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v22 = *(_DWORD *)(v3 + 4);
    if ( v2 == 0xFFFF )
      v23 = &word_29074;
    else
      v23 = (__int16 *)(v22 + v5);
    *(_WORD *)(v22 + 16 * (unsigned __int16)v23[2] + 2) = v6;
  }
LABEL_38:
  *(_WORD *)(*(_DWORD *)(v3 + 4) + v8) = v2;
  if ( v2 != 0xFFFF )
    *(_WORD *)(v5 + *(_DWORD *)(v3 + 4) + 4) = v6;
  return result;
}
// 18C64: could not find valid save-restore pair for r4
// 18C64: could not find valid save-restore pair for r5
// 18C64: could not find valid save-restore pair for r6
// 18C64: could not find valid save-restore pair for r7
// 18C64: could not find valid save-restore pair for r8
// 18C64: could not find valid save-restore pair for r9
// 18C64: could not find valid save-restore pair for r10
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00019034) --------------------------------------------------------
int __fastcall sub_19034(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r4@1
  int v4; // r2@2
  int v5; // r8@5
  int v6; // r6@5
  int v7; // r3@7
  int v8; // r9@7
  __int16 *v9; // r2@7
  int result; // r0@8
  __int16 *v11; // r3@10
  int v12; // r3@13
  __int16 *v13; // r2@14
  int v14; // r3@19
  __int16 *v15; // r2@20
  int v16; // r2@26
  int v17; // r10@29
  int v18; // r2@30
  __int16 *v19; // r10@31
  int v20; // r3@34
  __int16 *v21; // r2@35
  int v22; // r3@50
  __int16 *v23; // r2@51

  v2 = a2;
  v3 = a1;
  if ( dword_2A5EC << 31 < 0 )
  {
    v4 = 1;
    if ( a2 != 0xFFFF )
      goto LABEL_5;
LABEL_44:
    v5 = 1048560;
    v6 = (unsigned __int16)word_29074;
    if ( v4 )
      goto LABEL_6;
    goto LABEL_45;
  }
  if ( _cxa_guard_acquire(&dword_2A5EC) )
  {
    word_29074 = -1;
    word_29076 = -1;
    word_29078 = -1;
    _cxa_guard_release(&dword_2A5EC);
  }
  v4 = dword_2A5EC & 1;
  if ( v2 == 0xFFFF )
    goto LABEL_44;
LABEL_5:
  v5 = 16 * v2;
  v6 = *(_WORD *)(*(_DWORD *)(v3 + 4) + 16 * v2);
  if ( v4 )
    goto LABEL_6;
LABEL_45:
  if ( _cxa_guard_acquire(&dword_2A5EC) )
  {
    word_29074 = -1;
    word_29076 = -1;
    word_29078 = -1;
    _cxa_guard_release(&dword_2A5EC);
  }
LABEL_6:
  if ( v6 == 0xFFFF )
  {
    v8 = 1048560;
    v7 = *(_DWORD *)(v3 + 4);
    v9 = &word_29074;
  }
  else
  {
    v7 = *(_DWORD *)(v3 + 4);
    v8 = 16 * v6;
    v9 = (__int16 *)(v7 + 16 * v6);
  }
  *(_WORD *)(v7 + v5) = v9[1];
  result = dword_2A5EC << 31;
  if ( !(dword_2A5EC & 1) )
  {
    result = _cxa_guard_acquire(&dword_2A5EC);
    if ( result )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      result = _cxa_guard_release(&dword_2A5EC);
    }
  }
  if ( v6 == 0xFFFF )
    v11 = &word_29074;
  else
    v11 = (__int16 *)(*(_DWORD *)(v3 + 4) + v8);
  if ( (unsigned __int16)v11[1] != 0xFFFF )
  {
    if ( !(dword_2A5EC & 1) )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v12 = *(_DWORD *)(v3 + 4);
    if ( v6 == 0xFFFF )
      v13 = &word_29074;
    else
      v13 = (__int16 *)(v12 + v8);
    *(_WORD *)(v12 + 16 * (unsigned __int16)v13[1] + 4) = v2;
  }
  if ( v6 != 0xFFFF )
  {
    if ( !(dword_2A5EC & 1) )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v14 = *(_DWORD *)(v3 + 4);
    if ( v2 == 0xFFFF )
      v15 = &word_29074;
    else
      v15 = (__int16 *)(v14 + v5);
    *(_WORD *)(v14 + v8 + 4) = v15[2];
  }
  if ( *(_WORD *)(v3 + 16) == v2 )
  {
    *(_WORD *)(v3 + 16) = v6;
    goto LABEL_38;
  }
  if ( dword_2A5EC << 31 >= 0 )
  {
    result = _cxa_guard_acquire(&dword_2A5EC);
    if ( result )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      result = _cxa_guard_release(&dword_2A5EC);
    }
    v16 = dword_2A5EC & 1;
    if ( v2 != 0xFFFF )
    {
LABEL_29:
      v17 = *(_WORD *)(*(_DWORD *)(v3 + 4) + v5 + 4);
      if ( v16 )
        goto LABEL_30;
LABEL_63:
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
      v18 = dword_2A5EC & 1;
      if ( v17 != 0xFFFF )
        goto LABEL_31;
      goto LABEL_66;
    }
  }
  else
  {
    v16 = 1;
    if ( v2 != 0xFFFF )
      goto LABEL_29;
  }
  v17 = (unsigned __int16)word_29078;
  if ( !v16 )
    goto LABEL_63;
LABEL_30:
  v18 = 1;
  if ( v17 != 0xFFFF )
  {
LABEL_31:
    v19 = (__int16 *)(*(_DWORD *)(v3 + 4) + 16 * v17);
    goto LABEL_32;
  }
LABEL_66:
  v19 = &word_29074;
LABEL_32:
  if ( (unsigned __int16)v19[1] == v2 )
  {
    if ( !v18 )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v20 = *(_DWORD *)(v3 + 4);
    if ( v2 == 0xFFFF )
      v21 = &word_29074;
    else
      v21 = (__int16 *)(v20 + v5);
    *(_WORD *)(v20 + 16 * (unsigned __int16)v21[2] + 2) = v6;
  }
  else
  {
    if ( !v18 )
    {
      result = _cxa_guard_acquire(&dword_2A5EC);
      if ( result )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        result = _cxa_guard_release(&dword_2A5EC);
      }
    }
    v22 = *(_DWORD *)(v3 + 4);
    if ( v2 == 0xFFFF )
      v23 = &word_29074;
    else
      v23 = (__int16 *)(v22 + v5);
    *(_WORD *)(v22 + 16 * (unsigned __int16)v23[2]) = v6;
  }
LABEL_38:
  *(_WORD *)(*(_DWORD *)(v3 + 4) + v8 + 2) = v2;
  if ( v2 != 0xFFFF )
    *(_WORD *)(v5 + *(_DWORD *)(v3 + 4) + 4) = v6;
  return result;
}
// 19034: could not find valid save-restore pair for r4
// 19034: could not find valid save-restore pair for r5
// 19034: could not find valid save-restore pair for r6
// 19034: could not find valid save-restore pair for r7
// 19034: could not find valid save-restore pair for r8
// 19034: could not find valid save-restore pair for r9
// 19034: could not find valid save-restore pair for r10
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00019404) --------------------------------------------------------
void __fastcall sub_19404(int a1, int a2)
{
  int v2; // r5@0
  int v3; // r6@1
  int v4; // r4@1
  int v5; // r3@2
  int v6; // r2@4
  __int16 *v7; // r3@7
  int v8; // r5@11
  signed int v9; // r3@12
  bool v10; // zf@12
  int v11; // r2@21
  int v12; // r5@24
  int v13; // r2@25
  __int16 *v14; // r3@26
  int v15; // r9@27
  int v16; // r2@28
  __int16 *v17; // r3@29
  int v18; // r10@30
  int v19; // r2@31
  __int16 *v20; // r3@32
  int v21; // r2@35
  __int16 *v22; // r3@36
  int v23; // r10@37
  __int16 *v24; // r3@39
  __int16 v25; // r2@40
  int v26; // r2@43
  __int16 *v27; // r3@46
  int v28; // r3@49
  int v29; // r10@52
  __int16 *v30; // r10@54
  int v31; // r3@56
  int v32; // r3@87
  int v33; // r10@90
  int v34; // r3@93
  int v35; // r2@103
  __int16 *v36; // r3@106
  int v37; // r6@107
  int v38; // r3@108
  __int16 *v39; // r2@109
  int v40; // r2@127
  __int16 *v41; // r3@130
  int v42; // r6@131
  int v43; // r3@132
  __int16 *v44; // r2@133
  int v45; // [sp+20h] [bp+20h]@1

  v45 = v2;
  v3 = a2;
  v4 = a1;
  while ( 1 )
  {
    v5 = *(_WORD *)(v4 + 16);
    if ( v3 == v5 )
      goto LABEL_19;
    if ( dword_2A5EC << 31 >= 0 )
    {
      if ( _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v6 = dword_2A5EC & 1;
    }
    else
    {
      v6 = 1;
    }
    if ( v3 == 0xFFFF )
      v7 = &word_29074;
    else
      v7 = *(__int16 **)(v4 + 4);
    if ( v3 != 0xFFFF )
      v7 += 8 * v3;
    v8 = (unsigned __int16)v7[2];
    if ( !v6 && _cxa_guard_acquire(&dword_2A5EC) )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      _cxa_guard_release(&dword_2A5EC);
    }
    v9 = 0xFFFF;
    v10 = v8 == 0xFFFF;
    if ( v8 == 0xFFFF )
      v8 = (int)&word_29074;
    else
      v9 = *(_DWORD *)(v4 + 4);
    if ( !v10 )
      v8 = v9 + 16 * v8;
    if ( *(_WORD *)(v8 + 6) )
    {
      v5 = *(_WORD *)(v4 + 16);
LABEL_19:
      *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v5 + 6) = 1;
      JUMPOUT(__CS__, v45);
    }
    if ( dword_2A5EC << 31 >= 0 )
    {
      if ( _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v11 = dword_2A5EC & 1;
      if ( v3 != 0xFFFF )
      {
LABEL_24:
        v12 = *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v3 + 4);
        if ( v11 )
          goto LABEL_25;
        goto LABEL_70;
      }
    }
    else
    {
      v11 = 1;
      if ( v3 != 0xFFFF )
        goto LABEL_24;
    }
    v12 = (unsigned __int16)word_29078;
    if ( v11 )
    {
LABEL_25:
      v13 = 1;
      if ( v12 != 0xFFFF )
        goto LABEL_26;
      goto LABEL_73;
    }
LABEL_70:
    if ( _cxa_guard_acquire(&dword_2A5EC) )
    {
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      _cxa_guard_release(&dword_2A5EC);
    }
    v13 = dword_2A5EC & 1;
    if ( v12 != 0xFFFF )
    {
LABEL_26:
      v14 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v12);
      goto LABEL_27;
    }
LABEL_73:
    v14 = &word_29074;
LABEL_27:
    v15 = (unsigned __int16)v14[2];
    if ( v13 )
    {
      v16 = 1;
      if ( v12 != 0xFFFF )
        goto LABEL_29;
    }
    else
    {
      if ( _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v16 = dword_2A5EC & 1;
      if ( v12 != 0xFFFF )
      {
LABEL_29:
        v17 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v12);
        goto LABEL_30;
      }
    }
    v17 = &word_29074;
LABEL_30:
    v18 = (unsigned __int16)v17[2];
    if ( v16 )
    {
      v19 = 1;
      if ( v18 == 0xFFFF )
        goto LABEL_61;
    }
    else
    {
      if ( _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v19 = dword_2A5EC & 1;
      if ( v18 == 0xFFFF )
      {
LABEL_61:
        v20 = &word_29074;
        goto LABEL_33;
      }
    }
    v20 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v18);
LABEL_33:
    if ( (unsigned __int16)*v20 == v12 )
    {
      if ( v19 )
      {
        v21 = 1;
        if ( v15 == 0xFFFF )
          goto LABEL_101;
      }
      else
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v21 = dword_2A5EC & 1;
        if ( v15 == 0xFFFF )
        {
LABEL_101:
          v22 = &word_29074;
          goto LABEL_37;
        }
      }
      v22 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v15);
LABEL_37:
      v23 = (unsigned __int16)v22[1];
      if ( v21 || !_cxa_guard_acquire(&dword_2A5EC) )
      {
        if ( v23 != 0xFFFF )
          goto LABEL_39;
      }
      else
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
        if ( v23 != 0xFFFF )
        {
LABEL_39:
          v24 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v23);
          goto LABEL_40;
        }
      }
      v24 = &word_29074;
LABEL_40:
      v25 = v24[3];
      if ( !v24[3] )
        goto LABEL_41;
      if ( dword_2A5EC << 31 >= 0 )
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v32 = dword_2A5EC & 1;
        if ( v3 != 0xFFFF )
        {
LABEL_90:
          v33 = *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v3 + 4);
          if ( v32 )
            goto LABEL_91;
          goto LABEL_123;
        }
      }
      else
      {
        v32 = 1;
        if ( v3 != 0xFFFF )
          goto LABEL_90;
      }
      v33 = (unsigned __int16)word_29078;
      if ( v32 )
        goto LABEL_91;
LABEL_123:
      if ( !_cxa_guard_acquire(&dword_2A5EC) )
      {
LABEL_91:
        if ( v33 != 0xFFFF )
          goto LABEL_92;
        goto LABEL_125;
      }
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      _cxa_guard_release(&dword_2A5EC);
      if ( v33 != 0xFFFF )
      {
LABEL_92:
        if ( *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v33 + 2) != v3 )
          goto LABEL_93;
        goto LABEL_126;
      }
LABEL_125:
      if ( (unsigned __int16)word_29076 != v3 )
      {
LABEL_93:
        v34 = *(_DWORD *)(v4 + 4) + 16 * v12;
        goto LABEL_94;
      }
LABEL_126:
      sub_18C64(v4, v12);
      if ( dword_2A5EC << 31 >= 0 )
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v40 = dword_2A5EC & 1;
      }
      else
      {
        v40 = 1;
      }
      if ( v12 == 0xFFFF )
        v41 = &word_29074;
      else
        v41 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v12);
      v42 = (unsigned __int16)v41[2];
      if ( !v40 && _cxa_guard_acquire(&dword_2A5EC) )
      {
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
      }
      v43 = *(_DWORD *)(v4 + 4);
      if ( v42 == 0xFFFF )
      {
        v34 = v43 + 1048560;
        v44 = &word_29074;
      }
      else
      {
        v34 = v43 + 16 * v42;
        v44 = (__int16 *)v34;
      }
      v15 = (unsigned __int16)v44[2];
      v3 = v12;
LABEL_94:
      *(_WORD *)(v34 + 6) = 1;
      *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v15 + 6) = 0;
      sub_19034(v4, v15);
    }
    else
    {
      if ( v19 )
      {
        v26 = 1;
        if ( v15 != 0xFFFF )
          goto LABEL_44;
      }
      else
      {
        if ( _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v26 = dword_2A5EC & 1;
        if ( v15 != 0xFFFF )
        {
LABEL_44:
          v23 = *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v15);
          if ( v26 )
            goto LABEL_45;
          goto LABEL_83;
        }
      }
      v23 = (unsigned __int16)word_29074;
      if ( v26 )
        goto LABEL_45;
LABEL_83:
      if ( !_cxa_guard_acquire(&dword_2A5EC) )
      {
LABEL_45:
        if ( v23 == 0xFFFF )
          goto LABEL_85;
        goto LABEL_46;
      }
      word_29074 = -1;
      word_29076 = -1;
      word_29078 = -1;
      _cxa_guard_release(&dword_2A5EC);
      if ( v23 == 0xFFFF )
      {
LABEL_85:
        v27 = &word_29074;
        goto LABEL_47;
      }
LABEL_46:
      v27 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v23);
LABEL_47:
      v25 = v27[3];
      if ( v27[3] )
      {
        if ( dword_2A5EC << 31 >= 0 )
        {
          if ( _cxa_guard_acquire(&dword_2A5EC) )
          {
            word_29074 = -1;
            word_29076 = -1;
            word_29078 = -1;
            _cxa_guard_release(&dword_2A5EC);
          }
          v28 = dword_2A5EC & 1;
          if ( v3 != 0xFFFF )
          {
LABEL_52:
            v29 = *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v3 + 4);
            if ( v28 )
              goto LABEL_53;
            goto LABEL_116;
          }
        }
        else
        {
          v28 = 1;
          if ( v3 != 0xFFFF )
            goto LABEL_52;
        }
        v29 = (unsigned __int16)word_29078;
        if ( v28 )
          goto LABEL_53;
LABEL_116:
        if ( !_cxa_guard_acquire(&dword_2A5EC) )
        {
LABEL_53:
          if ( v29 != 0xFFFF )
            goto LABEL_54;
          goto LABEL_118;
        }
        word_29074 = -1;
        word_29076 = -1;
        word_29078 = -1;
        _cxa_guard_release(&dword_2A5EC);
        if ( v29 != 0xFFFF )
        {
LABEL_54:
          v30 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v29);
          goto LABEL_55;
        }
LABEL_118:
        v30 = &word_29074;
LABEL_55:
        if ( (unsigned __int16)*v30 == v3 )
        {
          sub_19034(v4, v12);
          if ( dword_2A5EC << 31 >= 0 )
          {
            if ( _cxa_guard_acquire(&dword_2A5EC) )
            {
              word_29074 = -1;
              word_29076 = -1;
              word_29078 = -1;
              _cxa_guard_release(&dword_2A5EC);
            }
            v35 = dword_2A5EC & 1;
          }
          else
          {
            v35 = 1;
          }
          if ( v12 == 0xFFFF )
            v36 = &word_29074;
          else
            v36 = (__int16 *)(*(_DWORD *)(v4 + 4) + 16 * v12);
          v37 = (unsigned __int16)v36[2];
          if ( !v35 && _cxa_guard_acquire(&dword_2A5EC) )
          {
            word_29074 = -1;
            word_29076 = -1;
            word_29078 = -1;
            _cxa_guard_release(&dword_2A5EC);
          }
          v38 = *(_DWORD *)(v4 + 4);
          if ( v37 == 0xFFFF )
          {
            v31 = v38 + 1048560;
            v39 = &word_29074;
          }
          else
          {
            v31 = v38 + 16 * v37;
            v39 = (__int16 *)v31;
          }
          v15 = (unsigned __int16)v39[2];
          v3 = v12;
        }
        else
        {
          v31 = *(_DWORD *)(v4 + 4) + 16 * v12;
        }
        *(_WORD *)(v31 + 6) = 1;
        *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v15 + 6) = 0;
        sub_18C64(v4, v15);
      }
      else
      {
LABEL_41:
        v3 = v15;
        *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v12 + 6) = 1;
        *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v23 + 6) = 1;
        *(_WORD *)(*(_DWORD *)(v4 + 4) + 16 * v15 + 6) = v25;
      }
    }
  }
}
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00019BF4) --------------------------------------------------------
void __fastcall sub_19BF4(int a1, int a2, int a3, int a4)
{
  int v4; // r7@0
  int v5; // r6@1
  int v6; // r10@1
  int v7; // r4@1
  int v8; // r2@4
  int v9; // r1@4
  int v10; // r11@6
  int v11; // r5@9
  int v12; // r3@10
  int v13; // r8@10
  int v14; // r1@10
  int v15; // r2@15
  unsigned int v16; // r0@23
  unsigned int v17; // r1@23
  unsigned int v18; // r0@24
  int v19; // r0@25
  unsigned int v20; // r8@25
  unsigned int v21; // r0@30
  unsigned int v22; // r1@30
  unsigned int v23; // r0@35
  int v24; // [sp+4h] [bp+4h]@30

  v5 = a2;
  v6 = a1;
  v7 = *(_WORD *)(a1 + 16);
  if ( v7 != 0xFFFF )
  {
    while ( 1 )
    {
      v10 = 16 * v7;
      if ( (*(int (__fastcall **)(int, int))v6)(v5, *(_DWORD *)(v6 + 4) + 16 * v7 + 8) )
      {
        if ( !(dword_2A5EC & 1) && _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v8 = 1;
        v9 = *(_WORD *)(*(_DWORD *)(v6 + 4) + v10);
        if ( v9 == 0xFFFF )
          goto LABEL_9;
      }
      else
      {
        a4 = dword_2A5EC << 31;
        if ( !(dword_2A5EC & 1) && _cxa_guard_acquire(&dword_2A5EC) )
        {
          word_29074 = -1;
          word_29076 = -1;
          word_29078 = -1;
          _cxa_guard_release(&dword_2A5EC);
        }
        v8 = 0;
        v9 = *(_WORD *)(*(_DWORD *)(v6 + 4) + v10 + 2);
        if ( v9 == 0xFFFF )
          goto LABEL_9;
      }
      v7 = v9;
    }
  }
  v8 = 0;
LABEL_9:
  v11 = *(_WORD *)(v6 + 20);
  if ( v11 != 0xFFFF )
  {
    v12 = *(_DWORD *)(v6 + 4);
    v13 = 16 * v11;
    v14 = v12 + 16 * v11;
    *(_WORD *)(v6 + 20) = *(_WORD *)(v14 + 2);
    goto LABEL_11;
  }
  v16 = *(_WORD *)(v6 + 22);
  v17 = *(_DWORD *)(v6 + 8);
  if ( v16 >= v17 )
  {
    v20 = 0;
    v19 = 0;
    if ( !v17 )
      goto LABEL_30;
  }
  else
  {
    v18 = (unsigned __int16)(v16 + 1);
    if ( v17 > v18 )
    {
LABEL_32:
      v13 = 16 * v18;
      v11 = v18;
      goto LABEL_28;
    }
    v19 = *(_WORD *)(v6 + 20);
    v20 = *(_WORD *)(v6 + 20);
  }
  if ( v17 > v20 )
  {
    v13 = 16 * v20;
    v11 = v19;
LABEL_28:
    v12 = *(_DWORD *)(v6 + 4);
    *(_WORD *)(v6 + 22) = v11;
    v14 = v12 + v13;
LABEL_11:
    *(_DWORD *)(v6 + 24) = v12;
    *(_WORD *)(v14 + 4) = v7;
    *(_WORD *)(v14 + 2) = -1;
    *(_WORD *)v14 = -1;
    *(_WORD *)(v14 + 6) = 0;
    if ( v7 == 0xFFFF )
    {
      *(_WORD *)(v6 + 16) = v11;
    }
    else if ( v8 )
    {
      *(_WORD *)(*(_DWORD *)(v6 + 4) + 16 * v7) = v11;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v6 + 4) + 16 * v7 + 2) = v11;
    }
    sub_19404(v6, v11);
    v15 = *(_DWORD *)(v6 + 4) + v13;
    ++*(_WORD *)(v6 + 18);
    if ( v15 != -8 )
    {
      *(_DWORD *)(v15 + 8) = *(_DWORD *)v5;
      *(_DWORD *)(v15 + 12) = *(_DWORD *)(v5 + 4);
    }
    JUMPOUT(__CS__, v4);
  }
LABEL_30:
  v24 = v8;
  sub_18BE4((void *)(v6 + 4), 1, v8, a4);
  v21 = *(_WORD *)(v6 + 22);
  v22 = *(_DWORD *)(v6 + 8);
  v8 = v24;
  if ( v21 >= v22 )
  {
    if ( !v22 )
    {
      v13 = 1048560;
      goto LABEL_39;
    }
    v13 = 0;
    v23 = 0;
    v11 = 0;
  }
  else
  {
    v18 = (unsigned __int16)(v21 + 1);
    if ( v22 > v18 )
      goto LABEL_32;
    v13 = 1048560;
    v23 = 0xFFFF;
  }
  if ( v22 > v23 )
    goto LABEL_28;
LABEL_39:
  ((void (__fastcall *)(const char *))Error)("CUtlRBTree overflow!\n");
  v8 = v24;
  goto LABEL_28;
}
// 3BE0: invalid function type has been ignored
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 29074: using guessed type __int16 word_29074;
// 29076: using guessed type __int16 word_29076;
// 29078: using guessed type __int16 word_29078;
// 2A5EC: using guessed type int dword_2A5EC;

//----- (00019DF8) --------------------------------------------------------
void __fastcall sub_19DF8(int a1, const char *a2, int *a3)
{
  int v3; // lr@0
  int *v4; // r5@1
  int v5; // r4@1
  char *v6; // r0@1
  int v7; // r3@1
  int v8; // r2@1
  char *v9; // [sp+0h] [bp+0h]@1
  int v10; // [sp+4h] [bp+4h]@1
  int v11; // [sp+14h] [bp+14h]@1

  v11 = v3;
  v4 = a3;
  v5 = a1;
  v6 = strdup(a2);
  v7 = *v4;
  v9 = v6;
  v10 = v7;
  sub_19BF4(v5, (int)&v9, v8, v7);
}

//----- (00019E2C) --------------------------------------------------------
int __fastcall sub_19E2C(int result)
{
  *(_DWORD *)(result + 80) = 0;
  return result;
}

//----- (00019E40) --------------------------------------------------------
signed int sub_19E40()
{
  return 1;
}

//----- (00019E50) --------------------------------------------------------
void sub_19E50()
{
  ;
}

//----- (00019E60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
signed int __fastcall sub_19E60(int a1)
{
  int v1; // r4@0
  int v2; // r5@0 OVERLAPPED
  int v4; // r7@0
  int v5; // lr@0
  int v6; // r4@1
  signed int result; // r0@2
  int v8; // r0@4
  int v9; // r0@4
  int v10; // r2@4
  int v11; // r3@4
  int v12; // r0@4
  int v13; // r0@4
  int v14; // r6@4
  int v15; // [sp+4h] [bp+4h]@1
  int v16; // [sp+10Ch] [bp+10Ch]@1
  __int64 v17; // [sp+110h] [bp+110h]@1
  int v18; // [sp+118h] [bp+118h]@1
  int v19; // [sp+11Ch] [bp+11Ch]@1

  v18 = v4;
  v19 = v5;
  v17 = *(_QWORD *)&v2;
  v16 = v1;
  v6 = a1;
  sub_4F0C(2);
  if ( sub_4E60((char *)&v15, 0x104u, (_BYTE *)(v6 + 88)) )
  {
    result = 0;
  }
  else
  {
    v8 = VStdLib_GetICVarFactory();
    v9 = sub_18638(v6, v8);
    sub_186F4(v6, v9, "VEngineCvar004");
    v12 = sub_184F4(v6, (const char *)&v15, v10, v11);
    v13 = sub_186F4(v6, v12, "VFileSystem022");
    v14 = v13;
    *(_DWORD *)(v6 + 80) = v13;
    result = 1;
    if ( !v14 )
    {
      ((void (*)(const char *, ...))Error)("Unable to load %s", &v15);
      result = 0;
    }
  }
  return result;
}
// 3BE0: invalid function type has been ignored
// 19E60: could not find valid save-restore pair for r4
// 19E60: could not find valid save-restore pair for r5
// 19E60: could not find valid save-restore pair for r6
// 19E60: could not find valid save-restore pair for r7
// 19E60: variables would overlap: r5.4 and r5.8
// 19E60: variables would overlap: r6.4 and r5.8
// 36CC: using guessed type int VStdLib_GetICVarFactory(void);

//----- (00019EF0) --------------------------------------------------------
signed int __fastcall sub_19EF0(int a1, int a2, int a3, int a4)
{
  int v4; // ST00_4@1
  int v5; // r4@1
  int v6; // r1@1
  int v7; // r2@1

  v4 = a4;
  v5 = a1;
  sub_18168(*(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 80), a1);
  return sub_184A4(*(_DWORD *)(v5 + 84), v6, v7, v4);
}
// 19EF0: could not find valid save-restore pair for r4
// 19EF0: could not find valid save-restore pair for r7

//----- (00019F1C) --------------------------------------------------------
int sub_19F1C()
{
  return dword_2DF08;
}
// 2DF08: using guessed type int dword_2DF08;

//----- (00019FAC) --------------------------------------------------------
int __fastcall sub_19FAC(int a1, int a2, int a3, int a4)
{
  __int64 v4; // r4@0
  int v5; // lr@0
  int v6; // r5@1
  int v7; // r4@1
  int result; // r0@1
  __int64 v9; // [sp+0h] [bp+0h]@1
  __int64 *v10; // [sp+8h] [bp+8h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  v9 = v4;
  v6 = a2;
  v10 = &v9;
  v11 = v5;
  v7 = a1;
  sub_17E6C(a1, 0, a3, a4);
  *(_DWORD *)(v7 + 84) = v6;
  result = v7;
  *(_DWORD *)(v7 + 80) = 0;
  *(_DWORD *)v7 = &off_289C8;
  return result;
}
// 19FAC: could not find valid save-restore pair for r4
// 19FAC: could not find valid save-restore pair for r5
// 19FAC: could not find valid save-restore pair for r7
// 289C8: using guessed type void *;

//----- (00019FD8) --------------------------------------------------------
int __fastcall sub_19FD8(int a1, int a2, int a3, int a4)
{
  __int64 v4; // r4@0
  int v5; // lr@0
  int v6; // r4@1
  signed int v7; // r5@1
  int result; // r0@2
  int v9; // [sp+0h] [bp+0h]@1
  int *v10; // [sp+8h] [bp+8h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  v10 = &v9;
  v11 = v5;
  *(_QWORD *)&v9 = v4;
  v6 = a1;
  v7 = sub_183F8(a1, a2, a3, a4);
  if ( sub_18110(v6) == 8 )
  {
    if ( sub_4DC0(*(_DWORD *)(v6 + 80)) )
    {
      result = 0;
    }
    else
    {
      sub_18168(*(_DWORD *)(v6 + 84), *(_DWORD *)(v6 + 80), v6);
      result = (*(int (**)(void))(**(_DWORD **)(v6 + 84) + 20))();
    }
  }
  else
  {
    result = v7;
  }
  return result;
}
// 19FD8: could not find valid save-restore pair for r4
// 19FD8: could not find valid save-restore pair for r5
// 19FD8: could not find valid save-restore pair for r7

//----- (0001A01C) --------------------------------------------------------
int __fastcall sub_1A01C(int a1, int a2, int a3, int a4)
{
  int v4; // ST00_4@1
  int v5; // r4@1
  int v6; // r1@1
  int v7; // r2@1

  v4 = a4;
  v5 = a1;
  (*(void (__cdecl **)(_DWORD, int, int, _DWORD))(**(_DWORD **)(a1 + 84) + 24))(
    *(_DWORD *)(a1 + 84),
    a2,
    a3,
    *(_DWORD *)(**(_DWORD **)(a1 + 84) + 24));
  return sub_184E4(v5, v6, v7, v4);
}
// 1A01C: could not find valid save-restore pair for r4
// 1A01C: could not find valid save-restore pair for r7

//----- (0001A044) --------------------------------------------------------
signed int sub_1A044()
{
  return 1;
}

//----- (0001A054) --------------------------------------------------------
void sub_1A054()
{
  ;
}

//----- (0001A064) --------------------------------------------------------
int __fastcall sub_1A064(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(a1 + 4);
}

//----- (0001A074) --------------------------------------------------------
int __fastcall sub_1A074(int result, int a2)
{
  int v2; // r3@1
  int *v3; // [sp+0h] [bp+0h]@1

  v2 = *(_BYTE *)(result + 25);
  v3 = (int *)&v3;
  if ( !v2 || a2 )
  {
    *(_BYTE *)(result + 24) = a2;
    *(_BYTE *)(result + 25) = 1;
  }
  return result;
}

//----- (0001A090) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_1A090(int result, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r2@1
  int v7; // r4@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v6 = *(_DWORD *)(result + 28);
  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v7 = result;
  if ( v6 != a2 )
  {
    if ( a2 )
      *(_DWORD *)(result + 28) = a2;
    else
      result = (*(int (__cdecl **)(int))(*(_DWORD *)result + 132))(result);
    *(_BYTE *)(v7 + 32) = 1;
  }
  return result;
}
// 1A090: could not find valid save-restore pair for r4
// 1A090: could not find valid save-restore pair for r7
// 1A090: variables would overlap: r3.4 and r3.8
// 1A090: variables would overlap: r4.4 and r3.8

//----- (0001A0BC) --------------------------------------------------------
int __fastcall sub_1A0BC(int result)
{
  int v1; // r3@1
  int *v2; // [sp+0h] [bp+0h]@1

  v1 = *(_DWORD *)(result + 20);
  v2 = (int *)&v2;
  if ( v1 )
    ++*(_DWORD *)(result + 16);
  return result;
}

//----- (0001A0D4) --------------------------------------------------------
int __fastcall sub_1A0D4(int result)
{
  int v1; // lr@0
  int v2; // r2@1
  _DWORD *v3; // [sp+0h] [bp+0h]@1
  int v4; // [sp+4h] [bp+4h]@1

  v2 = *(_DWORD *)(result + 20);
  v3 = &v3;
  v4 = v1;
  if ( v2 )
    result = (*(int (**)(void))(*(_DWORD *)result + 28))();
  return result;
}
// 1A0D4: could not find valid save-restore pair for r7

//----- (0001A0E8) --------------------------------------------------------
int __fastcall sub_1A0E8(int result, _DWORD *a2, _DWORD *a3)
{
  *a2 = *(_DWORD *)(result + 40);
  *a3 = *(_DWORD *)(result + 44);
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

//----- (0001A108) --------------------------------------------------------
int __fastcall sub_1A108(int result, _DWORD *a2, _DWORD *a3, int a4)
{
  int *v4; // [sp+0h] [bp+0h]@1

  v4 = (int *)&v4;
  if ( a4 )
  {
    *(_DWORD *)(result + 56) = *a2;
    *(_DWORD *)(result + 60) = *a3;
  }
  else
  {
    *a2 = *(_DWORD *)(result + 56);
    *a3 = *(_DWORD *)(result + 60);
  }
  return result;
}

//----- (0001A130) --------------------------------------------------------
void sub_1A130()
{
  ;
}

//----- (0001A140) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__fastcall sub_1A140(char *result, _DWORD *a2, _DWORD *a3, void *a4)
{
  int v5; // lr@0
  void *v6; // r4@1
  int v7; // r0@6
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a4;
  if ( a2 )
    *a2 = result + 100;
  if ( a3 )
    *a3 = *((_DWORD *)result + 57);
  if ( a4 )
  {
    v7 = (*(int (__cdecl **)(char *))(*(_DWORD *)result + 108))(result);
    result = (char *)memcpy(v6, (const void *)(v7 + 4), 0x104u);
  }
  return result;
}
// 1A140: could not find valid save-restore pair for r4
// 1A140: could not find valid save-restore pair for r7
// 1A140: variables would overlap: r3.4 and r3.8
// 1A140: variables would overlap: r4.4 and r3.8

//----- (0001A1B8) --------------------------------------------------------
void sub_1A1B8()
{
  ;
}

//----- (0001A1C8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_1A1C8(_DWORD **a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  _DWORD **v6; // r4@1
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  ((void (__cdecl *)(_DWORD **, int, int, _DWORD))**a1)(a1, a2, a3, **a1);
  return ((int (__fastcall *)(_DWORD **, _DWORD))(*v6)[1])(v6, 0);
}
// 1A1C8: could not find valid save-restore pair for r4
// 1A1C8: could not find valid save-restore pair for r7
// 1A1C8: variables would overlap: r3.4 and r3.8
// 1A1C8: variables would overlap: r4.4 and r3.8

//----- (0001A1E8) --------------------------------------------------------
signed int sub_1A1E8()
{
  return 1;
}

//----- (0001A1F8) --------------------------------------------------------
signed int sub_1A1F8()
{
  return 1;
}

//----- (0001A208) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_BOOL4 __fastcall sub_1A208(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v7; // [sp+0h] [bp+0h]@1
  int *v8; // [sp+8h] [bp+8h]@1
  int v9; // [sp+Ch] [bp+Ch]@1

  v8 = &v7;
  v9 = v5;
  *(_QWORD *)&v7 = *(_QWORD *)&a4;
  return (*(int (__cdecl **)(int, int, int, _DWORD))(*(_DWORD *)a1 + 20))(a1, a2, a3, *(_DWORD *)(*(_DWORD *)a1 + 20)) > a2;
}
// 1A208: could not find valid save-restore pair for r4
// 1A208: could not find valid save-restore pair for r7
// 1A208: variables would overlap: r3.4 and r3.8
// 1A208: variables would overlap: r4.4 and r3.8

//----- (0001A228) --------------------------------------------------------
void sub_1A228()
{
  ;
}

//----- (0001A238) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __fastcall sub_1A238(int a1, _BYTE *a2, int a3, unsigned int a4)
{
  int v5; // r5@0 OVERLAPPED
  unsigned int v7; // r8@1
  int v8; // r9@1
  int v9; // r6@1
  _BYTE *v10; // r4@1
  int v11; // r1@1
  unsigned int v12; // r0@3
  int v13; // r3@3
  unsigned int v14; // r5@3
  unsigned int result; // r0@10
  __int64 v16; // [sp+0h] [bp+0h]@1
  __int64 v17; // [sp+8h] [bp+8h]@1

  v7 = a4;
  v8 = a3;
  v17 = *(_QWORD *)&v5;
  v9 = a1;
  v16 = *(_QWORD *)&a4;
  v10 = a2;
  v11 = *a2;
  if ( !v11 && !a3 )
    return 0;
  v12 = SDL_GL_GetProcAddress(a1, v11, a3, a4, v16, HIDWORD(v16), v17, HIDWORD(v17));
  v13 = 1 - v12;
  v14 = v12;
  if ( v12 > 1 )
    v13 = 0;
  if ( !v7 )
    v13 = 0;
  if ( !v13 )
  {
    if ( !*v10 || !v12 )
      goto LABEL_9;
LABEL_13:
    result = v14;
    *v10 = 1;
    return result;
  }
  v14 = v7;
  if ( *v10 )
    goto LABEL_13;
LABEL_9:
  *v10 = 0;
  if ( v8 )
  {
    ((void (*)(const char *, ...))Error)(
      "Could not find required OpenGL entry point '%s'! Either your video card is unsupported, or your OpenGL driver need"
      "s to be updated.\n",
      v9);
    result = v14;
  }
  else
  {
    result = v14;
  }
  return result;
}
// 3BE0: invalid function type has been ignored
// 1A238: could not find valid save-restore pair for r4
// 1A238: could not find valid save-restore pair for r5
// 1A238: could not find valid save-restore pair for r6
// 1A238: could not find valid save-restore pair for r7
// 1A238: could not find valid save-restore pair for r8
// 1A238: variables would overlap: r3.4 and r3.8
// 1A238: variables would overlap: r4.4 and r3.8
// 1A238: variables would overlap: r5.4 and r5.8
// 1A238: variables would overlap: r6.4 and r5.8
// 3898: using guessed type int __cdecl SDL_GL_GetProcAddress(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001A2B8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_1A2B8(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r5@1
  int result; // r0@2
  int v10; // r0@3
  int v11; // r6@3
  int v12; // [sp+0h] [bp+0h]@1
  __int64 v13; // [sp+8h] [bp+8h]@1
  int *v14; // [sp+10h] [bp+10h]@1
  int v15; // [sp+14h] [bp+14h]@1

  v14 = &v12;
  v15 = v7;
  v13 = *(_QWORD *)&v5;
  v8 = a1;
  *(_QWORD *)&v12 = *(_QWORD *)&a4;
  if ( *(_DWORD *)(a1 + 12) )
  {
    result = *(_DWORD *)(a1 + 12);
  }
  else
  {
    v10 = operator new(0x10Cu);
    v11 = v10;
    *(_DWORD *)(v10 + 264) = 0;
    *(_DWORD *)v10 = &off_28AE0;
    memset((void *)(v10 + 4), 0, 0x104u);
    *(_DWORD *)(v11 + 264) = 0;
    *(_DWORD *)(v8 + 12) = v11;
    (*(void (__fastcall **)(int))(*(_DWORD *)v11 + 8))(v11);
    result = *(_DWORD *)(v8 + 12);
  }
  return result;
}
// 1A2B8: could not find valid save-restore pair for r4
// 1A2B8: could not find valid save-restore pair for r5
// 1A2B8: could not find valid save-restore pair for r6
// 1A2B8: could not find valid save-restore pair for r7
// 1A2B8: variables would overlap: r3.4 and r3.8
// 1A2B8: variables would overlap: r4.4 and r3.8
// 1A2B8: variables would overlap: r5.4 and r5.8
// 1A2B8: variables would overlap: r6.4 and r5.8
// 28AE0: using guessed type void *;

//----- (0001A30C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_1A30C(int a1, const char *a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  int result; // r0@2
  __int64 v8; // [sp+0h] [bp+0h]@1
  __int64 *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v8 = *(_QWORD *)&a4;
  v6 = a1;
  v9 = &v8;
  v10 = v5;
  if ( sub_11A70(a2, "SDLMgrInterface001") )
    result = 0;
  else
    result = v6;
  return result;
}
// 1A30C: could not find valid save-restore pair for r4
// 1A30C: could not find valid save-restore pair for r7
// 1A30C: variables would overlap: r3.4 and r3.8
// 1A30C: variables would overlap: r4.4 and r3.8

//----- (0001A334) --------------------------------------------------------
int __fastcall sub_1A334(int a1)
{
  int v2; // r2@2

  if ( *(_DWORD *)(a1 + 20) )
  {
    v2 = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 16) = 1;
    a1 = (*(int (**)(void))(v2 + 64))();
  }
  SDL_GL_UnloadLibrary(a1);
  return SDL_QuitSubSystem(32);
}
// 1A334: could not find valid save-restore pair for r7
// 3520: using guessed type int __fastcall SDL_QuitSubSystem(_DWORD);
// 36E4: using guessed type int __fastcall SDL_GL_UnloadLibrary(_DWORD);

//----- (0001A35C) --------------------------------------------------------
int __fastcall sub_1A35C(int a1)
{
  int v1; // r6@1
  int v2; // r4@2
  int v3; // r5@2
  int v4; // r0@4

  v1 = a1;
  if ( *(_DWORD *)(a1 + 228) > 0 )
  {
    v2 = a1 + 108;
    v3 = 0;
    do
    {
      v4 = *(_DWORD *)(v2 - 8);
      ++v3;
      v2 += 8;
      SDL_GL_SetAttribute(v4, *(_DWORD *)(v2 - 12));
    }
    while ( *(_DWORD *)(v1 + 228) > v3 );
  }
  return j_SDL_GL_CreateContext(*(_DWORD *)(v1 + 20));
}
// 1A35C: could not find valid save-restore pair for r4
// 1A35C: could not find valid save-restore pair for r7
// 3580: using guessed type int __fastcall SDL_GL_SetAttribute(_DWORD, _DWORD);

//----- (0001A3AC) --------------------------------------------------------
_BOOL4 __fastcall sub_1A3AC(int a1)
{
  int v1; // lr@0
  _DWORD *v3; // [sp+0h] [bp+0h]@1
  int v4; // [sp+4h] [bp+4h]@1

  v3 = &v3;
  v4 = v1;
  return SDL_GL_MakeCurrent(*(_DWORD *)(a1 + 20)) == 0;
}
// 1A3AC: could not find valid save-restore pair for r7
// 3840: using guessed type int __fastcall SDL_GL_MakeCurrent(_DWORD);

//----- (0001A3C4) --------------------------------------------------------
int __fastcall sub_1A3C4(const char *a1, int a2, int a3, int a4)
{
  int v4; // r4@0
  __int64 v5; // r5@0
  int v6; // r7@0
  int v7; // lr@0
  int v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+80Ch] [bp+80Ch]@1
  __int64 v11; // [sp+810h] [bp+810h]@1
  int v12; // [sp+818h] [bp+818h]@1
  int v13; // [sp+81Ch] [bp+81Ch]@1
  const char *varg_r0; // [sp+820h] [bp+820h]@1
  int varg_r1; // [sp+824h] [bp+824h]@1
  int varg_r2; // [sp+828h] [bp+828h]@1
  int varg_r3; // [sp+82Ch] [bp+82Ch]@1

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  v12 = v6;
  v13 = v7;
  v11 = v5;
  v10 = v4;
  sub_12498((char *)&v9, 0x800u, a1, &varg_r1);
  return Plat_DebugString(&v9);
}
// 1A3C4: could not find valid save-restore pair for r4
// 1A3C4: could not find valid save-restore pair for r5
// 1A3C4: could not find valid save-restore pair for r6
// 1A3C4: could not find valid save-restore pair for r7
// 34D8: using guessed type int __fastcall Plat_DebugString(_DWORD);

//----- (0001A410) --------------------------------------------------------
int __fastcall sub_1A410(int result, int a2)
{
  int v2; // r0@2

  if ( *(_DWORD *)(result + 4) != a2 )
  {
    v2 = *(_DWORD *)(result + 20);
    if ( v2 )
      SDL_GL_MakeCurrent(v2);
    result = j_SDL_GL_DeleteContext();
  }
  return result;
}
// 1A410: could not find valid save-restore pair for r4
// 3840: using guessed type int __fastcall SDL_GL_MakeCurrent(_DWORD);

//----- (0001A440) --------------------------------------------------------
int __fastcall sub_1A440(int a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, char a5)
{
  _BYTE *v5; // r11@1
  pthread_mutex_t *v6; // r9@1
  _BYTE *v7; // r10@1
  int v8; // r4@1
  int v9; // lr@1
  int v10; // r12@3
  int v11; // r4@4
  int v12; // r5@4
  int v13; // r8@4
  int v14; // r6@10
  signed int v15; // r3@11
  _BYTE *v17; // [sp+4h] [bp+4h]@1

  v5 = a3;
  v6 = (pthread_mutex_t *)(a1 + 240);
  v7 = a2;
  v8 = a1;
  v17 = a4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 240));
  v9 = v8 + 256;
  if ( !a5 )
    v9 = v8 + 296;
  v10 = *(_DWORD *)(v9 + 24);
  if ( v10 > 0 )
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v14 = *(_DWORD *)v9 + v11;
        if ( *(_DWORD *)v14 )
          goto LABEL_9;
        v15 = *(_DWORD *)(v14 + 4);
        if ( v15 != 41 )
          break;
        ++v12;
        *v7 = 1;
        ++v13;
        *(_DWORD *)v14 = 8;
        v11 += 48;
        if ( v12 == v10 )
          goto LABEL_13;
      }
      if ( v15 <= 41 )
        break;
      if ( v15 == 44 )
      {
        *v17 = 1;
        ++v13;
        *(_DWORD *)v14 = 8;
        goto LABEL_9;
      }
      if ( v15 == 88 )
        goto LABEL_8;
LABEL_9:
      ++v12;
      v11 += 48;
      if ( v12 == v10 )
        goto LABEL_13;
    }
    if ( v15 != 40 )
      goto LABEL_9;
LABEL_8:
    ++v13;
    *v5 = 1;
    *(_DWORD *)v14 = 8;
    goto LABEL_9;
  }
  v13 = 0;
LABEL_13:
  pthread_mutex_unlock(v6);
  return v13;
}
// 1A440: could not find valid save-restore pair for r4
// 1A440: could not find valid save-restore pair for r5
// 1A440: could not find valid save-restore pair for r6
// 1A440: could not find valid save-restore pair for r7
// 1A440: could not find valid save-restore pair for r8
// 1A440: could not find valid save-restore pair for r9
// 1A440: could not find valid save-restore pair for r10
// 1A440: could not find valid save-restore pair for r11

//----- (0001A50C) --------------------------------------------------------
int __fastcall sub_1A50C(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return sub_35CC(*(_DWORD *)(a1 + 20));
}
// 35CC: using guessed type int __fastcall sub_35CC(_DWORD);

//----- (0001BEE4) --------------------------------------------------------
void __fastcall sub_1BEE4(int a1, int a2, signed int a3, signed int a4)
{
  int v4; // lr@0
  int v5; // r5@1
  signed int v6; // r8@1
  signed int v7; // r9@1
  int v8; // r6@1
  int v9; // r10@1
  int v10; // r4@2
  int v11; // r0@4
  int v12; // r0@5
  int v13; // r1@5
  int v14; // r0@7
  int v15; // r0@13
  int v16; // r1@13
  int v17; // r0@13
  int v18; // r2@13
  int v19; // r0@13
  int v20; // r1@13
  int v21; // r0@13
  int v22; // r2@13
  int v23; // r0@15
  int v24; // r1@15
  int v25; // r0@15
  int v26; // r2@15
  int v27; // r3@16
  int v28; // r0@21
  int v29; // r2@21
  int v30; // r3@21
  int v31; // r0@21
  int v32; // r2@21
  int v33; // r3@21
  int v34; // r0@21
  int v35; // r2@21
  int v36; // r3@21
  int v37; // r2@21
  int v38; // r3@21
  _BYTE *v39; // r4@21
  int v40; // r1@22
  int v41; // r2@22
  int v42; // r3@22
  int v43; // r1@23
  int v44; // t1@25
  int v45; // r1@26
  int v46; // r2@26
  int v47; // r3@26
  int v48; // r0@6
  int v49; // r0@8
  int v50; // r1@8
  char v51; // [sp+8h] [bp+0h]@12
  int v52; // [sp+24h] [bp+1Ch]@18
  int v53; // [sp+2Ch] [bp+24h]@1

  v5 = 0;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  v53 = v4;
  v9 = a2;
  *(_BYTE *)(a1 + 34) = 0;
  sub_B330((int)&unk_2E2D8, -1);
  if ( *(_DWORD *)(v8 + 228) > 0 )
  {
    v10 = v8 + 108;
    do
    {
      v11 = *(_DWORD *)(v10 - 8);
      ++v5;
      v10 += 8;
      SDL_GL_SetAttribute(v11, *(_DWORD *)(v10 - 12));
    }
    while ( *(_DWORD *)(v8 + 228) > v5 );
  }
  *(_DWORD *)(v8 + 16) = 1;
  v12 = SDL_CreateWindow(v9);
  *(_DWORD *)(v8 + 20) = v12;
  if ( !v12 )
  {
    v48 = SDL_GetError(0, v13);
    ((void (*)(const char *, ...))Error)("Failed to create SDL window: %s", v48);
    v12 = *(_DWORD *)(v8 + 20);
  }
  SetAssertDialogParent(v12, v13);
  v14 = SDL_GL_CreateContext(*(_DWORD *)(v8 + 20));
  *(_DWORD *)(v8 + 4) = v14;
  if ( !v14 )
  {
    v49 = SDL_GetError(0, 0);
    ((void (*)(const char *, ...))Error)("Failed to create GL context: %s", v49);
    v50 = *(_DWORD *)(v8 + 4);
  }
  SDL_GL_MakeCurrent(*(_DWORD *)(v8 + 20));
  if ( !(dword_2E344 & 1) && _cxa_guard_acquire(&dword_2E344) )
  {
    dword_2E348 = 0;
    v51 = 1;
    dword_2E348 = (int (__fastcall *)(_DWORD))sub_1A238((int)"glGetString", &v51, 1, 0);
    _cxa_guard_release(&dword_2E344);
  }
  if ( !(dword_2E34C & 1) && _cxa_guard_acquire(&dword_2E34C) )
  {
    dword_2E350 = 0;
    v51 = 1;
    dword_2E350 = sub_1A238((int)"glGetIntegerv", &v51, 1, 0);
    _cxa_guard_release(&dword_2E34C);
  }
  dword_2E348(7936);
  dword_2E348(7937);
  dword_2E348(7938);
  v15 = dword_2E348(7939);
  v17 = CommandLine_Tier0(v15, v16);
  v19 = (*(int (__cdecl **)(int, const char *, int))(*(_DWORD *)v17 + 40))(v17, "-gl_debug", v18);
  v21 = CommandLine_Tier0(v19, v20);
  if ( (*(int (__cdecl **)(int, const char *, int))(*(_DWORD *)v21 + 40))(v21, "-regal", v22) )
  {
    SetUseRegal(1);
    SDL_SetRegalMode(1);
  }
  v23 = GetOpenGLEntryPoints(sub_1A238);
  dword_2DF88 = v23;
  v25 = CommandLine_Tier0(v23, v24);
  if ( (*(int (__cdecl **)(int, const char *, int))(*(_DWORD *)v25 + 40))(v25, "-gl_dump_strings", v26) )
  {
    v28 = (*(int (__fastcall **)(signed int))(dword_2DF88 + 284))(7937);
    sub_1A3C4("GL_RENDERER: %s\n", v28, v29, v30);
    v31 = (*(int (__fastcall **)(signed int))(dword_2DF88 + 284))(7936);
    sub_1A3C4("GL_VENDOR: %s\n", v31, v32, v33);
    v34 = (*(int (__fastcall **)(signed int))(dword_2DF88 + 284))(7938);
    sub_1A3C4("GL_VERSION: %s\n", v34, v35, v36);
    v39 = (_BYTE *)(*(int (__fastcall **)(signed int))(dword_2DF88 + 284))(7939);
    if ( v39 )
    {
      sub_1A3C4("GL_EXTENSIONS:%s\n", (int)"", v37, v38);
      v42 = *v39;
      if ( *v39 )
      {
        do
        {
          v43 = (char)v42;
          if ( (char)v42 == 32 )
            v43 = 10;
          sub_1A3C4("%c", v43, v41, v42);
          v44 = (v39++)[1];
          v42 = v44;
        }
        while ( v44 );
      }
      sub_1A3C4("\n", v40, v41, v42);
    }
    else
    {
      sub_1A3C4("GL_EXTENSIONS:%s\n", 0, v37, v38);
    }
    sub_1A3C4("\n", v45, v46, v47);
  }
  (*(void (__fastcall **)(signed int, int))(dword_2DF88 + 548))(1, v8 + 8);
  (*(void (__cdecl **)(_DWORD, _DWORD, signed int))(dword_2DF88 + 420))(0, 0, v7);
  (*(void (__cdecl **)(_DWORD, _DWORD, signed int))(dword_2DF88 + 344))(0, 0, v7);
  (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(dword_2DF88 + 108))(0, 0, 0);
  (*(void (__fastcall **)(signed int))(dword_2DF88 + 104))(0x4000);
  SDL_GL_SwapWindow(*(_DWORD *)(v8 + 20));
  (*(void (__fastcall **)(signed int))(dword_2DF88 + 104))(0x4000);
  SDL_GL_SwapWindow(*(_DWORD *)(v8 + 20));
  (*(void (__fastcall **)(_DWORD))(dword_2DF88 + 104))(0x4000);
  SDL_GL_SwapWindow(*(_DWORD *)(v8 + 20));
  *(_DWORD *)(v8 + 64) = v7;
  *(_DWORD *)(v8 + 68) = v6;
  *(_DWORD *)(v8 + 76) = v7 / 2;
  v27 = v6 / 3;
  *(_DWORD *)(v8 + 80) = v6 / 2;
  if ( v6 / 3 < 200 )
    v27 = 200;
  *(_DWORD *)(v8 + 84) = v27;
  JUMPOUT(__CS__, v52);
}
// 3BE0: invalid function type has been ignored
// 3470: using guessed type int __fastcall SDL_GL_CreateContext(_DWORD);
// 3488: using guessed type int __cdecl SDL_GetError(_DWORD, _DWORD);
// 3580: using guessed type int __fastcall SDL_GL_SetAttribute(_DWORD, _DWORD);
// 3730: using guessed type int __fastcall SetUseRegal(_DWORD);
// 3760: using guessed type int __fastcall SDL_CreateWindow(_DWORD);
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 37D0: using guessed type int __cdecl SetAssertDialogParent(_DWORD, _DWORD);
// 3840: using guessed type int __fastcall SDL_GL_MakeCurrent(_DWORD);
// 3948: using guessed type int __fastcall _cxa_guard_release(_DWORD);
// 3B04: using guessed type int __fastcall SDL_SetRegalMode(_DWORD);
// 3B50: using guessed type int __fastcall SDL_GL_SwapWindow(_DWORD);
// 3BFC: using guessed type int __fastcall GetOpenGLEntryPoints(_DWORD);
// 3C08: using guessed type int __fastcall _cxa_guard_acquire(_DWORD);
// 11F7C: using guessed type int[84];
// 2DF88: using guessed type int dword_2DF88;
// 2E344: using guessed type int dword_2E344;
// 2E348: using guessed type int (__fastcall *dword_2E348)(_DWORD);
// 2E34C: using guessed type int dword_2E34C;
// 2E350: using guessed type int dword_2E350;

//----- (0001C298) --------------------------------------------------------
int __fastcall sub_1C298(int a1)
{
  int v1; // r6@1
  int v2; // r1@1
  int v3; // r0@2
  int v4; // r0@2
  int v5; // r0@2
  int v6; // r1@2
  int v7; // r0@2
  int v8; // r0@2
  int v9; // r1@2
  char v10; // r4@2
  int v15; // r0@3
  int result; // r0@4
  int v17; // r0@5
  int v18; // r1@5
  int v19; // r0@6
  const char *v20; // r4@6
  int v21; // r0@8
  int v22; // r1@8
  int v23; // r0@10
  int v24; // r0@10
  int v25; // r1@10
  int v26; // r0@12
  int v27; // r1@12
  int v28; // r1@15
  int v29; // r0@16
  int v30; // r0@18
  int v31; // r0@21
  int v32; // r0@9

  v1 = a1;
  if ( !SDL_WasInit(32) )
  {
    v17 = CommandLine_Tier0(0, v2);
    if ( (*(int (**)(void))(*(_DWORD *)v17 + 40))() )
    {
      SetUseRegal(1);
      v20 = "libRegal.so";
      SDL_SetRegalMode(1);
    }
    else
    {
      v19 = CommandLine_Tier0(0, v18);
      v20 = (const char *)(*(int (**)(void))(*(_DWORD *)v19 + 40))();
      if ( v20 )
        v20 = "libEGL.so";
    }
    v21 = SDL_Init(32) + 1;
    if ( !v21 )
    {
      v32 = SDL_GetError(0, v22);
      v21 = ((int (*)(const char *, ...))Error)("SDL_Init(SDL_INIT_VIDEO) failed: %s", v32);
    }
    v23 = CommandLine_Tier0(v21, v22);
    v24 = (*(int (**)(void))(*(_DWORD *)v23 + 40))();
    if ( v24 )
      v24 = SDL_GL_SetAttribute(20, 1);
    v26 = CommandLine_Tier0(v24, v25);
    if ( (*(int (**)(void))(*(_DWORD *)v26 + 40))()
      || (v31 = CommandLine_Tier0(0, v27), !(*(int (**)(void))(*(_DWORD *)v31 + 40))()) )
    {
      if ( SDL_GL_SetAttribute(19, 1) == -1 )
        ((void (__fastcall *)(const char *))Error)("Failed to configure SDL for EGL");
    }
    if ( SDL_GL_LoadLibrary(v20) == -1 )
    {
      v29 = SDL_GetError(0, v28);
      ((void (*)(const char *, ...))Error)("SDL_GL_LoadLibrary(NULL) failed: %s", v29);
    }
  }
  v3 = ((int (*)(void))SDL_GetCurrentVideoDriver)();
  v4 = fprintf((FILE *)((char *)&_sF + 168), "SDL video target is '%s'\n", v3);
  SDL_GetCurrentVideoDriver(v4);
  v5 = Msg("SDL video target is '%s'\n");
  *(_BYTE *)(v1 + 36) = 1;
  v7 = CommandLine_Tier0(v5, v6);
  v8 = (*(int (**)(void))(*(_DWORD *)v7 + 40))();
  v10 = v8;
  if ( !v8 )
  {
    v30 = CommandLine_Tier0(0, v9);
    if ( (*(int (**)(void))(*(_DWORD *)v30 + 40))() )
      *(_BYTE *)(v1 + 36) = v10;
  }
  __asm { VMOV.F32        D16, #1.0 }
  *(_BYTE *)(v1 + 37) = 0;
  *(_DWORD *)(v1 + 92) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 96) = -1;
  *(_BYTE *)(v1 + 25) = 0;
  __asm { VSTR            D16, [R6,#0xE8] }
  *(_DWORD *)(v1 + 28) = 0;
  *(_BYTE *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 340) = 0;
  *(_DWORD *)(v1 + 336) = 0;
  *(_DWORD *)(v1 + 344) = 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  *(_BYTE *)(v1 + 34) = 0;
  *(_BYTE *)(v1 + 35) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 44) = 0;
  *(_DWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 52) = 0;
  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)(v1 + 60) = 0;
  *(_DWORD *)(v1 + 64) = 0;
  *(_DWORD *)(v1 + 68) = 0;
  *(_DWORD *)(v1 + 228) = 0;
  *(_BYTE *)(v1 + 348) = 0;
  *(_DWORD *)(v1 + 352) = 0;
  *(_DWORD *)(v1 + 356) = 0;
  *(_DWORD *)(v1 + 360) = 0;
  *(_BYTE *)(v1 + 72) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  *(_BYTE *)(v1 + 33) = 1;
  *(_DWORD *)(v1 + 76) = 0;
  *(_QWORD *)(v1 + 368) = 0LL;
  *(_DWORD *)(v1 + 80) = 0;
  *(_DWORD *)(v1 + 84) = 0;
  *(_BYTE *)(v1 + 88) = 0;
  memset((void *)(v1 + 100), 0, 0x80u);
  *(_DWORD *)(v1 + 108) = 1;
  *(_DWORD *)(v1 + 136) = 1;
  *(_DWORD *)(v1 + 160) = 1;
  *(_DWORD *)(v1 + 104) = 8;
  *(_DWORD *)(v1 + 112) = 8;
  *(_DWORD *)(v1 + 120) = 8;
  *(_DWORD *)(v1 + 128) = 8;
  *(_DWORD *)(v1 + 152) = 8;
  *(_DWORD *)(v1 + 116) = 2;
  *(_DWORD *)(v1 + 228) = (signed int)(((v1 + 164 - (v1 + 100)) >> 2) + ((unsigned int)(v1 + 164 - (v1 + 100)) >> 31)) >> 1;
  *(_DWORD *)(v1 + 124) = 3;
  *(_DWORD *)(v1 + 132) = 5;
  *(_DWORD *)(v1 + 140) = 6;
  *(_DWORD *)(v1 + 144) = 24;
  *(_DWORD *)(v1 + 148) = 7;
  *(_DWORD *)(v1 + 156) = 15;
  sub_1BEE4(v1, (int)"", 640, 480);
  if ( v15 )
  {
    SDL_HideWindow(*(_DWORD *)(v1 + 20));
    result = 0;
  }
  else
  {
    ((void (__fastcall *)(const char *))Error)("CreateGameWindow failed");
    SDL_HideWindow(*(_DWORD *)(v1 + 20));
    result = 0;
  }
  return result;
}
// 3BE0: invalid function type has been ignored
// 1C298: could not find valid save-restore pair for r4
// 1C298: could not find valid save-restore pair for r5
// 1C298: could not find valid save-restore pair for r6
// 1C298: could not find valid save-restore pair for r7
// 1C298: could not find valid save-restore pair for r8
// 1C298: could not find valid save-restore pair for r9
// 3488: using guessed type int __cdecl SDL_GetError(_DWORD, _DWORD);
// 3574: using guessed type int __fastcall SDL_HideWindow(_DWORD);
// 3580: using guessed type int __fastcall SDL_GL_SetAttribute(_DWORD, _DWORD);
// 3680: using guessed type int __fastcall SDL_GetCurrentVideoDriver(_DWORD);
// 3730: using guessed type int __fastcall SetUseRegal(_DWORD);
// 3784: using guessed type int __cdecl CommandLine_Tier0(_DWORD, _DWORD);
// 3828: using guessed type int __fastcall SDL_WasInit(_DWORD);
// 38B4: using guessed type int __fastcall SDL_GL_LoadLibrary(_DWORD);
// 390C: using guessed type int __fastcall SDL_Init(_DWORD);
// 3A48: using guessed type int __fastcall Msg(_DWORD);
// 3B04: using guessed type int __fastcall SDL_SetRegalMode(_DWORD);

//----- (0001C550) --------------------------------------------------------
signed int __fastcall sub_1C550(int a1)
{
  int v1; // lr@0
  signed int result; // r0@2
  _DWORD *v3; // [sp+0h] [bp+0h]@1
  int v4; // [sp+4h] [bp+4h]@1

  v3 = &v3;
  v4 = v1;
  if ( *(_DWORD *)(a1 + 20) )
  {
    result = 1;
  }
  else
  {
    sub_1C298(a1);
    result = 1;
  }
  return result;
}
// 1C550: could not find valid save-restore pair for r7

//----- (0001C568) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_1C568(int a1, int a2, int a3, int a4)
{
  int v5; // r5@0 OVERLAPPED
  int v7; // lr@0
  int v8; // r4@1
  const pthread_mutexattr_t *v9; // r6@1
  pthread_mutex_t *v10; // r5@1
  __int64 v12; // [sp+0h] [bp+0h]@1
  __int64 v13; // [sp+8h] [bp+8h]@1
  __int64 *v14; // [sp+10h] [bp+10h]@1
  int v15; // [sp+14h] [bp+14h]@1

  v12 = *(_QWORD *)&a4;
  v8 = a1;
  v13 = *(_QWORD *)&v5;
  v9 = (const pthread_mutexattr_t *)(a1 + 244);
  v14 = &v12;
  v15 = v7;
  *(_DWORD *)a1 = &off_28B18;
  v10 = (pthread_mutex_t *)(a1 + 240);
  pthread_mutexattr_init((pthread_mutexattr_t *)(a1 + 244));
  pthread_mutexattr_settype(v9, 1);
  pthread_mutex_init(v10, v9);
  *(_QWORD *)(v8 + 256) = 0LL;
  *(_DWORD *)(v8 + 264) = 0;
  *(_QWORD *)(v8 + 280) = 0LL;
  *(_QWORD *)(v8 + 292) = 0LL;
  *(_QWORD *)(v8 + 300) = 0LL;
  *(_QWORD *)(v8 + 320) = 0LL;
  *(_DWORD *)(v8 + 332) = 0;
  *(_DWORD *)(v8 + 20) = 0;
  *(_DWORD *)(v8 + 288) = -1;
  *(_DWORD *)(v8 + 268) = -1;
  *(_DWORD *)(v8 + 272) = -1;
  *(_DWORD *)(v8 + 276) = -1;
  *(_DWORD *)(v8 + 328) = -1;
  *(_DWORD *)(v8 + 308) = -1;
  *(_DWORD *)(v8 + 312) = -1;
  *(_DWORD *)(v8 + 316) = -1;
  sub_1C298(v8);
  return v8;
}
// 1C568: could not find valid save-restore pair for r4
// 1C568: could not find valid save-restore pair for r5
// 1C568: could not find valid save-restore pair for r6
// 1C568: could not find valid save-restore pair for r7
// 1C568: variables would overlap: r3.4 and r3.8
// 1C568: variables would overlap: r4.4 and r3.8
// 1C568: variables would overlap: r5.4 and r5.8
// 1C568: variables would overlap: r6.4 and r5.8
// 36A8: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);
// 28B18: using guessed type void *;

//----- (0001C630) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall sub_1C630(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int result; // r0@1
  int v7; // r4@2
  int v8; // r1@2
  int v9; // r2@2
  int v10; // r3@2
  __int64 v11; // [sp+0h] [bp+0h]@1
  __int64 *v12; // [sp+8h] [bp+8h]@1
  int v13; // [sp+Ch] [bp+Ch]@1

  v11 = *(_QWORD *)&a4;
  v12 = &v11;
  v13 = v5;
  result = dword_2DF8C;
  if ( !dword_2DF8C )
  {
    v7 = operator new(0x178u);
    sub_1C568(v7, v8, v9, v10);
    result = v7;
    dword_2DF8C = v7;
  }
  return result;
}
// 1C630: could not find valid save-restore pair for r4
// 1C630: could not find valid save-restore pair for r7
// 1C630: variables would overlap: r3.4 and r3.8
// 1C630: variables would overlap: r4.4 and r3.8
// 2DF8C: using guessed type int dword_2DF8C;

//----- (0001C670) --------------------------------------------------------
signed int __fastcall sub_1C670(int a1, int a2, int a3, signed int a4, signed int a5)
{
  int v5; // lr@0
  signed int v6; // r8@1
  int v7; // r9@1
  int v8; // r4@1
  int v9; // r11@1
  signed int v10; // r5@1
  bool v11; // zf@1
  bool v12; // nf@1
  signed int v13; // r6@4
  int v14; // r0@6
  signed int v15; // r5@11
  int v17; // r5@5
  signed int v18; // r0@30
  int v19; // [sp+8h] [bp+0h]@5
  int v20; // [sp+10h] [bp+8h]@5
  int v21; // [sp+18h] [bp+10h]@5
  int v22; // [sp+3Ch] [bp+34h]@1

  v6 = a4;
  v7 = a2;
  v8 = a1;
  v22 = v5;
  v9 = a3;
  *(_BYTE *)(a1 + 37) = 0;
  v10 = a5;
  v11 = a5 == 0;
  v12 = a5 < 0;
  if ( a5 > 0 )
  {
    v11 = a4 == 0;
    v12 = a4 < 0;
  }
  if ( !v12 && !v11 )
  {
    v13 = 1;
    goto LABEL_6;
  }
  v17 = *(_DWORD *)a1;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  (*(void (__cdecl **)(int))(v17 + 76))(a1);
  if ( !v19 )
    v19 = 1024;
  if ( !v20 )
    v20 = 768;
  v6 = *(_DWORD *)(v8 + 64);
  if ( v6 )
  {
    v10 = *(_DWORD *)(v8 + 68);
    if ( v10 )
    {
LABEL_19:
      v13 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    v10 = *(_DWORD *)(v8 + 68);
    v6 = v19;
    if ( v10 )
      goto LABEL_19;
  }
  v10 = v20;
  v13 = 0;
LABEL_6:
  v14 = *(_DWORD *)(v8 + 20);
  if ( v14 )
  {
    if ( v7 )
      SDL_SetWindowTitle(v14);
    if ( *(_BYTE *)(v8 + 34) != (v9 ^ 1) )
    {
LABEL_10:
      (*(void (__fastcall **)(int))(*(_DWORD *)v8 + 44))(v8);
      if ( !v13 )
        return 1;
LABEL_23:
      SDL_ShowWindow(*(_DWORD *)(v8 + 20));
      SDL_RaiseWindow(*(_DWORD *)(v8 + 20));
      v15 = 1;
      *(_BYTE *)(v8 + 37) = 1;
      return v15;
    }
    if ( v9 )
    {
      if ( !v13 )
        return 1;
    }
    else
    {
      if ( *(_DWORD *)(dword_2DF5C + 48) != *(_DWORD *)(dword_2E2F4 + 48) )
        goto LABEL_10;
      if ( !v13 )
        return 1;
    }
    (*(void (__fastcall **)(int, signed int, signed int))(*(_DWORD *)v8 + 56))(v8, v6, v10);
    goto LABEL_23;
  }
  sub_1BEE4(v8, v7, v6, v10);
  v15 = v18;
  if ( v18 )
    SDL_ShowWindow(*(_DWORD *)(v8 + 20));
  return v15;
}
// 3880: using guessed type int __cdecl SDL_SetWindowTitle(_DWORD);
// 3960: using guessed type int __fastcall SDL_ShowWindow(_DWORD);
// 3A3C: using guessed type int __fastcall SDL_RaiseWindow(_DWORD);
// 2DF5C: using guessed type int dword_2DF5C;
// 2E2F4: using guessed type int dword_2E2F4;

//----- (0001C7A4) --------------------------------------------------------
int __fastcall sub_1C7A4(int a1, signed int a2, int a3, int a4)
{
  int v4; // lr@0
  signed int v7; // r5@1
  int v8; // r4@1
  int v10; // r10@1
  int v15; // r0@2
  int result; // r0@2
  int v17; // r0@3
  signed int v18; // r1@3
  int v19; // r0@8
  int v20; // r2@10
  int v21; // r6@10
  int v22; // r0@13
  int v23; // [sp+0h] [bp+0h]@1
  int v24; // [sp+4h] [bp+4h]@13
  double v25; // [sp+8h] [bp+8h]@11
  int v26; // [sp+18h] [bp+18h]@2
  int v27; // [sp+1Ch] [bp+1Ch]@2
  int v28; // [sp+20h] [bp+20h]@2
  int v29; // [sp+24h] [bp+24h]@2
  int v30; // [sp+28h] [bp+28h]@2
  int v31; // [sp+4Ch] [bp+4Ch]@1

  _R9 = a4;
  _R8 = a3;
  v7 = a2;
  v8 = a1;
  v31 = v4;
  _R7 = &v23;
  v10 = *(_DWORD *)(dword_2DF5C + 48);
  if ( !a2 )
  {
    __asm { VMOV.F32        D16, #1.0 }
    v15 = *(_DWORD *)(a1 + 20);
    v29 = (unsigned __int8)a2;
    v27 = a3;
    v26 = 371595268;
    v28 = a4;
    __asm { VSTR            D16, [R4,#0xE8] }
    v30 = (unsigned __int8)a2;
    result = SDL_SetWindowDisplayMode(v15, &v26);
    if ( !*(_BYTE *)(v8 + 34) )
      return result;
    sub_B330((int)&unk_2E2D8, -1);
    v17 = *(_DWORD *)(v8 + 20);
    v18 = v7;
    goto LABEL_4;
  }
  if ( SDL_GetDesktopDisplayMode(*(_DWORD *)(dword_2DF5C + 48), &v26) )
    SDL_GetDesktopDisplayMode(0, &v26);
  __asm { VLDR            S12, [R7,#0x50+var_34] }
  v19 = *(_DWORD *)(v8 + 20);
  __asm { VLDR            S13, [R7,#0x50+var_30] }
  v26 = 371595268;
  __asm
  {
    VCVT.F32.S32    S14, S12
    VMOV            S12, R8
    VCVT.F32.S32    S15, S13
    VCVT.F32.S32    S13, S12
    VMOV            S12, R9
    VDIV.F32        S14, S13, S14
    VCVT.F32.S32    S13, S12
    VDIV.F32        S15, S13, S15
    VSTR            S14, [R4,#0xE8]
    VSTR            S15, [R4,#0xEC]
  }
  result = SDL_SetWindowDisplayMode(v19, &v26);
  if ( !*(_BYTE *)(v8 + 34) || v10 != *(_DWORD *)(dword_2E2F4 + 48) )
  {
    if ( SDL_GetNumVideoDisplays(result) > 1 )
    {
      __asm
      {
        VMOV.I32        Q8, #0
        VSTR            D16, [R7,#0x50+var_48]
        VSTR            D17, [R7,#0x50+var_40]
      }
      SDL_GetDisplayBounds(v10, &v25);
      v20 = HIDWORD(v25);
      v21 = LODWORD(v25);
    }
    else
    {
      v20 = 0;
      v21 = 0;
    }
    if ( *(_BYTE *)(v8 + 34) )
    {
      v22 = *(_DWORD *)(v8 + 20);
      v24 = v20;
      SDL_SetWindowFullscreen(v22, 0);
      ThreadSleep(15);
    }
    SDL_SetWindowPosition(*(_DWORD *)(v8 + 20), v21);
    (*(void (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 56))(v8, _R8, _R9);
    sub_B330((int)&unk_2E2D8, v10);
    v17 = *(_DWORD *)(v8 + 20);
    v18 = 4097;
LABEL_4:
    result = SDL_SetWindowFullscreen(v17, v18);
    *(_BYTE *)(v8 + 34) = v7;
  }
  return result;
}
// 3454: using guessed type int __fastcall SDL_SetWindowPosition(_DWORD, _DWORD);
// 3674: using guessed type int __fastcall SDL_GetNumVideoDisplays(_DWORD);
// 36F0: using guessed type int __fastcall SDL_SetWindowDisplayMode(_DWORD, _DWORD);
// 3804: using guessed type int __fastcall SDL_GetDesktopDisplayMode(_DWORD, _DWORD);
// 3810: using guessed type int __fastcall SDL_GetDisplayBounds(_DWORD, _DWORD);
// 3874: using guessed type int __fastcall ThreadSleep(_DWORD);
// 3A54: using guessed type int __fastcall SDL_SetWindowFullscreen(_DWORD, _DWORD);
// 2DF5C: using guessed type int dword_2DF5C;
// 2E2F4: using guessed type int dword_2E2F4;

//----- (0001C954) --------------------------------------------------------
int __fastcall sub_1C954(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(a1 + 20);
}

//----- (0001C964) --------------------------------------------------------
int __fastcall sub_1C964(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_BYTE *)(a1 + 34);
}

//----- (0001C978) --------------------------------------------------------
int __fastcall sub_1C978(int a1)
{
  int *v2; // [sp+0h] [bp+0h]@1

  v2 = (int *)&v2;
  return *(_DWORD *)(a1 + 4);
}

//----- (0001C988) --------------------------------------------------------
int __fastcall sub_1C988(int result, char a2)
{
  *(_BYTE *)(result + 36) = a2;
  return result;
}

//----- (0001C99C) --------------------------------------------------------
int __fastcall sub_1C99C(int result)
{
  int *v5; // [sp+0h] [bp+0h]@1

  v5 = (int *)&v5;
  __asm { VLDR            D0, [R0,#0x170] }
  return result;
}

//----- (0001C9B0) --------------------------------------------------------
int __fastcall sub_1C9B0(int result)
{
  int v1; // r3@1
  int v2; // r3@2
  int v3; // r2@3
  int v4; // r1@3
  int v5; // r3@4
  int *v6; // [sp+0h] [bp+0h]@1

  v1 = *(_DWORD *)(result + 32);
  v6 = (int *)&v6;
  if ( v1 != -1 )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 != -1 )
    {
      do
      {
        v3 = *(_DWORD *)result + 48 * v2;
        v4 = *(_DWORD *)(v3 + 44);
        *(_DWORD *)(v3 + 40) = v2;
        v2 = v4;
      }
      while ( v4 != -1 );
      *(_DWORD *)(v3 + 44) = *(_DWORD *)(result + 20);
      v5 = *(_DWORD *)(result + 12);
      if ( v5 != -1 )
        *(_DWORD *)(result + 20) = v5;
    }
    *(_DWORD *)(result + 12) = -1;
    *(_DWORD *)(result + 16) = -1;
    *(_DWORD *)(result + 24) = 0;
  }
  return result;
}

//----- (0001CAA8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_1CAA8(int a1, int a2, int a3, int a4)
{
  int v5; // lr@0
  int v6; // r4@1
  void *v7; // r0@2
  int v8; // [sp+0h] [bp+0h]@1
  int *v9; // [sp+8h] [bp+8h]@1
  int v10; // [sp+Ch] [bp+Ch]@1

  v9 = &v8;
  v10 = v5;
  *(_QWORD *)&v8 = *(_QWORD *)&a4;
  v6 = a1;
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v7 = *(void **)a1;
    if ( v7 )
    {
      free(v7);
      *(_DWORD *)v6 = 0;
    }
    *(_DWORD *)(v6 + 4) = 0;
  }
}
// 1CAA8: could not find valid save-restore pair for r4
// 1CAA8: could not find valid save-restore pair for r7
// 1CAA8: variables would overlap: r3.4 and r3.8
// 1CAA8: variables would overlap: r4.4 and r3.8

//----- (0001CB40) --------------------------------------------------------
int __fastcall sub_1CB40(int result, int a2)
{
  int v2; // r11@1
  int v3; // r8@1
  int v4; // r5@2
  int v5; // r4@2

  v2 = a2;
  v3 = result;
  if ( a2 > 0 )
  {
    v4 = 0;
    v5 = 0;
    do
    {
      if ( !dword_2E35C )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VFileSystem022");
        dword_2E35C = result;
      }
      if ( !dword_2E360 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VMaterialSystem080");
        dword_2E360 = result;
        dword_2E364 = result;
      }
      if ( !dword_2E368 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("InputSystemVersion001");
        dword_2E368 = result;
      }
      if ( !dword_2E36C )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("NetworkSystemVersion001");
        dword_2E36C = result;
      }
      if ( !dword_2E370 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("MaterialSystemHardwareConfig012");
        dword_2E370 = result;
      }
      if ( !dword_2E374 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("DebugTextureInfo001");
        dword_2E374 = result;
      }
      if ( !dword_2E378 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VBAllocTracker001");
        dword_2E378 = result;
      }
      if ( !dword_2E37C )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("COLORCORRECTION_VERSION_1");
        dword_2E37C = result;
      }
      if ( !dword_2E380 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VP4001");
        dword_2E380 = result;
      }
      if ( !dword_2E384 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VMDLLIB001");
        dword_2E384 = result;
      }
      if ( !dword_2E388 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("QueuedLoaderVersion004");
        dword_2E388 = result;
      }
      ++v5;
      v4 += 4;
    }
    while ( v5 != v2 );
  }
  return result;
}
// 1CB40: could not find valid save-restore pair for r4
// 1CB40: could not find valid save-restore pair for r5
// 1CB40: could not find valid save-restore pair for r6
// 1CB40: could not find valid save-restore pair for r7
// 1CB40: could not find valid save-restore pair for r8
// 1CB40: could not find valid save-restore pair for r9
// 1CB40: could not find valid save-restore pair for r10
// 1CB40: could not find valid save-restore pair for r11
// 2E35C: using guessed type int dword_2E35C;
// 2E360: using guessed type int dword_2E360;
// 2E364: using guessed type int dword_2E364;
// 2E368: using guessed type int dword_2E368;
// 2E36C: using guessed type int dword_2E36C;
// 2E370: using guessed type int dword_2E370;
// 2E374: using guessed type int dword_2E374;
// 2E378: using guessed type int dword_2E378;
// 2E37C: using guessed type int dword_2E37C;
// 2E380: using guessed type int dword_2E380;
// 2E384: using guessed type int dword_2E384;
// 2E388: using guessed type int dword_2E388;

//----- (0001CD10) --------------------------------------------------------
void sub_1CD10()
{
  dword_2E35C = 0;
  dword_2E364 = 0;
  dword_2E360 = 0;
  dword_2E370 = 0;
  dword_2E374 = 0;
  dword_2E368 = 0;
  dword_2E36C = 0;
  dword_2E37C = 0;
  dword_2E380 = 0;
  dword_2E384 = 0;
  dword_2E388 = 0;
}
// 2E35C: using guessed type int dword_2E35C;
// 2E360: using guessed type int dword_2E360;
// 2E364: using guessed type int dword_2E364;
// 2E368: using guessed type int dword_2E368;
// 2E36C: using guessed type int dword_2E36C;
// 2E370: using guessed type int dword_2E370;
// 2E374: using guessed type int dword_2E374;
// 2E37C: using guessed type int dword_2E37C;
// 2E380: using guessed type int dword_2E380;
// 2E384: using guessed type int dword_2E384;
// 2E388: using guessed type int dword_2E388;

//----- (0001CD40) --------------------------------------------------------
int __fastcall sub_1CD40(int result, int a2)
{
  int v2; // r11@1
  int v3; // r8@1
  int v4; // r4@2
  int v5; // r5@2

  v2 = a2;
  v3 = result;
  if ( a2 > 0 )
  {
    v4 = 0;
    v5 = 0;
    do
    {
      if ( !dword_2E3BC )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VStudioRender025");
        dword_2E3C0 = result;
        dword_2E3BC = result;
      }
      if ( !dword_2E3C4 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VGUI_ivgui008");
        dword_2E3C4 = result;
      }
      if ( !dword_2E3C8 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VGUI_Input005");
        dword_2E3C8 = result;
      }
      if ( !dword_2E3CC )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VGUI_Panel009");
        dword_2E3CC = result;
      }
      if ( !dword_2E3D0 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VGUI_Surface030");
        dword_2E3D0 = result;
      }
      if ( !dword_2E3D4 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VGUI_Scheme010");
        dword_2E3D4 = result;
      }
      if ( !dword_2E3D8 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VGUI_System010");
        dword_2E3D8 = result;
      }
      if ( !dword_2E3DC )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VGUI_Localize005");
        dword_2E3DC = result;
      }
      if ( !dword_2E3E0 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("MatSystemSurface008");
        dword_2E3E0 = result;
      }
      if ( !dword_2E3E4 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VDataCache003");
        dword_2E3E4 = result;
      }
      if ( !dword_2E3E8 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("MDLCache004");
        dword_2E3EC = result;
        dword_2E3E8 = result;
      }
      if ( !dword_2E3F0 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("IVideoServices002");
        dword_2E3F0 = result;
      }
      if ( !dword_2E3F4 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VDmeMakeFileUtils001");
        dword_2E3F4 = result;
      }
      if ( !dword_2E3F8 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VPhysicsCollision007");
        dword_2E3F8 = result;
      }
      if ( !dword_2E3FC )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VSoundEmitter002");
        dword_2E3FC = result;
      }
      if ( !dword_2E400 )
      {
        result = (*(int (__fastcall **)(const char *))(v3 + v4))("VTEX_003");
        dword_2E400 = result;
      }
      ++v5;
      v4 += 4;
    }
    while ( v5 != v2 );
  }
  return result;
}
// 1CD40: could not find valid save-restore pair for r4
// 1CD40: could not find valid save-restore pair for r5
// 1CD40: could not find valid save-restore pair for r6
// 1CD40: could not find valid save-restore pair for r7
// 1CD40: could not find valid save-restore pair for r8
// 1CD40: could not find valid save-restore pair for r9
// 1CD40: could not find valid save-restore pair for r10
// 1CD40: could not find valid save-restore pair for r11
// 2E3BC: using guessed type int dword_2E3BC;
// 2E3C0: using guessed type int dword_2E3C0;
// 2E3C4: using guessed type int dword_2E3C4;
// 2E3C8: using guessed type int dword_2E3C8;
// 2E3CC: using guessed type int dword_2E3CC;
// 2E3D0: using guessed type int dword_2E3D0;
// 2E3D4: using guessed type int dword_2E3D4;
// 2E3D8: using guessed type int dword_2E3D8;
// 2E3DC: using guessed type int dword_2E3DC;
// 2E3E0: using guessed type int dword_2E3E0;
// 2E3E4: using guessed type int dword_2E3E4;
// 2E3E8: using guessed type int dword_2E3E8;
// 2E3EC: using guessed type int dword_2E3EC;
// 2E3F0: using guessed type int dword_2E3F0;
// 2E3F4: using guessed type int dword_2E3F4;
// 2E3F8: using guessed type int dword_2E3F8;
// 2E3FC: using guessed type int dword_2E3FC;
// 2E400: using guessed type int dword_2E400;

//----- (0001CFD0) --------------------------------------------------------
void sub_1CFD0()
{
  dword_2E3BC = 0;
  dword_2E3C0 = 0;
  dword_2E3C4 = 0;
  dword_2E3C8 = 0;
  dword_2E3CC = 0;
  dword_2E3D0 = 0;
  dword_2E3DC = 0;
  dword_2E3D4 = 0;
  dword_2E3D8 = 0;
  dword_2E3E0 = 0;
  dword_2E3E4 = 0;
  dword_2E3E8 = 0;
  dword_2E3EC = 0;
  dword_2E3F0 = 0;
  dword_2E3F8 = 0;
  dword_2E3F4 = 0;
  dword_2E3FC = 0;
  dword_2E400 = 0;
}
// 2E3BC: using guessed type int dword_2E3BC;
// 2E3C0: using guessed type int dword_2E3C0;
// 2E3C4: using guessed type int dword_2E3C4;
// 2E3C8: using guessed type int dword_2E3C8;
// 2E3CC: using guessed type int dword_2E3CC;
// 2E3D0: using guessed type int dword_2E3D0;
// 2E3D4: using guessed type int dword_2E3D4;
// 2E3D8: using guessed type int dword_2E3D8;
// 2E3DC: using guessed type int dword_2E3DC;
// 2E3E0: using guessed type int dword_2E3E0;
// 2E3E4: using guessed type int dword_2E3E4;
// 2E3E8: using guessed type int dword_2E3E8;
// 2E3EC: using guessed type int dword_2E3EC;
// 2E3F0: using guessed type int dword_2E3F0;
// 2E3F4: using guessed type int dword_2E3F4;
// 2E3F8: using guessed type int dword_2E3F8;
// 2E3FC: using guessed type int dword_2E3FC;
// 2E400: using guessed type int dword_2E400;

//----- (0001D010) --------------------------------------------------------
int __fastcall ceill(int a1, int a2, __int64 _R2)
{
  int result; // r0@1
  int v9; // r1@1
  unsigned int v10; // r7@12

  __asm
  {
    VMOV            R2, R3, D0; Alternative name is 'ceil'
    VMOV            R12, S0
  }
  result = (HIDWORD(_R2) >> 20) & 0x7FF;
  v9 = result - 1023;
  if ( result - 1023 > 19 )
  {
    if ( v9 <= 51 )
    {
      v10 = 0xFFFFFFFF >> ((HIDWORD(_R2) >> 20) - 19);
      if ( v10 & (unsigned int)_R2 )
      {
        __asm
        {
          VLDR            D7, =1.0e300
          VADD.F64        D0, D0, D7
          VCMPE.F64       D0, #0.0
          VMRS            APSR_nzcv, FPSCR
        }
        if ( (unsigned __int8)(_NF ^ _VF) | _ZF )
        {
LABEL_6:
          result = _R12;
          __asm { VMOV            D0, R0, R1 }
          return result;
        }
        if ( _R2 > 0 && v9 != 20 )
          _R12 = _R2 + (1 << (51 - result));
        result = _R12 & ~v10;
        __asm { VMOV            D0, R0, R1 }
      }
    }
    else
    {
      _ZF = v9 == 1024;
      if ( _ZF )
        __asm { VADDEQ.F64      D0, D0, D0 }
    }
  }
  else
  {
    if ( v9 < 0 )
    {
      __asm
      {
        VLDR            D3, =1.0e300
        VADD.F64        D4, D0, D3
        VCMPE.F64       D4, #0.0
        VMRS            APSR_nzcv, FPSCR
      }
      if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
      {
        if ( SHIDWORD(_R2) < 0 )
        {
          _R12 = 0;
        }
        else
        {
          _R12 = HIDWORD(_R2) | _R2;
          if ( _R2 )
            _R12 = 0;
        }
      }
      goto LABEL_6;
    }
    result = (0xFFFFF >> v9) & HIDWORD(_R2);
    if ( result | (unsigned int)_R2 )
    {
      __asm
      {
        VLDR            D1, =1.0e300
        VADD.F64        D2, D0, D1
        VCMPE.F64       D2, #0.0
        VMRS            APSR_nzcv, FPSCR
      }
      if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
        _R12 = 0;
      goto LABEL_6;
    }
  }
  return result;
}

//----- (0001D168) --------------------------------------------------------
void sinf()
{
  int v5; // r3@1
  int v9; // r2@35
  __int64 v11; // [sp+8h] [bp-20h]@35
  double v12; // [sp+10h] [bp-18h]@35

  __asm { VMOV            R4, S0 }
  v5 = _R4 & 0x7FFFFFFF;
  if ( (_R4 & 0x7FFFFFFF) > 1061752794 )
  {
    if ( v5 > 1081824209 )
    {
      if ( v5 > 1088565717 )
      {
        _VF = __OFSUB__(v5, 2139095039);
        _ZF = v5 == 2139095039;
        _NF = v5 - 2139095039 < 0;
        if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
        {
          __asm { VSUBGT.F32      S0, S0, S0 }
          return;
        }
        HIDWORD(_R6) = 1305022426;
        if ( v5 > 1305022426 )
        {
          v9 = (v5 >> 23) - 150;
          _R3 = (_R4 & 0x7FFFFFFF) - (v9 << 23);
          __asm
          {
            VMOV            S14, R3
            VCVT.F64.F32    D0, S14
            VMOV            R6, R7, D0
          }
          v11 = _R6;
          _R0 = sub_1D538((int)&v11, (int)&v12, v9, 1, 0);
          __asm { VLDR            D0, [SP,#0x28+var_18] }
          if ( _NF ^ _VF )
          {
            __asm { VNEGLT.F64      D0, D0 }
            _R0 = -_R0;
          }
        }
        else
        {
          __asm
          {
            VLDR            D1, =6.75539944e15
            VLDR            D4, =0.636619772
            VLDR            D5, =1.57079631
            VLDR            D6, =1.58932548e-8
            VCVT.F64.F32    D0, S0
            VMOV.F64        D3, D1
            VMLA.F64        D3, D0, D4
            VSUB.F64        D7, D3, D1
            VMLS.F64        D0, D7, D5
            VCVTR.S32.F64   S7, D7
            VMLS.F64        D0, D7, D6
            VMOV            R0, S7
          }
        }
        if ( (_R0 & 3) != 1 )
        {
          if ( (_R0 & 3) == 2 )
          {
            __asm
            {
              VNEG.F64        D1, D0
              VLDR            D3, =0.00833332939
              VLDR            D5, =0.166666666
              VLDR            D2, =0.00000271831149
              VLDR            D6, =0.000198393348
              VMUL.F64        D7, D1, D1
              VNMLS.F64       D5, D7, D3
              VMUL.F64        D4, D1, D7
              VMUL.F64        D1, D7, D7
              VNMLS.F64       D0, D4, D5
              VNMLS.F64       D6, D7, D2
              VMUL.F64        D3, D1, D4
              VMLA.F64        D0, D6, D3
              VCVT.F32.F64    S0, D0
            }
          }
          else
          {
            if ( !(_R0 & 3) )
            {
              __asm
              {
                VMUL.F64        D1, D0, D0
                VLDR            D4, =0.00833332939
                VLDR            D5, =0.166666666
                VLDR            D2, =0.00000271831149
                VLDR            D6, =0.000198393348
              }
              goto LABEL_6;
            }
            __asm
            {
              VLDR            D1, =-0.499999997
              VLDR            D4, =0.0416666233
              VLDR            D3, =0.0000243904488
              VLDR            D6, =0.00138867638
              VMUL.F64        D0, D0, D0
              VMOV.F64        D2, #1.0
              VMLA.F64        D2, D0, D1
              VMUL.F64        D5, D0, D0
              VNMLS.F64       D6, D0, D3
              VMLA.F64        D2, D5, D4
              VMUL.F64        D7, D0, D5
              VMLA.F64        D2, D6, D7
              VCVT.F32.F64    S1, D2
              VNEG.F32        S0, S1
            }
          }
          return;
        }
        __asm
        {
          VMUL.F64        D2, D0, D0
          VLDR            D5, =-0.499999997
          VLDR            D4, =0.0416666233
          VLDR            D1, =0.0000243904488
          VLDR            D6, =0.00138867638
        }
LABEL_14:
        __asm
        {
          VMOV.F64        D0, #1.0
          VMLA.F64        D0, D2, D5
          VMUL.F64        D5, D2, D2
          VNMLS.F64       D6, D2, D1
          VMLA.F64        D0, D5, D4
          VMUL.F64        D1, D2, D5
          VMLA.F64        D0, D6, D1
          VCVT.F32.F64    S0, D0
        }
        return;
      }
      __asm { VCVT.F64.F32    D0, S0 }
      if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
      {
        __asm
        {
          VLDR            D3, =-6.28318531
          VLDR            D7, =6.28318531
          VLDR            D4, =0.00833332939
        }
        if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
          __asm { VMOVGT.F64      D7, D3 }
        __asm
        {
          VLDR            D5, =0.166666666
          VLDR            D2, =0.00000271831149
          VLDR            D6, =0.000198393348
          VADD.F64        D0, D0, D7
        }
        goto LABEL_5;
      }
      __asm { VLDR            D7, =4.71238898 }
      if ( (unsigned __int8)(_NF ^ _VF) | _ZF )
      {
        __asm
        {
          VLDR            D5, =-0.499999997
          VLDR            D4, =0.0416666233
          VLDR            D1, =0.0000243904488
          VLDR            D6, =0.00138867638
          VADD.F64        D2, D0, D7
        }
        goto LABEL_13;
      }
      __asm
      {
        VSUB.F64        D6, D0, D7
        VLDR            D4, =-0.499999997
        VLDR            D1, =0.0416666233
        VLDR            D3, =0.0000243904488
        VLDR            D5, =0.00138867638
      }
    }
    else
    {
      __asm { VCVT.F64.F32    D0, S0 }
      if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
      {
        __asm
        {
          VLDR            D1, =-3.14159265
          VLDR            D7, =3.14159265
          VLDR            D4, =0.00833332939
        }
        if ( (unsigned __int8)(_NF ^ _VF) | _ZF )
          __asm { VMOVLE.F64      D7, D1 }
        __asm
        {
          VLDR            D5, =0.166666666
          VLDR            D2, =0.00000271831149
          VLDR            D6, =0.000198393348
          VSUB.F64        D0, D7, D0
        }
        goto LABEL_5;
      }
      if ( _R4 > 0 )
      {
        __asm
        {
          VLDR            D7, =1.57079633
          VSUB.F64        D2, D0, D7
          VLDR            D5, =-0.499999997
          VLDR            D4, =0.0416666233
          VLDR            D1, =0.0000243904488
          VLDR            D6, =0.00138867638
        }
LABEL_13:
        __asm { VMUL.F64        D2, D2, D2 }
        goto LABEL_14;
      }
      __asm
      {
        VLDR            D2, =1.57079633
        VLDR            D4, =-0.499999997
        VLDR            D1, =0.0416666233
        VLDR            D3, =0.0000243904488
        VLDR            D5, =0.00138867638
        VADD.F64        D6, D0, D2
      }
    }
    __asm
    {
      VMUL.F64        D6, D6, D6
      VMOV.F64        D0, #1.0
      VMLA.F64        D0, D6, D4
      VMUL.F64        D4, D6, D6
      VNMLS.F64       D5, D6, D3
      VMLA.F64        D0, D4, D1
      VMUL.F64        D3, D6, D4
      VMLA.F64        D0, D5, D3
      VCVT.F32.F64    S3, D0
      VNEG.F32        S0, S3
    }
    return;
  }
  if ( v5 >= 964689920 )
    goto LABEL_45;
  __asm
  {
    VCVTR.S32.F32   S5, S0
    VMOV            R4, S5
  }
  if ( _R4 )
  {
LABEL_45:
    __asm
    {
      VCVT.F64.F32    D0, S0
      VLDR            D4, =0.00833332939
      VLDR            D5, =0.166666666
      VLDR            D2, =0.00000271831149
      VLDR            D6, =0.000198393348
    }
LABEL_5:
    __asm { VMUL.F64        D1, D0, D0 }
LABEL_6:
    __asm
    {
      VNMLS.F64       D5, D1, D4
      VMUL.F64        D4, D0, D1
      VMUL.F64        D3, D1, D1
      VNMLS.F64       D6, D1, D2
      VMLA.F64        D0, D4, D5
      VMUL.F64        D2, D3, D4
      VMLA.F64        D0, D6, D2
      VCVT.F32.F64    S0, D0
    }
  }
}

//----- (0001D538) --------------------------------------------------------
int __fastcall sub_1D538(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4@1
  int v7; // r8@1
  int v8; // r7@1
  int v9; // r6@1
  int v10; // r3@1
  int v11; // r10@1
  int v13; // r2@2
  char *v14; // r12@2
  char *v18; // r5@11
  char *v19; // lr@11
  int v23; // r3@13
  int v24; // r5@17
  int v25; // r12@17
  int *v29; // r3@19
  double v31; // r0@21
  char *v34; // r3@22
  signed int v35; // r12@22
  signed int v37; // r11@22
  char *v40; // r3@25
  signed int v41; // lr@25
  int v42; // t1@29
  int v43; // r12@38
  char *v44; // r3@39
  double v45; // r0@39
  int v46; // t1@40
  char *v47; // r12@43
  int v48; // t1@44
  int v49; // r11@45
  int v50; // r3@45
  char *v51; // r12@46
  int v55; // t1@47
  int v56; // r3@48
  int v57; // r8@59
  int v58; // r2@59
  char *v61; // r4@65
  int v62; // r12@65
  int v65; // lr@68
  char *v76; // r6@123
  int v77; // t1@124
  double v78; // r0@128
  signed int v79; // [sp+4h] [bp-294h]@61
  int v80; // [sp+Ch] [bp-28Ch]@1
  int v81; // [sp+10h] [bp-288h]@1
  char *v82; // [sp+1Ch] [bp-27Ch]@17
  char v83[80]; // [sp+20h] [bp-278h]@25
  char v84[160]; // [sp+70h] [bp-228h]@2
  double v85; // [sp+110h] [bp-188h]@87
  double v86; // [sp+118h] [bp-180h]@98
  char v87[8]; // [sp+1B0h] [bp-E8h]@11
  char v88[152]; // [sp+1B8h] [bp-E0h]@11
  char v89[72]; // [sp+250h] [bp-48h]@17

  v5 = a4;
  _R9 = (unsigned __int64)(715827883LL * (a3 - 3)) >> 32;
  v7 = a1;
  v80 = a2;
  v8 = a4 - 1;
  v9 = dword_20FF4[a5];
  v81 = (a3 - 3) / 24 & ~((a3 - 3) / 24 >> 31);
  v10 = v81 - (a4 - 1);
  v11 = a3 + 24 * ~v81;
  if ( v8 + v9 >= 0 )
  {
    _R1 = v84;
    v13 = 0;
    v14 = (char *)&unk_21004 + 4 * v10;
    do
    {
      _VF = 0;
      _NF = v10++ < 0;
      if ( _NF ^ _VF )
        __asm { VLDRLT          D7, =0.0 }
      else
        _R9 = *(_DWORD *)&v14[v13];
      v13 += 4;
      if ( !(_NF ^ _VF) )
      {
        __asm
        {
          VMOVGE          S13, R9
          VCVTGE.F64.S32  D7, S13
        }
      }
      __asm { VSTMIA          R1!, {D7} }
    }
    while ( !_ZF );
  }
  if ( v9 >= 0 )
  {
    v18 = &v84[8 * v5];
    v19 = &v88[8 * v9];
    _R12 = v87;
    do
    {
      while ( v8 < 0 )
      {
        __asm
        {
          VLDR            D7, =0.0
          VSTMIA          R12!, {D7}
        }
        v18 += 8;
        if ( _R12 == v19 )
          goto LABEL_17;
      }
      _R1 = a1;
      _R2 = v18;
      v23 = 0;
      __asm { VLDR            D7, =0.0 }
      do
      {
        ++v23;
        __asm
        {
          VLDMIA          R1!, {D5}
          VLDMDB          R2!, {D6}
          VMLA.F64        D7, D5, D6
        }
      }
      while ( !_ZF );
      __asm { VSTMIA          R12!, {D7} }
      v18 += 8;
    }
    while ( _R12 != v19 );
  }
LABEL_17:
  v24 = dword_20FF4[a5];
  v25 = 4 * (v9 - 1);
  HIDWORD(_R0) = v89;
  _R2 = (int)&v89[v25];
  __asm { VLDR            D9, =5.96046448e-8 }
  v82 = &v89[v25];
  __asm { VLDR            D8, =1.6777216e7 }
  while ( 1 )
  {
    _LR = &v89[8 * v24];
    __asm { VLDR            D0, [LR,#-0xA0] }
    if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
    {
      HIDWORD(_R0) = v87;
      _R2 = (int)&v87[8 * v24];
      v29 = (int *)&v82;
      do
      {
        __asm
        {
          VMUL.F64        D7, D0, D9
          VLDMDB          R2!, {D1}
          VCVTR.S32.F64   S4, D7
          VCVT.F64.S32    D3, S4
          VMLS.F64        D0, D3, D8
          VCVTR.S32.F64   S0, D0
          VMOV            LR, S0
          VADD.F64        D0, D3, D1
        }
        v29[1] = _LR;
        ++v29;
      }
      while ( (char **)v29 != &(&v82)[4 * v24] );
    }
    LODWORD(_R0) = v11;
    __asm { VMOV.F64        D11, #8.0 }
    v31 = scalbn(_R0, _R2);
    __asm
    {
      VMOV.F64        D4, #0.125
      VMOV.F64        D10, D0
      VMUL.F64        D0, D0, D4
    }
    _R0 = floor(v31);
    __asm
    {
      VMLS.F64        D10, D0, D11
      VCVTR.S32.F64   S23, D10
      VCVT.F64.S32    D7, S23
      VSUB.F64        D10, D10, D7
    }
    if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
    {
      v34 = &v89[4 * (v24 - 1)];
      v35 = *((_DWORD *)v34 - 140);
      _R2 = v35 >> (24 - v11);
      HIDWORD(_R0) = v35 - (_R2 << (24 - v11));
      __asm { VMOV            LR, S23 }
      *((_DWORD *)v34 - 140) = HIDWORD(_R0);
      v37 = SHIDWORD(_R0) >> (23 - v11);
      LODWORD(_R0) = _LR + _R2;
      __asm { VMOV            S23, R0 }
      goto LABEL_23;
    }
    if ( _ZF )
    {
      HIDWORD(_R0) = *(_DWORD *)&v89[4 * v24 - 564];
      v37 = SHIDWORD(_R0) >> 23;
LABEL_23:
      if ( v37 <= 0 )
        goto LABEL_36;
      goto LABEL_24;
    }
    __asm
    {
      VMOV.F64        D5, #0.5
      VCMPE.F64       D10, D5
      VMRS            APSR_nzcv, FPSCR
    }
    if ( _NF ^ _VF )
    {
      v37 = 0;
LABEL_36:
      __asm
      {
        VCMP.F64        D10, #0.0
        VMRS            APSR_nzcv, FPSCR
      }
      if ( !_ZF )
        goto LABEL_59;
      goto LABEL_38;
    }
    v37 = 2;
LABEL_24:
    __asm { VMOV            R3, S23 }
    _R12 = _R3 + 1;
    __asm { VMOV            S23, R12 }
    if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
    {
      LODWORD(_R0) = &v83[4 * v24];
      v40 = v83;
      v41 = 0;
      do
      {
        while ( 1 )
        {
          _R2 = 0xFFFFFF;
          v42 = *(_DWORD *)v40;
          v40 += 4;
          HIDWORD(_R0) = v42;
          if ( !v41 )
            break;
          v41 = 1;
          *((_DWORD *)v40 - 1) = 0xFFFFFF - HIDWORD(_R0);
          if ( v40 == (char *)LODWORD(_R0) )
            goto LABEL_31;
        }
        _R2 = 0x1000000 - HIDWORD(_R0);
        if ( HIDWORD(_R0) )
        {
          *((_DWORD *)v40 - 1) = _R2;
          v41 = 1;
        }
      }
      while ( v40 != (char *)LODWORD(_R0) );
    }
LABEL_31:
    if ( v11 > 0 )
    {
      if ( v11 == 1 )
      {
        HIDWORD(_R0) = &v89[4 * (v24 - 1)];
        _R2 = *(_DWORD *)(HIDWORD(_R0) - 560) & 0x7FFFFF;
        *(_DWORD *)(HIDWORD(_R0) - 560) = _R2;
      }
      else if ( v11 == 2 )
      {
        HIDWORD(_R0) = &v89[4 * (v24 - 1)];
        _R2 = *(_DWORD *)(HIDWORD(_R0) - 560) & 0x3FFFFF;
        *(_DWORD *)(HIDWORD(_R0) - 560) = _R2;
      }
    }
    if ( v37 != 2 )
      goto LABEL_36;
    __asm
    {
      VMOV.F64        D0, #1.0
      VSUB.F64        D10, D0, D10
    }
    if ( _ZF )
      goto LABEL_36;
    LODWORD(_R0) = v11;
    _R0 = scalbn(_R0, _R2);
    __asm
    {
      VSUB.F64        D10, D10, D0
      VCMP.F64        D10, #0.0
      VMRS            APSR_nzcv, FPSCR
    }
    if ( !_ZF )
    {
LABEL_59:
      __asm { VMOV.F64        D0, D10 }
      LODWORD(_R0) = -v11;
      v57 = v9;
      v45 = scalbn(_R0, _R2);
      __asm
      {
        VLDR            D9, =1.6777216e7
        VCMPE.F64       D0, D9
        VMRS            APSR_nzcv, FPSCR
      }
      if ( _NF ^ _VF )
      {
        __asm { VCVTR.S32.F64   S1, D0 }
        v43 = v24;
        __asm { VSTR            S1, [R7,#-0x230] }
      }
      else
      {
        __asm
        {
          VLDR            D6, =5.96046448e-8
          VMUL.F64        D8, D0, D6
        }
        v43 = v24 + 1;
        v11 += 24;
        __asm
        {
          VCVTR.S32.F64   S11, D8
          VCVT.F64.S32    D1, S11
          VMLS.F64        D0, D1, D9
          VCVTR.S32.F64   S3, D0
          VSTR            S3, [R5,#-0x230]
          VSTR            S11, [R6,#-0x230]
        }
      }
      goto LABEL_61;
    }
LABEL_38:
    v43 = v24 - 1;
    if ( v9 <= v24 - 1 )
    {
      v44 = &v83[4 * v24];
      HIDWORD(v45) = 0;
      do
      {
        v46 = *((_DWORD *)v44 - 1);
        v44 -= 4;
        HIDWORD(v45) |= v46;
      }
      while ( v44 != &v83[4 * v9] );
      if ( HIDWORD(v45) )
        break;
    }
    if ( *((_DWORD *)v82 - 140) )
    {
      HIDWORD(_R0) = 1;
    }
    else
    {
      HIDWORD(_R0) = 1;
      v47 = &v83[4 * (v9 - 1)];
      do
      {
        v48 = *((_DWORD *)v47 - 1);
        v47 -= 4;
        _R2 = v48;
        ++HIDWORD(_R0);
      }
      while ( !v48 );
    }
    v49 = v24 + HIDWORD(_R0);
    v50 = v24 + 1;
    if ( v24 + 1 <= v24 + HIDWORD(_R0) )
    {
      HIDWORD(_R0) = v8 + v50;
      v51 = (char *)&unk_21004 + 4 * (v24 + v81);
      _R2 = (int)v87;
      _LR = &v84[8 * (v8 + v50)];
      _R5 = &v87[8 * v50];
      do
      {
        while ( 1 )
        {
          v55 = *((_DWORD *)v51 + 1);
          v51 += 4;
          _R3 = v55;
          __asm
          {
            VMOV            S7, R3
            VCVT.F64.S32    D11, S7
            VSTMIA          LR!, {D11}
          }
          if ( !(_NF ^ _VF) )
            break;
          __asm
          {
            VLDR            D10, =0.0
            VSTMIA          R5!, {D10}
          }
          if ( _ZF )
            goto LABEL_53;
        }
        HIDWORD(_R0) = v7;
        _R2 = (int)_LR;
        v56 = 0;
        __asm { VLDR            D10, =0.0 }
        do
        {
          ++v56;
          __asm
          {
            VLDMIA          R1!, {D7}
            VLDMDB          R2!, {D5}
            VMLA.F64        D10, D7, D5
          }
        }
        while ( !_ZF );
        __asm { VSTMIA          R5!, {D10} }
      }
      while ( !_ZF );
    }
LABEL_53:
    v24 = v49;
  }
  v58 = 4 * v43;
  v57 = v9;
  v11 -= 24;
  if ( !*(_DWORD *)&v89[4 * v43 - 560] )
  {
    v76 = &v83[v58];
    do
    {
      v77 = *((_DWORD *)v76 - 1);
      v76 -= 4;
      --v43;
      v11 -= 24;
    }
    while ( !v77 );
  }
LABEL_61:
  LODWORD(v45) = v11;
  __asm { VMOV.F64        D0, #1.0 }
  v79 = v43;
  scalbn(v45, v58);
  if ( v79 >= 0 )
  {
    __asm { VLDR            D6, =5.96046448e-8 }
    _R3 = &v83[4 * (v79 + 1)];
    _R1 = &v87[8 * (v79 + 1)];
    do
    {
      __asm
      {
        VLDMDB          R3!, {S5}
        VCVT.F64.S32    D2, S5
        VMUL.F64        D8, D2, D0
        VMUL.F64        D0, D0, D6
        VSTMDB          R1!, {D8}
      }
    }
    while ( !_ZF );
    v61 = &v87[8 * v79];
    v62 = 0;
    do
    {
      _VF = 0;
      _NF = v57 < 0;
      if ( _NF ^ _VF )
      {
        __asm { VLDRLT          D8, =0.0 }
      }
      else
      {
        _R9 = &unk_21110;
        _R6 = v61;
        __asm { VLDR            D8, =0.0 }
        v65 = 0;
        do
        {
          ++v65;
          __asm
          {
            VLDMIA          R9!, {D3}
            VLDMIA          R6!, {D6}
            VMLA.F64        D8, D3, D6
          }
        }
        while ( !(_NF ^ _VF) && v65 <= v62 );
      }
      v61 -= 8;
      ++v62;
      __asm { VSTR            D8, [R1,#-0x140] }
    }
    while ( !_ZF );
  }
  switch ( a5 )
  {
    case 0:
      if ( v79 < 0 )
      {
        __asm { VLDR            D0, =0.0 }
        if ( !_ZF )
          __asm { VNEGNE.F64      D0, D0 }
        __asm { VSTR            D0, [R11] }
      }
      else
      {
        __asm { VLDR            D0, =0.0 }
        _R7 = &v85 + v79 + 1;
        do
        {
          __asm
          {
            VLDMDB          R7!, {D4}
            VADD.F64        D0, D0, D4
          }
        }
        while ( !_ZF );
        _ZF = v37 == 0;
        if ( !_ZF )
          __asm { VNEGNE.F64      D0, D0 }
        __asm { VSTR            D0, [R11] }
      }
      goto LABEL_114;
    case 1:
    case 2:
      _VF = 0;
      _NF = v79 < 0;
      if ( _NF ^ _VF )
      {
        __asm { VLDRLT          D8, =0.0 }
      }
      else
      {
        __asm { VLDR            D8, =0.0 }
        _R10 = &v85 + v79 + 1;
        do
        {
          __asm
          {
            VLDMDB          R10!, {D6}
            VADD.F64        D8, D8, D6
          }
        }
        while ( !_ZF );
      }
      __asm
      {
        VLDR            D1, [SP,#0x298+var_188]
        VSUB.F64        D3, D1, D8
      }
      if ( _ZF )
        __asm { VMOVEQ.F64      D6, D8 }
      else
        __asm { VNEGNE.F64      D6, D8 }
      __asm { VSTR            D6, [R3] }
      if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
      {
        _R1 = &v86;
        do
        {
          __asm
          {
            VLDMIA          R1!, {D2}
            VADD.F64        D3, D3, D2
          }
        }
        while ( !_ZF );
      }
      _ZF = v37 == 0;
      if ( !_ZF )
        __asm { VNEGNE.F64      D3, D3 }
      __asm { VSTR            D3, [R12,#8] }
      goto LABEL_114;
    case 3:
      if ( v79 <= 0 )
        goto LABEL_135;
      _R10 = &v89[8 * v79];
      __asm { VLDR            D7, [R10,#-0x140] }
      _R3 = &v85 + v79 + 1;
      do
      {
        __asm
        {
          VLDR            D0, [R3,#-0x10]
          VADD.F64        D4, D7, D0
          VSUB.F64        D5, D0, D4
          VADD.F64        D10, D7, D5
          VSTMDB          R3!, {D10}
          VMOV.F64        D7, D4
          VSTR            D4, [R3,#-8]
        }
      }
      while ( !_ZF );
      if ( v79 <= 1 )
      {
LABEL_135:
        __asm { VLDR            D0, =0.0 }
        if ( !_ZF )
        {
LABEL_98:
          __asm
          {
            VLDR            D4, [SP,#0x298+var_188]
            VNEG.F64        D10, D0
            VLDR            D7, [SP,#0x298+var_180]
            VNEG.F64        D5, D4
            VSTR            D10, [R11,#0x10]
            VNEG.F64        D9, D7
            VSTR            D5, [R11]
            VSTR            D9, [R11,#8]
          }
          goto LABEL_114;
        }
      }
      else
      {
        _R1 = &v85 + v79 + 1;
        _R4 = &v89[8 * v79];
        __asm { VLDR            D2, [R4,#-0x140] }
        do
        {
          __asm
          {
            VLDR            D9, [R1,#-0x10]
            VADD.F64        D6, D9, D2
            VSUB.F64        D8, D9, D6
            VADD.F64        D1, D8, D2
            VSTMDB          R1!, {D1}
            VMOV.F64        D2, D6
            VSTR            D6, [R1,#-8]
          }
        }
        while ( !_ZF );
        _R8 = &v85 + v79 + 1;
        __asm { VLDR            D0, =0.0 }
        do
        {
          __asm
          {
            VLDMDB          R8!, {D3}
            VADD.F64        D0, D0, D3
          }
        }
        while ( !_ZF );
        if ( v37 )
          goto LABEL_98;
      }
      __asm { VSTR            D0, [R7,#0x10] }
      v78 = v86;
      *(double *)v80 = v85;
      *(double *)(v80 + 8) = v78;
LABEL_114:
      __asm { VMOV            R6, S23 ; jumptable 0001DA50 default case }
      return _R6 & 7;
    default:
      goto LABEL_114;
  }
}
// 1D538: using guessed type char var_228[160];
// 1D538: using guessed type char var_E0[152];
// 1D538: using guessed type char var_E8[8];
// 1D538: using guessed type char var_278[80];
// 1D538: using guessed type char var_48[72];

//----- (0001DD48) --------------------------------------------------------
char *__fastcall sub_1DD48(char *result, _DWORD *a2)
{
  int v2; // r12@1
  unsigned int v3; // r3@1
  char v4; // r2@2
  char v5; // t1@2

  v2 = 0;
  v3 = 0;
  do
  {
    v5 = *result++;
    v4 = v5;
    v2 |= (v5 & 0x7F) << v3;
    v3 += 7;
  }
  while ( v5 & 0x80 );
  if ( v3 <= 0x1F && v4 & 0x40 )
    v2 |= -1 << v3;
  *a2 = v2;
  return result;
}

//----- (0001DD8C) --------------------------------------------------------
unsigned int __fastcall sub_1DD8C(int a1, int a2, int a3, int *a4)
{
  char v4; // r5@1
  int v5; // r7@1
  int v6; // r12@3
  char *v7; // r4@3
  unsigned int result; // r0@9
  int v9; // ST04_4@12
  int *v10; // ST00_4@12
  char *v11; // r0@12
  int v12; // r0@13
  char v13; // t1@14
  int v14; // r2@18
  int v15; // [sp+Ch] [bp-1Ch]@12

  v4 = a1;
  v5 = a2;
  if ( a1 == 80 )
  {
    v14 = a3 + 3;
    *a4 = *(_DWORD *)(v14 & 0xFFFFFFFC);
    result = (v14 & 0xFFFFFFFC) + 4;
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
      case 0xB:
        v6 = *(_BYTE *)a3 | (*(_BYTE *)(a3 + 1) << 8) | (*(_BYTE *)(a3 + 2) << 16) | (*(_BYTE *)(a3 + 3) << 24);
        v7 = (char *)(a3 + 4);
        break;
      case 1:
        v6 = 0;
        v12 = 0;
        v7 = (char *)a3;
        do
        {
          v13 = *v7++;
          v6 |= (v13 & 0x7F) << v12;
          v12 += 7;
        }
        while ( v13 & 0x80 );
        break;
      case 2:
        v7 = (char *)(a3 + 2);
        v6 = *(_BYTE *)a3 | (*(_BYTE *)(a3 + 1) << 8);
        break;
      case 4:
      case 0xC:
        v6 = *(_BYTE *)a3 | (*(_BYTE *)(a3 + 1) << 8) | (*(_BYTE *)(a3 + 2) << 16) | (*(_BYTE *)(a3 + 3) << 24);
        v7 = (char *)(a3 + 8);
        break;
      default:
        abort();
        return result;
      case 9:
        v9 = a3;
        v10 = a4;
        v11 = sub_1DD48((char *)a3, &v15);
        v6 = v15;
        a3 = v9;
        a4 = v10;
        v7 = v11;
        break;
      case 0xA:
        v7 = (char *)(a3 + 2);
        v6 = (signed __int16)(*(_BYTE *)a3 | (unsigned __int16)(*(_BYTE *)(a3 + 1) << 8));
        break;
    }
    if ( v6 )
    {
      if ( (v4 & 0x70) != 16 )
        a3 = v5;
      v6 += a3;
      if ( v4 & 0x80 )
        v6 = *(_DWORD *)v6;
    }
    result = (unsigned int)v7;
    *a4 = v6;
  }
  return result;
}

//----- (0001DEFC) --------------------------------------------------------
int __fastcall sub_1DEFC(int a1, int a2)
{
  int v2; // r3@2

  if ( a1 == 255 )
    return 0;
  v2 = a1 & 0x70;
  if ( v2 == 32 )
    return Unwind_GetTextRelBase(a2);
  if ( (a1 & 0x70u) <= 0x20 )
  {
    if ( a1 & 0x70 && v2 != 16 )
      goto LABEL_11;
    return 0;
  }
  if ( v2 != 64 )
  {
    if ( v2 != 80 )
    {
      if ( v2 == 48 )
        return Unwind_GetDataRelBase(a2);
LABEL_11:
      abort();
    }
    return 0;
  }
  return Unwind_GetRegionStart(a2);
}
// 33D8: using guessed type int __fastcall Unwind_GetDataRelBase(_DWORD);
// 3978: using guessed type int __fastcall Unwind_GetRegionStart(_DWORD);
// 3990: using guessed type int __fastcall Unwind_GetTextRelBase(_DWORD);

//----- (0001DF70) --------------------------------------------------------
char *__fastcall sub_1DF70(int a1, _BYTE *a2, int a3)
{
  int v3; // r7@1
  _BYTE *v4; // r5@1
  int v5; // r4@1
  int v6; // r6@3
  _BYTE *v7; // r5@3
  int v8; // r0@5
  int v9; // r3@6
  char *v10; // r0@6
  int v11; // r2@7
  int v12; // r3@7
  char v13; // t1@8
  int v14; // r12@10
  char v15; // r2@10
  int v16; // r3@10
  char *result; // r0@10
  char v18; // t1@11

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( a1 )
    a1 = Unwind_GetRegionStart(a1);
  *(_DWORD *)v5 = a1;
  v6 = *v4;
  v7 = v4 + 1;
  if ( v6 == 255 )
  {
    *(_DWORD *)(v5 + 4) = a1;
  }
  else
  {
    v8 = sub_1DEFC(v6, v3);
    v7 = (_BYTE *)sub_1DD8C(v6, v8, (int)v7, (int *)(v5 + 4));
  }
  v9 = *v7;
  *(_BYTE *)(v5 + 20) = v9;
  v10 = v7 + 1;
  if ( v9 == 255 )
  {
    *(_DWORD *)(v5 + 12) = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    *(_BYTE *)(v5 + 20) = -112;
    do
    {
      v13 = *v10++;
      v11 |= (v13 & 0x7F) << v12;
      v12 += 7;
    }
    while ( v13 & 0x80 );
    *(_DWORD *)(v5 + 12) = &v10[v11];
  }
  v14 = 0;
  v15 = *v10;
  v16 = 0;
  result = v10 + 1;
  *(_BYTE *)(v5 + 21) = v15;
  do
  {
    v18 = *result++;
    v14 |= (v18 & 0x7F) << v16;
    v16 += 7;
  }
  while ( v18 & 0x80 );
  *(_DWORD *)(v5 + 16) = &result[v14];
  return result;
}
// 3978: using guessed type int __fastcall Unwind_GetRegionStart(_DWORD);

//----- (0001E6B8) --------------------------------------------------------
int __fastcall sub_1E6B8(int a1)
{
  int result; // r0@2

  if ( *(_BYTE *)a1 != 71
    || *(_BYTE *)(a1 + 1) != 78
    || *(_BYTE *)(a1 + 2) != 85
    || *(_BYTE *)(a1 + 3) != 67
    || *(_BYTE *)(a1 + 4) != 67
    || *(_BYTE *)(a1 + 5) != 43
    || *(_BYTE *)(a1 + 6) != 43 )
  {
    result = 0;
  }
  else
  {
    result = (unsigned int)*(_BYTE *)(a1 + 7) <= 1;
  }
  return result;
}

//----- (0001E728) --------------------------------------------------------
void __fastcall sub_1E728(int a1)
{
  int v1; // r4@1
  int v2; // r7@4
  void (*v3)(void); // r8@5
  int v4; // r5@5
  int v5; // r6@5
  int v6; // r10@5
  int v7; // r9@5

  v1 = a1;
  if ( !a1 || (((void (*)(void))_cxa_begin_catch)(), !sub_1E6B8(v1)) )
    std::terminate();
  v2 = __cxxabiv1::__terminate(*(void (**)(void))(v1 - 20));
  if ( sub_1E6B8(v2) )
  {
    v3 = *(void (**)(void))(v2 - 24);
    v4 = *(_DWORD *)(v2 - 20);
    v5 = *(_DWORD *)(v2 + 40);
    v6 = *(_DWORD *)(v2 + 48);
    v7 = *(_DWORD *)(v2 + 52);
    _cxa_begin_catch(v2);
    __cxxabiv1::__unexpected(v3);
  }
  _cxa_begin_catch(v2);
  std::unexpected();
}
// 39B4: using guessed type int __fastcall _cxa_begin_catch(_DWORD);

//----- (0001E8C0) --------------------------------------------------------
int __fastcall sub_1E8C0(char *a1, int a2, int a3, int a4)
{
  int v4; // r12@1
  char *v5; // r4@1
  int *v6; // r0@1
  int v7; // lr@1
  int v8; // r8@1
  int v9; // r5@1
  int v10; // ST00_4@1
  void (__cdecl *v11)(int *, int, signed int, int); // r6@1
  int v12; // r2@1
  int v14; // [sp+14h] [bp-2Ch]@1
  int v15; // [sp+18h] [bp-28h]@1
  int v16; // [sp+1Ch] [bp-24h]@1
  int v17; // [sp+20h] [bp-20h]@1
  int v18; // [sp+24h] [bp-1Ch]@1

  v4 = *(_DWORD *)a1;
  v5 = a1;
  v6 = *(int **)(*(_DWORD *)a1 - 4);
  v7 = *v6;
  v8 = a3;
  v9 = a4;
  v10 = (int)&v5[*(_DWORD *)(v4 - 8)];
  v18 = 16;
  v11 = *(void (__cdecl **)(int *, int, signed int, int))(v7 + 28);
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v11(v6, a4, 6, a3);
  v12 = v14;
  if ( !v14 )
    return 0;
  if ( (v17 & 6) != 6 && ((unsigned __int8)v16 & (unsigned __int8)v15 & 6) != 6 )
  {
    if ( (v16 & 5) == 4 || v17 )
      return 0;
    if ( v9 < 0 )
    {
      if ( v9 == -2 || ((*(int (__fastcall **)(int, int))(*(_DWORD *)v8 + 32))(v8, v9) & 6) != 6 )
        return 0;
      v12 = v14;
    }
    else if ( v5 != (char *)(v14 + v9) )
    {
      return 0;
    }
  }
  return v12;
}

//----- (0001E9D4) --------------------------------------------------------
int __fastcall sub_1E9D4(unsigned int a1)
{
  return operator new(a1);
}

// ALL OK, 428 function(s) have been successfully decompiled
